0001   0000             ;==================================================================================
0002   0000             ; Contents of this file are copyright Grant Searle
0003   0000             ; HEX routines from Joel Owens.
0004   0000             ;
0005   0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0006   0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0007   0000             ;
0008   0000             ; http://searle.hostei.com/grant/index.html
0009   0000             ;
0010   0000             ; eMail: home.micros01@btinternet.com
0011   0000             ;
0012   0000             ; If the above don't work, please perform an Internet search to see if I have
0013   0000             ; updated the web page hosting service.
0014   0000             ;
0015   0000             ;==================================================================================
0016   0000             
0017   0000             ;------------------------------------------------------------------------------
0018   0000             ;
0019   0000             ; Z80 Monitor Rom
0020   0000             ;
0021   0000             ;------------------------------------------------------------------------------
0022   0000             ; General Equates
0023   0000             ;------------------------------------------------------------------------------
0024   0000             
0025   0000             ;CR		.EQU	0DH
0026   0000             ;LF		.EQU	0AH
0027   0000             ;ESC		.EQU	1BH
0028   0000             ;CTRLC	.EQU	03H
0029   0000             M_CLS		.EQU	0CH
0030   0000             
0031   0000             
0032   0000             loadAddr	.EQU	0D000h	; CP/M load address
0033   0000             numSecs		.EQU	24	; Number of 512 sectors to be loaded
0034   0000             
0035   0000             
0036   0000             RTS_HIGH	.EQU	0D5H
0037   0000             RTS_LOW		.EQU	095H
0038   0000             
0039   0000             ACIA0_D		.EQU	$81
0040   0000             ACIA0_C		.EQU	$80
0041   0000             ACIA1_D		.EQU	$83
0042   0000             ACIA1_C		.EQU	$82
0043   0000             
0044   0000             SD_DATA		.EQU	088H
0045   0000             SD_CONTROL	.EQU	089H
0046   0000             SD_STATUS	.EQU	089H
0047   0000             SD_LBA0		.EQU	08AH
0048   0000             SD_LBA1		.EQU	08BH
0049   0000             SD_LBA2		.EQU	08CH
0050   0000             
0051   3000             	.ORG	$3000
0052   3000             
0053   3000             primaryIO	.ds	1
0054   3001             secNo		.ds	1
0055   3002             dmaAddr		.ds	2
0056   3004             InitTxtB        .ds     2
0057   3006             	
0058   3006 00          lba0		.DB	00h
0059   3007 00          lba1		.DB	00h
0060   3008 00          lba2		.DB	00h
0061   3009 00          lba3		.DB	00h
0062   300A             
0063   300A             stackSpace	.ds	32
0064   302A             M_STACK   	.EQU    $	; Stack top
0065   302A             
0066   302A             
0067   302A             ;------------------------------------------------------------------------------
0068   302A             ;                         START OF MONITOR ROM
0069   302A             ;------------------------------------------------------------------------------
0070   302A             
0071   0000             MON		.ORG	$0000		; MONITOR ROM RESET VECTOR
0072   0000             ;------------------------------------------------------------------------------
0073   0000             ; Reset
0074   0000             ;------------------------------------------------------------------------------
0075   0000 F3          RST00		DI			;Disable INTerrupts
0076   0001 C3 A4 00    		JP	M_INIT		;Initialize Hardware and go
0077   0004 00          		NOP
0078   0005 00          		NOP
0079   0006 00          		NOP
0080   0007 00          		NOP
0081   0008             ;------------------------------------------------------------------------------
0082   0008             ; TX a character over RS232 wait for TXDONE first.
0083   0008             ;------------------------------------------------------------------------------
0084   0008 C3 32 00    RST08		JP	conout
0085   000B 00          		NOP
0086   000C 00          		NOP
0087   000D 00          		NOP
0088   000E 00          		NOP
0089   000F 00          		NOP
0090   0010             ;------------------------------------------------------------------------------
0091   0010             ; RX a character from buffer wait until char ready.
0092   0010             ;------------------------------------------------------------------------------
0093   0010 C3 1B 00    RST10		JP	conin
0094   0013 00          		NOP
0095   0014 00          		NOP
0096   0015 00          		NOP
0097   0016 00          		NOP
0098   0017 00          		NOP
0099   0018             ;------------------------------------------------------------------------------
0100   0018             ; Check input buffer status
0101   0018             ;------------------------------------------------------------------------------
0102   0018 C3 6C 00    RST18		JP	CKINCHAR
0103   001B             
0104   001B             
0105   001B             ;------------------------------------------------------------------------------
0106   001B             ; Console input routine
0107   001B             ; Use the "primaryIO" flag to determine which input port to monitor.
0108   001B             ;------------------------------------------------------------------------------
0109   001B             conin:
0110   001B 3A 00 30    		LD	A,(primaryIO)
0111   001E FE 00       		CP	0
0112   0020 20 08       		JR	NZ,coninB
0113   0022             coninA:
0114   0022             
0115   0022             waitForCharA:
0116   0022 CD 73 00    		call ckincharA
0117   0025 28 FB       		JR	Z, waitForCharA
0118   0027 DB 81       		IN   	A,(ACIA0_D)
0119   0029 C9          		RET	; Char ready in A
0120   002A             
0121   002A             coninB:
0122   002A             
0123   002A             waitForCharB:
0124   002A CD 7A 00    		call ckincharB
0125   002D 28 FB       		JR	Z, waitForCharB
0126   002F DB 83       		IN   	A,(ACIA1_D)
0127   0031 C9          		RET	; Char ready in A
0128   0032             
0129   0032             ;------------------------------------------------------------------------------
0130   0032             ; Console output routine
0131   0032             ; Use the "primaryIO" flag to determine which output port to send a character.
0132   0032             ;------------------------------------------------------------------------------
0133   0032 F5          conout:		PUSH	AF		; Store character
0134   0033 3A 00 30    		LD	A,(primaryIO)
0135   0036 FE 00       		CP	0
0136   0038 20 0D       		JR	NZ,conoutB1
0137   003A 18 01       		JR	conoutA1
0138   003C             conoutA:
0139   003C F5          		PUSH	AF
0140   003D             
0141   003D CD 60 00    conoutA1:	CALL	CKACIA0		; See if ACIA channel A is finished transmitting
0142   0040 28 FB       		JR	Z,conoutA1	; Loop until ACIA flag signals ready
0143   0042 F1          		POP	AF		; RETrieve character
0144   0043 D3 81       		OUT	(ACIA0_D),A	; OUTput the character
0145   0045 C9          		RET
0146   0046             
0147   0046             conoutB:
0148   0046 F5          		PUSH	AF
0149   0047             
0150   0047 CD 66 00    conoutB1:	CALL	CKACIA1		; See if ACIA channel B is finished transmitting
0151   004A 28 FB       		JR	Z,conoutB1	; Loop until ACIA flag signals ready
0152   004C F1          		POP	AF		; RETrieve character
0153   004D D3 83       		OUT	(ACIA1_D),A	; OUTput the character
0154   004F C9          		RET
0155   0050             
0156   0050             ;------------------------------------------------------------------------------
0157   0050             ; Non blocking console output routine
0158   0050             ; On return Z flag is 0, if the character could be written, else 1
0159   0050             ; Use the "primaryIO" flag to determine which output port to send a character.
0160   0050             ;------------------------------------------------------------------------------
0161   0050             nbconoutB:
0162   0050 F5                   	PUSH	AF
0163   0051             
0164   0051 CD 66 00    nbconoutB1:	CALL	CKACIA1		; See if ACIA channel B has finished transmitting
0165   0054 20 04       		JR      NZ, nbconoutB2  ; Ready to write
0166   0056 F1          		POP	AF	        ; Remove the parameter we don't need 
0167   0057 E6 00       	        AND     $00             ; Indicate failure
0168   0059 C9          		RET	        	; Return if ACIA flag signals not ready
0169   005A             nbconoutB2:	
0170   005A F1          	        POP	AF		; RETrieve character
0171   005B D3 83       		OUT	(ACIA1_D),A	; OUTput the character
0172   005D F6 FF       	        OR      $ff             ; Indicate success
0173   005F C9          		RET
0174   0060             
0175   0060             ;------------------------------------------------------------------------------
0176   0060             ; I/O status check routine
0177   0060             ; Use the "primaryIO" flag to determine which port to check.
0178   0060             ;------------------------------------------------------------------------------
0179   0060             CKACIA0
0180   0060 DB 80       		IN   	A,(ACIA0_C)	; Status byte D1=TX Buff Empty, D0=RX char ready	
0181   0062 0F          		RRCA			; Rotates RX status into Carry Flag,	
0182   0063 CB 47       		BIT  	0,A		; Set Zero flag if still transmitting character	
0183   0065 C9                  RET
0184   0066             
0185   0066             CKACIA1
0186   0066 DB 82       		IN   	A,(ACIA1_C)	; Status byte D1=TX Buff Empty, D0=RX char ready	
0187   0068 0F          		RRCA			; Rotates RX status into Carry Flag,	
0188   0069 CB 47       		BIT  	0,A		; Set Zero flag if still transmitting character	
0189   006B C9                  RET
0190   006C             
0191   006C             ;------------------------------------------------------------------------------
0192   006C             ; Check if there is a character in the input buffer
0193   006C             ; Use the "primaryIO" flag to determine which port to check.
0194   006C             ;------------------------------------------------------------------------------
0195   006C             CKINCHAR
0196   006C 3A 00 30    		LD	A,(primaryIO)
0197   006F FE 00       		CP	0
0198   0071 20 07       		JR	NZ,ckincharB
0199   0073             
0200   0073             ckincharA:
0201   0073             
0202   0073 DB 80       		IN   A,(ACIA0_C)		; Status byte
0203   0075 E6 01       		AND  $01
0204   0077 FE 00       		CP   $0			; Z flag set if no char
0205   0079 C9          		RET
0206   007A             
0207   007A             ckincharB:
0208   007A             
0209   007A DB 82       		IN   A,(ACIA1_C)		; Status byte
0210   007C E6 01       		AND  $01
0211   007E FE 00       		CP   $0			; Z flag set if no char
0212   0080 C9          		RET
0213   0081             
0214   0081             ;------------------------------------------------------------------------------
0215   0081             ; Filtered Character I/O
0216   0081             ;------------------------------------------------------------------------------
0217   0081             
0218   0081 D7          RDCHR		RST	10H
0219   0082 FE 0A       		CP	LF
0220   0084 28 FB       		JR	Z,RDCHR		; Ignore LF
0221   0086 FE 1B       		CP	ESC
0222   0088 20 02       		JR	NZ,RDCHR1
0223   008A 3E 03       		LD	A,CTRLC		; Change ESC to CTRL-C
0224   008C C9          RDCHR1		RET
0225   008D             
0226   008D FE 0D       WRCHR		CP	CR
0227   008F 28 0A       		JR	Z,WRCRLF	; When CR, write CRLF
0228   0091 FE 0C       		CP	M_CLS
0229   0093 28 04       		JR	Z,WR		; Allow write of "CLS"
0230   0095 FE 20       		CP	' '		; Don't write out any other control codes
0231   0097 38 01       		JR	C,NOWR		; ie. < space
0232   0099 CF          WR		RST	08H
0233   009A C9          NOWR		RET
0234   009B             
0235   009B 3E 0D       WRCRLF		LD	A,CR
0236   009D CF          		RST	08H
0237   009E 3E 0A       		LD	A,LF
0238   00A0 CF          		RST	08H
0239   00A1 3E 0D       		LD	A,CR
0240   00A3 C9          		RET
0241   00A4             
0242   00A4             
0243   00A4             ;------------------------------------------------------------------------------
0244   00A4             ; Initialise hardware and start main loop
0245   00A4             ;------------------------------------------------------------------------------
0246   00A4 31 2A 30    M_INIT		LD   SP,M_STACK		; Set the Stack Pointer
0247   00A7             
0248   00A7 3E 95       		LD        A,RTS_LOW
0249   00A9 D3 80       		OUT       (ACIA0_C),A         ; Initialise ACIA0
0250   00AB D3 82       		OUT       (ACIA1_C),A         ; Initialise ACIA1
0251   00AD             		; Display the "Press space to start" message on both consoles
0252   00AD 3E 00       		LD	A,$00
0253   00AF 32 00 30    		LD	(primaryIO),A
0254   00B2 21 34 03        		LD   	HL,INITTXT
0255   00B5 CD 37 01    		CALL 	M_PRINT
0256   00B8             		; On Display B we need to take care that it does not hang. 	
0257   00B8 21 34 03    		LD   	HL,INITTXT
0258   00BB 22 04 30    		LD      (InitTxtB),HL
0259   00BE             
0260   00BE 2A 04 30    printInitB:	LD   	HL,(InitTxtB)
0261   00C1 7E          		LD   	A,(HL)	; Get character
0262   00C2 B7          		OR   	A	; Is it $00 ?
0263   00C3 28 0C       		JR      Z, waitForSpace
0264   00C5 CD 50 00            	CALL    nbconoutB	; Print it
0265   00C8 28 07       		JR      Z, waitForSpace ; If we can't write, don't increment
0266   00CA 23          		INC	HL
0267   00CB 22 04 30    		LD 	(InitTxtB),HL   ; Store pointer into message for next round 
0268   00CE C3 BE 00                    JP      printInitB
0269   00D1             		; Wait until space is in one of the buffers to determine the active console
0270   00D1             waitForSpace:
0271   00D1 CD 73 00    		CALL    ckincharA
0272   00D4 28 0F       		JR	Z,chkSpaceB
0273   00D6 3E 00       		LD	A,$00
0274   00D8 32 00 30    		LD	(primaryIO),A
0275   00DB CD 1B 00    		CALL	conin
0276   00DE FE 20       		CP	' '
0277   00E0 C2 D1 00    		JP	NZ, waitForSpace
0278   00E3 18 12       		JR	spacePressed
0279   00E5             
0280   00E5             chkSpaceB:	
0281   00E5 CD 7A 00    		CALL 	ckincharB
0282   00E8 28 D4       	        JR	Z,printInitB ; If no key pressed, try to continue writing the init message on B
0283   00EA 3E 01       		LD	A,$01
0284   00EC 32 00 30    		LD	(primaryIO),A
0285   00EF CD 1B 00    		CALL	conin
0286   00F2 FE 20       		CP	' '
0287   00F4 C2 BE 00    		JP	NZ, printInitB ; If space not pressed, try to continue writing the init message on B
0288   00F7             
0289   00F7             spacePressed:
0290   00F7             
0291   00F7             		; Clear message on both consoles
0292   00F7 3E 0C       		LD	A,$0C
0293   00F9 CD 3C 00    		CALL	conoutA
0294   00FC CD 50 00    	        CALL	nbconoutB
0295   00FF             
0296   00FF             		;; We only clear the message on the active console,
0297   00FF             		;; because trying to write on a console not connected could
0298   00FF             		;; make the system freeze.
0299   00FF             
0300   00FF             		; primaryIO is now set to the channel where SPACE was pressed	
0301   00FF CD 3E 01    		CALL TXCRLF	; TXCRLF
0302   0102 21 C2 02    		LD   HL,M_SIGNON	; Print SIGNON message
0303   0105 CD 37 01    		CALL M_PRINT
0304   0108             
0305   0108             ;------------------------------------------------------------------------------
0306   0108             ; Monitor command loop
0307   0108             ;------------------------------------------------------------------------------
0308   0108 21 08 01    MAIN  		LD   HL,MAIN	; Save entry point for Monitor	
0309   010B E5          		PUSH HL		; This is the return address
0310   010C CD 3E 01    MAIN0		CALL TXCRLF	; Entry point for Monitor, Normal	
0311   010F 3E 3E       		LD   A,'>'	; Get a ">"	
0312   0111 CF          		RST 08H		; print it
0313   0112             
0314   0112 CD 81 00    MAIN1		CALL RDCHR	; Get a character from the input port
0315   0115 FE 20       		CP   ' '	; <spc> or less? 	
0316   0117 38 F9       		JR   C,MAIN1	; Go back
0317   0119             	
0318   0119 FE 3A       		CP   ':'	; ":"?
0319   011B CA B5 01    		JP   Z,LOAD	; First character of a HEX load
0320   011E             
0321   011E CD 8D 00    		CALL WRCHR	; Print char on console
0322   0121             
0323   0121 E6 5F       		AND  $5F	; Make character uppercase
0324   0123             
0325   0123 FE 49       		CP   'I'	
0326   0125 CA F6 01    		JP   Z,INTERPRT
0327   0128             
0328   0128 FE 47       		CP   'G'
0329   012A CA AF 01    		JP   Z,M_GOTO
0330   012D             
0331   012D FE 58       		CP   'X'
0332   012F CA FA 01    		JP   Z,CPMLOAD
0333   0132             
0334   0132 3E 3F       		LD   A,'?'	; Get a "?"	
0335   0134 CF          		RST 08H		; Print it
0336   0135 18 D5       		JR   MAIN0
0337   0137             	
0338   0137             ;------------------------------------------------------------------------------
0339   0137             ; Print string of characters to Serial A until byte=$00, WITH CR, LF
0340   0137             ;------------------------------------------------------------------------------
0341   0137 7E          M_PRINT		LD   A,(HL)	; Get character
0342   0138 B7          		OR   A		; Is it $00 ?
0343   0139 C8          		RET  Z		; Then RETurn on terminator
0344   013A CF          		RST  08H	; Print it
0345   013B 23          		INC  HL		; Next Character
0346   013C 18 F9       		JR   M_PRINT	; Continue until $00
0347   013E             
0348   013E             
0349   013E 3E 0D       TXCRLF		LD   A,$0D	; 
0350   0140 CF          		RST  08H	; Print character 
0351   0141 3E 0A       		LD   A,$0A	; 
0352   0143 CF          		RST  08H	; Print character
0353   0144 C9          		RET
0354   0145             
0355   0145             ;------------------------------------------------------------------------------
0356   0145             ; Get a character from the console, must be $20-$7F to be valid (no control characters)
0357   0145             ; <Ctrl-c> and <SPACE> breaks with the Zero Flag set
0358   0145             ;------------------------------------------------------------------------------	
0359   0145 CD 81 00    M_GETCHR		CALL RDCHR	; RX a Character
0360   0148 FE 03       		CP   $03	; <ctrl-c> User break?
0361   014A C8          		RET  Z			
0362   014B FE 20       		CP   $20	; <space> or better?
0363   014D 38 F6       		JR   C,M_GETCHR	; Do it again until we get something usable
0364   014F C9          		RET
0365   0150             ;------------------------------------------------------------------------------
0366   0150             ; Gets two ASCII characters from the console (assuming them to be HEX 0-9 A-F)
0367   0150             ; Moves them into B and C, converts them into a byte value in A and updates a
0368   0150             ; Checksum value in E
0369   0150             ;------------------------------------------------------------------------------
0370   0150 CD 45 01    GET2		CALL M_GETCHR	; Get us a valid character to work with
0371   0153 47          		LD   B,A	; Load it in B
0372   0154 CD 45 01    		CALL M_GETCHR	; Get us another character
0373   0157 4F          		LD   C,A	; load it in C
0374   0158 CD 8F 01    		CALL BCTOA	; Convert ASCII to byte
0375   015B 4F          		LD   C,A	; Build the checksum
0376   015C 7B          		LD   A,E
0377   015D 91          		SUB  C		; The checksum should always equal zero when checked
0378   015E 5F          		LD   E,A	; Save the checksum back where it came from
0379   015F 79          		LD   A,C	; Retrieve the byte and go back
0380   0160 C9          		RET
0381   0161             ;------------------------------------------------------------------------------
0382   0161             ; Gets four Hex characters from the console, converts them to values in HL
0383   0161             ;------------------------------------------------------------------------------
0384   0161 21 00 00    GETHL		LD   HL,$0000	; Gets xxxx but sets Carry Flag on any Terminator
0385   0164 CD A8 01    		CALL ECHO	; RX a Character
0386   0167 FE 0D       		CP   $0D	; <CR>?
0387   0169 20 0E       		JR   NZ,GETX2	; other key		
0388   016B 37          SETCY		SCF		; Set Carry Flag
0389   016C C9          		RET             ; and Return to main program		
0390   016D             ;------------------------------------------------------------------------------
0391   016D             ; This routine converts last four hex characters (0-9 A-F) user types into a value in HL
0392   016D             ; Rotates the old out and replaces with the new until the user hits a terminating character
0393   016D             ;------------------------------------------------------------------------------
0394   016D 21 00 00    GETX		LD   HL,$0000	; CLEAR HL
0395   0170 CD A8 01    GETX1		CALL ECHO	; RX a character from the console
0396   0173 FE 0D       		CP   $0D	; <CR>
0397   0175 C8          		RET  Z		; quit
0398   0176 FE 2C       		CP   $2C	; <,> can be used to safely quit for multiple entries
0399   0178 C8          		RET  Z		; (Like filling both DE and HL from the user)
0400   0179 FE 03       GETX2		CP   $03	; Likewise, a <ctrl-C> will terminate clean, too, but
0401   017B 28 EE       		JR   Z,SETCY	; It also sets the Carry Flag for testing later.
0402   017D 29          		ADD  HL,HL	; Otherwise, rotate the previous low nibble to high
0403   017E 29          		ADD  HL,HL	; rather slowly
0404   017F 29          		ADD  HL,HL	; until we get to the top
0405   0180 29          		ADD  HL,HL	; and then we can continue on.
0406   0181 D6 30       		SUB  $30	; Convert ASCII to byte	value
0407   0183 FE 0A       		CP   $0A	; Are we in the 0-9 range?
0408   0185 38 02       		JR   C,GETX3	; Then we just need to sub $30, but if it is A-F
0409   0187 D6 07       		SUB  $07	; We need to take off 7 more to get the value down to
0410   0189 E6 0F       GETX3		AND  $0F	; to the right hex value
0411   018B 85          		ADD  A,L	; Add the high nibble to the low
0412   018C 6F          		LD   L,A	; Move the byte back to A
0413   018D 18 E1       		JR   GETX1	; and go back for next character until he terminates
0414   018F             ;------------------------------------------------------------------------------
0415   018F             ; Convert ASCII characters in B C registers to a byte value in A
0416   018F             ;------------------------------------------------------------------------------
0417   018F 78          BCTOA		LD   A,B	; Move the hi order byte to A
0418   0190 D6 30       		SUB  $30	; Take it down from Ascii
0419   0192 FE 0A       		CP   $0A	; Are we in the 0-9 range here?
0420   0194 38 02       		JR   C,BCTOA1	; If so, get the next nybble
0421   0196 D6 07       		SUB  $07	; But if A-F, take it down some more
0422   0198 07          BCTOA1		RLCA		; Rotate the nybble from low to high
0423   0199 07          		RLCA		; One bit at a time
0424   019A 07          		RLCA		; Until we
0425   019B 07          		RLCA		; Get there with it
0426   019C 47          		LD   B,A	; Save the converted high nybble
0427   019D 79          		LD   A,C	; Now get the low order byte
0428   019E D6 30       		SUB  $30	; Convert it down from Ascii
0429   01A0 FE 0A       		CP   $0A	; 0-9 at this point?
0430   01A2 38 02       		JR   C,BCTOA2	; Good enough then, but
0431   01A4 D6 07       		SUB  $07	; Take off 7 more if it's A-F
0432   01A6 80          BCTOA2		ADD  A,B	; Add in the high order nybble
0433   01A7 C9          		RET
0434   01A8             
0435   01A8             ;------------------------------------------------------------------------------
0436   01A8             ; Get a character and echo it back to the user
0437   01A8             ;------------------------------------------------------------------------------
0438   01A8 CD 81 00    ECHO		CALL	RDCHR
0439   01AB CD 8D 00    		CALL	WRCHR
0440   01AE C9          		RET
0441   01AF             
0442   01AF             ;------------------------------------------------------------------------------
0443   01AF             ; GOTO command
0444   01AF             ;------------------------------------------------------------------------------
0445   01AF CD 61 01    M_GOTO		CALL GETHL		; ENTRY POINT FOR <G>oto addr. Get XXXX from user.
0446   01B2 D8          		RET  C			; Return if invalid       	
0447   01B3 E5          		PUSH HL
0448   01B4 C9          		RET			; Jump to HL address value
0449   01B5             
0450   01B5             ;------------------------------------------------------------------------------
0451   01B5             ; LOAD Intel Hex format file from the console.
0452   01B5             ; [Intel Hex Format is:
0453   01B5             ; 1) Colon (Frame 0)
0454   01B5             ; 2) Record Length Field (Frames 1 and 2)
0455   01B5             ; 3) Load Address Field (Frames 3,4,5,6)
0456   01B5             ; 4) Record Type Field (Frames 7 and 8)
0457   01B5             ; 5) Data Field (Frames 9 to 9+2*(Record Length)-1
0458   01B5             ; 6) Checksum Field - Sum of all byte values from Record Length to and 
0459   01B5             ;   including Checksum Field = 0 ]
0460   01B5             ;------------------------------------------------------------------------------	
0461   01B5 1E 00       LOAD		LD   E,0	; First two Characters is the Record Length Field
0462   01B7 CD 50 01    		CALL GET2	; Get us two characters into BC, convert it to a byte <A>
0463   01BA 57          		LD   D,A	; Load Record Length count into D
0464   01BB CD 50 01    		CALL GET2	; Get next two characters, Memory Load Address <H>
0465   01BE 67          		LD   H,A	; put value in H register.
0466   01BF CD 50 01    		CALL GET2	; Get next two characters, Memory Load Address <L>
0467   01C2 6F          		LD   L,A	; put value in L register.
0468   01C3 CD 50 01    		CALL GET2	; Get next two characters, Record Field Type
0469   01C6 FE 01       		CP   $01	; Record Field Type 00 is Data, 01 is End of File
0470   01C8 20 09       		JR   NZ,LOAD2	; Must be the end of that file
0471   01CA CD 50 01    		CALL GET2	; Get next two characters, assemble into byte
0472   01CD 7B          		LD   A,E	; Recall the Checksum byte
0473   01CE A7          		AND  A		; Is it Zero?
0474   01CF 28 1E       		JR   Z,LOAD00	; Print footer reached message
0475   01D1 18 15       		JR   LOADERR	; Checksums don't add up, Error out
0476   01D3             		
0477   01D3 7A          LOAD2		LD   A,D	; Retrieve line character counter	
0478   01D4 A7          		AND  A		; Are we done with this line?
0479   01D5 28 0B       		JR   Z,LOAD3	; Get two more ascii characters, build a byte and checksum
0480   01D7 CD 50 01    		CALL GET2	; Get next two chars, convert to byte in A, checksum it
0481   01DA 77          		LD   (HL),A	; Move converted byte in A to memory location
0482   01DB 23          		INC  HL		; Increment pointer to next memory location	
0483   01DC 3E 2E       		LD   A,'.'	; Print out a "." for every byte loaded
0484   01DE CF          		RST  08H	;
0485   01DF 15          		DEC  D		; Decrement line character counter
0486   01E0 18 F1       		JR   LOAD2	; and keep loading into memory until line is complete
0487   01E2             		
0488   01E2 CD 50 01    LOAD3		CALL GET2	; Get two chars, build byte and checksum
0489   01E5 7B          		LD   A,E	; Check the checksum value
0490   01E6 A7          		AND  A		; Is it zero?
0491   01E7 C8          		RET  Z
0492   01E8             
0493   01E8 21 23 03    LOADERR		LD   HL,CKSUMERR  ; Get "Checksum Error" message
0494   01EB CD 37 01    		CALL M_PRINT	; Print Message from (HL) and terminate the load
0495   01EE C9          		RET
0496   01EF             
0497   01EF 21 5A 03    LOAD00  	LD   HL,LDETXT	; Print load complete message
0498   01F2 CD 37 01    		CALL M_PRINT
0499   01F5 C9          		RET
0500   01F6             
0501   01F6             ;------------------------------------------------------------------------------
0502   01F6             ; Start Interpreter
0503   01F6             ;------------------------------------------------------------------------------
0504   01F6             INTERPRT
0505   01F6 C3 65 03    		JP  STARTINT
0506   01F9 C9          		RET
0507   01FA             
0508   01FA             ;------------------------------------------------------------------------------
0509   01FA             ; CP/M load command
0510   01FA             ;------------------------------------------------------------------------------
0511   01FA             CPMLOAD
0512   01FA             
0513   01FA 21 0C 02        	LD HL,CPMTXT
0514   01FD CD 37 01    		CALL M_PRINT
0515   0200 CD 45 01    		CALL M_GETCHR
0516   0203 C8          		RET Z	; Cancel if CTRL-C
0517   0204 E6 5F       		AND  $5F ; uppercase
0518   0206 FE 59       		CP 'Y'
0519   0208 CA 2A 02    		JP  Z,CPMLOAD2
0520   020B C9          		RET
0521   020C             CPMTXT
0522   020C 0D 0A       		.BYTE	$0D,$0A
0523   020E 42 6F 6F 74 		.TEXT	"Boot CP/M?"
0523   0212 20 43 50 2F 
0523   0216 4D 3F 
0524   0218 00          		.BYTE	$00
0525   0219             
0526   0219             CPMTXT2
0527   0219 0D 0A       		.BYTE	$0D,$0A
0528   021B 4C 6F 61 64 		.TEXT	"Loading CP/M"
0528   021F 69 6E 67 20 
0528   0223 43 50 2F 4D 
0529   0227 0D 0A 00    		.BYTE	$0D,$0A,$00
0530   022A             
0531   022A             CPMLOAD2
0532   022A 21 19 02        	LD HL,CPMTXT2
0533   022D CD 37 01    		CALL M_PRINT
0534   0230             		
0535   0230 06 18       		LD	B,numSecs
0536   0232             
0537   0232 3E 00       		LD	A,0
0538   0234 32 06 30    		LD	(lba0),A
0539   0237 32 07 30    		ld 	(lba1),A
0540   023A 32 08 30    		ld 	(lba2),A
0541   023D 32 09 30    		ld 	(lba3),A
0542   0240             		
0543   0240 21 00 D0    		LD	HL,loadAddr
0544   0243 22 02 30    		LD	(dmaAddr),HL
0545   0246             processSectors:
0546   0246             
0547   0246 CD 74 02    		call	readhst
0548   0249             
0549   0249 11 00 02    		LD	DE,0200H
0550   024C 2A 02 30    		LD	HL,(dmaAddr)
0551   024F 19          		ADD	HL,DE
0552   0250 22 02 30    		LD	(dmaAddr),HL
0553   0253 3A 06 30    		LD	A,(lba0)
0554   0256 3C          		INC	A
0555   0257 32 06 30    		LD	(lba0),A
0556   025A             
0557   025A 10 EA       		djnz	processSectors
0558   025C             
0559   025C             ; Start CP/M using entry at top of BIOS
0560   025C             ; The current active console stream ID is pushed onto the stack
0561   025C             ; to allow the CBIOS to pick it up
0562   025C             ; 0 = ACIA0, 1 = ACIA1
0563   025C             		
0564   025C 3A 00 30    		ld	A,(primaryIO)
0565   025F F5          		PUSH	AF
0566   0260 2A FE FF    		ld	HL,($FFFE)
0567   0263 E9          		jp	(HL)
0568   0264             
0569   0264             
0570   0264             ;------------------------------------------------------------------------------
0571   0264             ; ROUTINES AS USED IN BIOS
0572   0264             ;------------------------------------------------------------------------------
0573   0264             
0574   0264             ;================================================================================================
0575   0264             ; Convert track/head/sector into LBA for physical access to the disk
0576   0264             ;================================================================================================
0577   0264             setLBAaddr:	
0578   0264             		; Transfer LBA to disk (LBA3 not used on SD card)
0579   0264 3A 08 30    		LD	A,(lba2)
0580   0267 D3 8C       		OUT	(SD_LBA2),A
0581   0269 3A 07 30    		LD	A,(lba1)
0582   026C D3 8B       		OUT	(SD_LBA1),A
0583   026E 3A 06 30    		LD	A,(lba0)
0584   0271 D3 8A       		OUT	(SD_LBA0),A
0585   0273 C9          		RET
0586   0274             		
0587   0274             ;================================================================================================
0588   0274             ; Read physical sector from host
0589   0274             ;================================================================================================
0590   0274             
0591   0274             readhst:
0592   0274 F5                  PUSH    AF
0593   0275 C5                  PUSH    BC
0594   0276 E5                  PUSH    HL
0595   0277             
0596   0277 DB 89       rdWait1: IN      A,(SD_STATUS)
0597   0279 FE 80               CP      128             ; Check for ready status
0598   027B 20 FA               JR      NZ,rdWait1
0599   027D             
0600   027D                     ; Add multiple status checks before starting read
0601   027D 06 03               LD      B,3            ; Check status 3 times
0602   027F             rdCheck1:
0603   027F DB 89               IN      A,(SD_STATUS)
0604   0281 FE 80               CP      128
0605   0283 20 FA               JR      NZ,rdCheck1
0606   0285 10 F8               DJNZ    rdCheck1
0607   0287                     
0608   0287 CD 64 02            CALL    setLBAaddr
0609   028A                     
0610   028A 3E 00               LD      A,$00          ; 00 = Read block
0611   028C D3 89               OUT     (SD_CONTROL),A
0612   028E             
0613   028E 0E 04               LD      c,4
0614   0290             rd4secs:
0615   0290 06 80               LD      b,128
0616   0292             rdByte:
0617   0292             
0618   0292 DB 89       rdWait2: IN      A,(SD_STATUS)
0619   0294 FE E0               CP      224            ; Read byte waiting
0620   0296 20 FA               JR      NZ,rdWait2
0621   0298             
0622   0298                     ; Add extra validation checks before each read
0623   0298 C5                  PUSH    BC            ; Save main counters
0624   0299 06 02               LD      B,2          ; Check status twice
0625   029B             rdCheck2:
0626   029B DB 89               IN      A,(SD_STATUS)
0627   029D FE E0               CP      224
0628   029F 20 FA               JR      NZ,rdCheck2
0629   02A1 10 F8               DJNZ    rdCheck2
0630   02A3 C1                  POP     BC           ; Restore main counters
0631   02A4             
0632   02A4 DB 88               IN      A,(SD_DATA)
0633   02A6             
0634   02A6                     ; Add small delay after read before store
0635   02A6 C5                  PUSH    BC
0636   02A7 06 0A               LD      B,10
0637   02A9             rdDelay:
0638   02A9 10 FE               DJNZ    rdDelay
0639   02AB C1                  POP     BC
0640   02AC             
0641   02AC 77                  LD      (HL),A
0642   02AD 23                  INC     HL
0643   02AE 05                  dec     b
0644   02AF 20 E1               JR      NZ, rdByte
0645   02B1 0D                  dec     c
0646   02B2 20 DC               JR      NZ,rd4secs
0647   02B4             
0648   02B4                     ; Add final wait before returning
0649   02B4 06 00               LD      B,0
0650   02B6             rdWaitFinal:
0651   02B6 DB 89               IN      A,(SD_STATUS)
0652   02B8 FE 80               CP      128             ; Wait for ready status
0653   02BA 20 FA               JR      NZ,rdWaitFinal
0654   02BC 10 F8               DJNZ    rdWaitFinal
0655   02BE             
0656   02BE E1                  POP     HL
0657   02BF C1                  POP     BC
0658   02C0 F1                  POP     AF
0659   02C1             
0660   02C1 C9                  RET
0661   02C2             
0662   02C2             ;------------------------------------------------------------------------------
0663   02C2             ; END OF ROUTINES AS USED IN BIOS
0664   02C2             ;------------------------------------------------------------------------------
0665   02C2             
0666   02C2             
0667   02C2 43 50 2F 4D M_SIGNON	.BYTE	"CP/M Boot ROM 2.0"
0667   02C6 20 42 6F 6F 
0667   02CA 74 20 52 4F 
0667   02CE 4D 20 32 2E 
0667   02D2 30 
0668   02D3             ;		.BYTE	" based on design by G. Searle"
0669   02D3             ;		.BYTE	$0D,$0A
0670   02D3 0D 0A       		.BYTE	$0D,$0A
0671   02D5 49 2D 53 74 		.TEXT	"I-Strt Intrp"
0671   02D9 72 74 20 49 
0671   02DD 6E 74 72 70 
0672   02E1 0D 0A       		.BYTE	$0D,$0A
0673   02E3 58 2D 42 6F 		.TEXT	"X-Boot CP/M"
0673   02E7 6F 74 20 43 
0673   02EB 50 2F 4D 
0674   02EE 0D 0A       		.BYTE	$0D,$0A
0675   02F0 3A 6E 6E 6E 		.TEXT	":nnnn-Load I rcrd"
0675   02F4 6E 2D 4C 6F 
0675   02F8 61 64 20 49 
0675   02FC 20 72 63 72 
0675   0300 64 
0676   0301 0D 0A       		.BYTE	$0D,$0A
0677   0303 47 6E 6E 6E 		.TEXT	"Gnnnn-R loc"
0677   0307 6E 2D 52 20 
0677   030B 6C 6F 63 
0678   030E 0D 0A       		.BYTE	$0D,$0A
0679   0310 00                 	.BYTE   $00
0680   0311             
0681   0311             M_BASTXT
0682   0311 0D 0A       		.BYTE	$0D,$0A
0683   0313 43 6F 6C 64 		.TEXT	"Cold or warm?"
0683   0317 20 6F 72 20 
0683   031B 77 61 72 6D 
0683   031F 3F 
0684   0320 0D 0A 00    		.BYTE	$0D,$0A,$00
0685   0323             
0686   0323 43 68 65 63 CKSUMERR	.BYTE	"Checksum error"
0686   0327 6B 73 75 6D 
0686   032B 20 65 72 72 
0686   032F 6F 72 
0687   0331 0D 0A 00    		.BYTE	$0D,$0A,$00
0688   0334             
0689   0334             INITTXT  
0690   0334 0C          		.BYTE	$0C
0691   0335 50 72 65 73 		.TEXT	"Press [space] to activate console."
0691   0339 73 20 5B 73 
0691   033D 70 61 63 65 
0691   0341 5D 20 74 6F 
0691   0345 20 61 63 74 
0691   0349 69 76 61 74 
0691   034D 65 20 63 6F 
0691   0351 6E 73 6F 6C 
0691   0355 65 2E 
0692   0357 0D 0A 00    		.BYTE	$0D,$0A, $00
0693   035A             
0694   035A             LDETXT  
0695   035A 43 6F 6D 70 		.TEXT	"Complete"
0695   035E 6C 65 74 65 
0696   0362 0D 0A 00    		.BYTE	$0D,$0A, $00
0697   0365             
0698   0365             ; ==========================================================================================================================
0699   0365             ; GENERAL EQUATES
0700   0365             
0701   0365             CTRLC   .EQU    03H             ; Control "C"
0702   0365             CTRLG   .EQU    07H             ; Control "G"
0703   0365             BKSP    .EQU    08H             ; Back space
0704   0365             LF      .EQU    0AH             ; Line feed
0705   0365             CS      .EQU    0CH             ; Clear screen
0706   0365             CR      .EQU    0DH             ; Carriage return
0707   0365             CTRLO   .EQU    0FH             ; Control "O"
0708   0365             CTRLQ	.EQU	11H		; Control "Q"
0709   0365             CTRLR   .EQU    12H             ; Control "R"
0710   0365             CTRLS   .EQU    13H             ; Control "S"
0711   0365             CTRLU   .EQU    15H             ; Control "U"
0712   0365             ESC     .EQU    1BH             ; Escape
0713   0365             DEL     .EQU    7FH             ; Delete
0714   0365             
0715   0365             
0716   0365             ;===========================================================================================================================
0717   0365             
0718   0365             ; NASCOM ROM BASIC Ver 4.7, 
0719   0365             ; used to be here, removed to get rid of the '(C) 1978 Microsoft'
0720   0365             
0721   0365             STARTINT:							  
0722   0365             #INCLUDE "SOURCE\\INTPRT.ASM"
0001+  0365             ;------------------------------------------------------------------------------
0002+  0365             ; Start BASIC command
0003+  0365             ;------------------------------------------------------------------------------
0004+  0365             BASIC
0005+  0365 21 11 03        		LD HL,M_BASTXT
0006+  0368 CD 37 01    		CALL M_PRINT
0007+  036B CD 45 01    		CALL M_GETCHR
0008+  036E C8          		RET Z	; Cancel if CTRL-C
0009+  036F E6 5F       		AND  $5F ; uppercase
0010+  0371 FE 43       		CP 'C'
0011+  0373 CA 7C 03    		JP  Z,COLD
0012+  0376 FE 57       		CP 'W'
0013+  0378 CA 7F 03    		JP  Z,WARM
0014+  037B C9          		RET
0015+  037C             
0016+  037C             ; BASIC WORK SPACE LOCATIONS
0017+  037C             
0018+  037C             WRKSPC  .EQU    30B0H             ; BASIC Work space
0019+  037C             USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
0020+  037C             OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
0021+  037C             OTPORT  .EQU    WRKSPC+7H           ; Port (p)
0022+  037C             DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
0023+  037C             DIV1    .EQU    WRKSPC+0AH           ; <- Values
0024+  037C             DIV2    .EQU    WRKSPC+0EH           ; <-   to
0025+  037C             DIV3    .EQU    WRKSPC+12H           ; <-   be
0026+  037C             DIV4    .EQU    WRKSPC+15H           ; <-inserted
0027+  037C             SEED    .EQU    WRKSPC+17H           ; Random number seed
0028+  037C             LSTRND  .EQU    WRKSPC+3AH           ; Last random number
0029+  037C             INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
0030+  037C             INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
0031+  037C             NULLS   .EQU    WRKSPC+41H           ; Number of nulls
0032+  037C             LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
0033+  037C             COMMAN  .EQU    WRKSPC+43H           ; Width for commas
0034+  037C             NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
0035+  037C             CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
0036+  037C             LINESC  .EQU    WRKSPC+46H           ; Lines counter
0037+  037C             LINESN  .EQU    WRKSPC+48H           ; Lines number
0038+  037C             CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
0039+  037C             NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
0040+  037C             BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
0041+  037C             RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
0042+  037C             POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
0043+  037C             PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
0044+  037C             RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
0045+  037C             STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
0046+  037C             LINEAT  .EQU    WRKSPC+5CH           ; Current line number
0047+  037C             BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
0048+  037C             BUFFER  .EQU    WRKSPC+61H           ; Input buffer
0049+  037C             STACK   .EQU    WRKSPC+66H           ; Initial stack
0050+  037C             CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
0051+  037C             LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
0052+  037C             TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
0053+  037C             DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
0054+  037C             LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
0055+  037C             TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
0056+  037C             TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
0057+  037C             TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
0058+  037C             STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
0059+  037C             CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
0060+  037C             LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
0061+  037C             DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
0062+  037C             FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
0063+  037C             LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
0064+  037C             READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
0065+  037C             BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
0066+  037C             NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
0067+  037C             ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
0068+  037C             CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
0069+  037C             PROGND  .EQU    WRKSPC+0D6H          ; End of program
0070+  037C             VAREND  .EQU    WRKSPC+0D8H          ; End of variables
0071+  037C             ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
0072+  037C             NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
0073+  037C             FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
0074+  037C             FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
0075+  037C             FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
0076+  037C             FPEXP   .EQU    FPREG+3         ; Floating point exponent
0077+  037C             SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
0078+  037C             PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
0079+  037C             MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
0080+  037C             PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area
0081+  037C             STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
0082+  037C             
0083+  037C             ; BASIC ERROR CODE VALUES
0084+  037C             
0085+  037C             NF      .EQU    00H             ; NEXT without FOR
0086+  037C             SN      .EQU    02H             ; Syntax error
0087+  037C             RG      .EQU    04H             ; RETURN without GOSUB
0088+  037C             OD      .EQU    06H             ; Out of DATA
0089+  037C             FC      .EQU    08H             ; Function call error
0090+  037C             OV      .EQU    0AH             ; Overflow
0091+  037C             OM      .EQU    0CH             ; Out of memory
0092+  037C             UL      .EQU    0EH             ; Undefined line number
0093+  037C             BS      .EQU    10H             ; Bad subscript
0094+  037C             DD      .EQU    12H             ; Re-DIMensioned array
0095+  037C             DZ      .EQU    14H             ; Division by zero (/0)
0096+  037C             ID      .EQU    16H             ; Illegal direct
0097+  037C             TM      .EQU    18H             ; Type miss-match
0098+  037C             OS      .EQU    1AH             ; Out of string space
0099+  037C             LS      .EQU    1CH             ; String too long
0100+  037C             ST      .EQU    1EH             ; String formula too complex
0101+  037C             CN      .EQU    20H             ; Can't CONTinue
0102+  037C             UF      .EQU    22H             ; UnDEFined FN function
0103+  037C             MO      .EQU    24H             ; Missing operand
0104+  037C             HX      .EQU    26H             ; HEX error
0105+  037C             BN      .EQU    28H             ; BIN error
0106+  037C             
0107+  037C             ;        .ORG    00396H
0108+  037C             
0109+  037C C3 82 03    COLD:   JP      STARTB          ; Jump for cold start
0110+  037F C3 20 04    WARM:   JP      WARMST          ; Jump for warm start
0111+  0382             STARTB: 
0112+  0382 DD 21 00 00         LD      IX,0            ; Flag cold start
0113+  0386 C3 8D 03            JP      CSTART          ; Jump to initialise
0114+  0389             
0115+  0389 33 0C               .WORD   DEINT           ; Get integer -32768 to 32767
0116+  038B A9 13               .WORD   ABPASS          ; Return integer in AB
0117+  038D             
0118+  038D             
0119+  038D 21 B0 30    CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
0120+  0390 F9                  LD      SP,HL           ; Set up a temporary stack
0121+  0391 C3 C8 1F            JP      INITST          ; Go to initialise
0122+  0394             
0123+  0394 11 5A 06    INIT:   LD      DE,INITAB       ; Initialise workspace
0124+  0397 06 63               LD      B,INITBE-INITAB+3; Bytes to copy
0125+  0399 21 B0 30            LD      HL,WRKSPC       ; Into workspace RAM
0126+  039C 1A          COPY:   LD      A,(DE)          ; Get source
0127+  039D 77                  LD      (HL),A          ; To destination
0128+  039E 23                  INC     HL              ; Next destination
0129+  039F 13                  INC     DE              ; Next source
0130+  03A0 05                  DEC     B               ; Count bytes
0131+  03A1 C2 9C 03            JP      NZ,COPY         ; More to move
0132+  03A4 F9                  LD      SP,HL           ; Temporary stack
0133+  03A5 CD 5B 08            CALL    CLREG           ; Clear registers and stack
0134+  03A8 CD 29 0E            CALL    PRNTCRLF        ; Output CRLF
0135+  03AB 32 5A 31            LD      (BUFFER+72+1),A ; Mark end of buffer
0136+  03AE 32 A9 31            LD      (PROGST),A      ; Initialise program area
0137+  03B1 21 6F 04    MSIZE:  LD      HL,MEMMSG       ; Point to message
0138+  03B4 CD C7 14            CALL    PRS             ; Output "Memory size"
0139+  03B7 CD 78 08            CALL    PROMPT          ; Get input with '?'
0140+  03BA CD 81 0B            CALL    GETCHR          ; Get next character
0141+  03BD B7                  OR      A               ; Set flags
0142+  03BE C2 D6 03            JP      NZ,TSTMEM       ; If number - Test if RAM there
0143+  03C1 21 0D 32            LD      HL,STLOOK       ; Point to start of RAM
0144+  03C4 23          MLOOP:  INC     HL              ; Next byte
0145+  03C5 7C                  LD      A,H             ; Above address FFFF ?
0146+  03C6 B5                  OR      L
0147+  03C7 CA E8 03            JP      Z,SETTOP        ; Yes - 64K RAM
0148+  03CA 7E                  LD      A,(HL)          ; Get contents
0149+  03CB 47                  LD      B,A             ; Save it
0150+  03CC 2F                  CPL                     ; Flip all bits
0151+  03CD 77                  LD      (HL),A          ; Put it back
0152+  03CE BE                  CP      (HL)            ; RAM there if same
0153+  03CF 70                  LD      (HL),B          ; Restore old contents
0154+  03D0 CA C4 03            JP      Z,MLOOP         ; If RAM - test next byte
0155+  03D3 C3 E8 03            JP      SETTOP          ; Top of RAM found
0156+  03D6             
0157+  03D6 CD 4D 0C    TSTMEM: CALL    ATOH            ; Get high memory into DE
0158+  03D9 B7                  OR      A               ; Set flags on last byte
0159+  03DA C2 29 07            JP      NZ,SNERR        ; ?SN Error if bad character
0160+  03DD EB                  EX      DE,HL           ; Address into HL
0161+  03DE 2B                  DEC     HL              ; Back one byte
0162+  03DF 3E D9               LD      A,11011001B     ; Test byte
0163+  03E1 46                  LD      B,(HL)          ; Get old contents
0164+  03E2 77                  LD      (HL),A          ; Load test byte
0165+  03E3 BE                  CP      (HL)            ; RAM there if same
0166+  03E4 70                  LD      (HL),B          ; Restore old contents
0167+  03E5 C2 B1 03            JP      NZ,MSIZE        ; Ask again if no RAM
0168+  03E8             
0169+  03E8 2B          SETTOP: DEC     HL              ; Back one byte
0170+  03E9 11 0C 32            LD      DE,STLOOK-1     ; See if enough RAM
0171+  03EC CD F1 09            CALL    CPDEHL          ; Compare DE with HL
0172+  03EF DA B1 03            JP      C,MSIZE         ; Ask again if not enough RAM
0173+  03F2 11 CE FF            LD      DE,0-50         ; 50 Bytes string space
0174+  03F5 22 5F 31            LD      (LSTRAM),HL     ; Save last available RAM
0175+  03F8 19                  ADD     HL,DE           ; Allocate string space
0176+  03F9 22 0A 31            LD      (STRSPC),HL     ; Save string space
0177+  03FC CD 36 08            CALL    CLRPTR          ; Clear program area
0178+  03FF 2A 0A 31            LD      HL,(STRSPC)     ; Get end of memory
0179+  0402 11 EF FF            LD      DE,0-17         ; Offset for free bytes
0180+  0405 19                  ADD     HL,DE           ; Adjust HL
0181+  0406 11 A9 31            LD      DE,PROGST       ; Start of program text
0182+  0409 7D                  LD      A,L             ; Get LSB
0183+  040A 93                  SUB     E               ; Adjust it
0184+  040B 6F                  LD      L,A             ; Re-save
0185+  040C 7C                  LD      A,H             ; Get MSB
0186+  040D 9A                  SBC     A,D             ; Adjust it
0187+  040E 67                  LD      H,A             ; Re-save
0188+  040F E5                  PUSH    HL              ; Save bytes free
0189+  0410 21 38 04            LD      HL,SIGNON       ; Sign-on message
0190+  0413 CD C7 14            CALL    PRS             ; Output string
0191+  0416 E1                  POP     HL              ; Get bytes free back
0192+  0417 CD 6A 1B            CALL    PRNTHL          ; Output amount of free memory
0193+  041A 21 29 04            LD      HL,BFREE        ; " Bytes free" message
0194+  041D CD C7 14            CALL    PRS             ; Output string
0195+  0420             
0196+  0420 31 16 31    WARMST: LD      SP,STACK        ; Temporary stack
0197+  0423 CD 5B 08    BRKRET: CALL    CLREG           ; Clear registers and stack
0198+  0426 C3 74 07            JP      PRNTOK          ; Go to get command line
0199+  0429             
0200+  0429 20 42 79 74 BFREE:  .BYTE   " Bytes free",CR,LF,0,0
0200+  042D 65 73 20 66 
0200+  0431 72 65 65 0D 
0200+  0435 0A 00 00 
0201+  0438             
0202+  0438 5A 38 30 20 SIGNON: .BYTE   "Z80 BASIC Ver 4.7b",CR,LF
0202+  043C 42 41 53 49 
0202+  0440 43 20 56 65 
0202+  0444 72 20 34 2E 
0202+  0448 37 62 0D 0A 
0203+  044C 43 6F 70 79         .BYTE   "Copyright ",40,"C",41
0203+  0450 72 69 67 68 
0203+  0454 74 20 28 43 
0203+  0458 29 
0204+  0459 20 31 39 37         .BYTE   " 1978 by Microsoft",CR,LF,0,0
0204+  045D 38 20 62 79 
0204+  0461 20 4D 69 63 
0204+  0465 72 6F 73 6F 
0204+  0469 66 74 0D 0A 
0204+  046D 00 00 
0205+  046F             
0206+  046F 4D 65 6D 6F MEMMSG: .BYTE   "Memory top",0
0206+  0473 72 79 20 74 
0206+  0477 6F 70 00 
0207+  047A             
0208+  047A             ; FUNCTION ADDRESS TABLE
0209+  047A             
0210+  047A DF 19       FNCTAB: .WORD   SGN
0211+  047C A3 1A               .WORD   INT
0212+  047E F5 19               .WORD   ABS
0213+  0480 B3 30               .WORD   USR
0214+  0482 87 13               .WORD   FRE
0215+  0484 0C 17               .WORD   INP
0216+  0486 B5 13               .WORD   POS
0217+  0488 69 1C               .WORD   SQR
0218+  048A 48 1D               .WORD   RND
0219+  048C 84 18               .WORD   LOG
0220+  048E B7 1C               .WORD   EXP
0221+  0490 BD 1D               .WORD   COS
0222+  0492 C3 1D               .WORD   SIN
0223+  0494 24 1E               .WORD   TAN
0224+  0496 39 1E               .WORD   ATN
0225+  0498 60 17               .WORD   PEEK
0226+  049A A4 1E               .WORD   DEEK
0227+  049C 01 31               .WORD   POINT
0228+  049E 39 16               .WORD   LEN
0229+  04A0 51 14               .WORD   STR
0230+  04A2 D3 16               .WORD   VAL
0231+  04A4 48 16               .WORD   ASC
0232+  04A6 59 16               .WORD   CHR
0233+  04A8 C6 1E               .WORD   HEX
0234+  04AA 59 1F               .WORD   BIN
0235+  04AC 69 16               .WORD   LEFT
0236+  04AE 99 16               .WORD   RIGHT
0237+  04B0 A3 16               .WORD   MID
0238+  04B2             
0239+  04B2             ; RESERVED WORD LIST
0240+  04B2             
0241+  04B2 C5 4E 44    WORDS:  .BYTE   'E'+80H,"ND"
0242+  04B5 C6 4F 52            .BYTE   'F'+80H,"OR"
0243+  04B8 CE 45 58 54         .BYTE   'N'+80H,"EXT"
0244+  04BC C4 41 54 41         .BYTE   'D'+80H,"ATA"
0245+  04C0 C9 4E 50 55         .BYTE   'I'+80H,"NPUT"
0245+  04C4 54 
0246+  04C5 C4 49 4D            .BYTE   'D'+80H,"IM"
0247+  04C8 D2 45 41 44         .BYTE   'R'+80H,"EAD"
0248+  04CC CC 45 54            .BYTE   'L'+80H,"ET"
0249+  04CF C7 4F 54 4F         .BYTE   'G'+80H,"OTO"
0250+  04D3 D2 55 4E            .BYTE   'R'+80H,"UN"
0251+  04D6 C9 46               .BYTE   'I'+80H,"F"
0252+  04D8 D2 45 53 54         .BYTE   'R'+80H,"ESTORE"
0252+  04DC 4F 52 45 
0253+  04DF C7 4F 53 55         .BYTE   'G'+80H,"OSUB"
0253+  04E3 42 
0254+  04E4 D2 45 54 55         .BYTE   'R'+80H,"ETURN"
0254+  04E8 52 4E 
0255+  04EA D2 45 4D            .BYTE   'R'+80H,"EM"
0256+  04ED D3 54 4F 50         .BYTE   'S'+80H,"TOP"
0257+  04F1 CF 55 54            .BYTE   'O'+80H,"UT"
0258+  04F4 CF 4E               .BYTE   'O'+80H,"N"
0259+  04F6 CE 55 4C 4C         .BYTE   'N'+80H,"ULL"
0260+  04FA D7 41 49 54         .BYTE   'W'+80H,"AIT"
0261+  04FE C4 45 46            .BYTE   'D'+80H,"EF"
0262+  0501 D0 4F 4B 45         .BYTE   'P'+80H,"OKE"
0263+  0505 C4 4F 4B 45         .BYTE   'D'+80H,"OKE"
0264+  0509 D3 43 52 45         .BYTE   'S'+80H,"CREEN"
0264+  050D 45 4E 
0265+  050F CC 49 4E 45         .BYTE   'L'+80H,"INES"
0265+  0513 53 
0266+  0514 C3 4C 53            .BYTE   'C'+80H,"LS"
0267+  0517 D7 49 44 54         .BYTE   'W'+80H,"IDTH"
0267+  051B 48 
0268+  051C CD 4F 4E 49         .BYTE   'M'+80H,"ONITOR"
0268+  0520 54 4F 52 
0269+  0523 D3 45 54            .BYTE   'S'+80H,"ET"
0270+  0526 D2 45 53 45         .BYTE   'R'+80H,"ESET"
0270+  052A 54 
0271+  052B D0 52 49 4E         .BYTE   'P'+80H,"RINT"
0271+  052F 54 
0272+  0530 C3 4F 4E 54         .BYTE   'C'+80H,"ONT"
0273+  0534 CC 49 53 54         .BYTE   'L'+80H,"IST"
0274+  0538 C3 4C 45 41         .BYTE   'C'+80H,"LEAR"
0274+  053C 52 
0275+  053D C3 4C 4F 41         .BYTE   'C'+80H,"LOAD"
0275+  0541 44 
0276+  0542 C3 53 41 56         .BYTE   'C'+80H,"SAVE"
0276+  0546 45 
0277+  0547 CE 45 57            .BYTE   'N'+80H,"EW"
0278+  054A             
0279+  054A D4 41 42 28         .BYTE   'T'+80H,"AB("
0280+  054E D4 4F               .BYTE   'T'+80H,"O"
0281+  0550 C6 4E               .BYTE   'F'+80H,"N"
0282+  0552 D3 50 43 28         .BYTE   'S'+80H,"PC("
0283+  0556 D4 48 45 4E         .BYTE   'T'+80H,"HEN"
0284+  055A CE 4F 54            .BYTE   'N'+80H,"OT"
0285+  055D D3 54 45 50         .BYTE   'S'+80H,"TEP"
0286+  0561             
0287+  0561 AB                  .BYTE   '+'+80H
0288+  0562 AD                  .BYTE   '-'+80H
0289+  0563 AA                  .BYTE   '*'+80H
0290+  0564 AF                  .BYTE   '/'+80H
0291+  0565 DE                  .BYTE   '^'+80H
0292+  0566 C1 4E 44            .BYTE   'A'+80H,"ND"
0293+  0569 CF 52               .BYTE   'O'+80H,"R"
0294+  056B BE                  .BYTE   '>'+80H
0295+  056C BD                  .BYTE   '='+80H
0296+  056D BC                  .BYTE   '<'+80H
0297+  056E             
0298+  056E D3 47 4E            .BYTE   'S'+80H,"GN"
0299+  0571 C9 4E 54            .BYTE   'I'+80H,"NT"
0300+  0574 C1 42 53            .BYTE   'A'+80H,"BS"
0301+  0577 D5 53 52            .BYTE   'U'+80H,"SR"
0302+  057A C6 52 45            .BYTE   'F'+80H,"RE"
0303+  057D C9 4E 50            .BYTE   'I'+80H,"NP"
0304+  0580 D0 4F 53            .BYTE   'P'+80H,"OS"
0305+  0583 D3 51 52            .BYTE   'S'+80H,"QR"
0306+  0586 D2 4E 44            .BYTE   'R'+80H,"ND"
0307+  0589 CC 4F 47            .BYTE   'L'+80H,"OG"
0308+  058C C5 58 50            .BYTE   'E'+80H,"XP"
0309+  058F C3 4F 53            .BYTE   'C'+80H,"OS"
0310+  0592 D3 49 4E            .BYTE   'S'+80H,"IN"
0311+  0595 D4 41 4E            .BYTE   'T'+80H,"AN"
0312+  0598 C1 54 4E            .BYTE   'A'+80H,"TN"
0313+  059B D0 45 45 4B         .BYTE   'P'+80H,"EEK"
0314+  059F C4 45 45 4B         .BYTE   'D'+80H,"EEK"
0315+  05A3 D0 4F 49 4E         .BYTE   'P'+80H,"OINT"
0315+  05A7 54 
0316+  05A8 CC 45 4E            .BYTE   'L'+80H,"EN"
0317+  05AB D3 54 52 24         .BYTE   'S'+80H,"TR$"
0318+  05AF D6 41 4C            .BYTE   'V'+80H,"AL"
0319+  05B2 C1 53 43            .BYTE   'A'+80H,"SC"
0320+  05B5 C3 48 52 24         .BYTE   'C'+80H,"HR$"
0321+  05B9 C8 45 58 24         .BYTE   'H'+80H,"EX$"
0322+  05BD C2 49 4E 24         .BYTE   'B'+80H,"IN$"
0323+  05C1 CC 45 46 54         .BYTE   'L'+80H,"EFT$"
0323+  05C5 24 
0324+  05C6 D2 49 47 48         .BYTE   'R'+80H,"IGHT$"
0324+  05CA 54 24 
0325+  05CC CD 49 44 24         .BYTE   'M'+80H,"ID$"
0326+  05D0 80                  .BYTE   80H             ; End of list marker
0327+  05D1             
0328+  05D1             ; KEYWORD ADDRESS TABLE
0329+  05D1             
0330+  05D1 CB 0B       WORDTB: .WORD   PEND
0331+  05D3 C8 0A               .WORD   FOR
0332+  05D5 A3 0F               .WORD   NEXT
0333+  05D7 18 0D               .WORD   DATA
0334+  05D9 AA 0E               .WORD   INPUT
0335+  05DB DF 11               .WORD   DIM
0336+  05DD D9 0E               .WORD   READ
0337+  05DF 2F 0D               .WORD   LET
0338+  05E1 D5 0C               .WORD   GOTO
0339+  05E3 B8 0C               .WORD   RUN
0340+  05E5 A7 0D               .WORD   IF
0341+  05E7 91 0B               .WORD   RESTOR
0342+  05E9 C4 0C               .WORD   GOSUB
0343+  05EB F3 0C               .WORD   RETURN
0344+  05ED 1A 0D               .WORD   REM
0345+  05EF C9 0B               .WORD   STOP
0346+  05F1 18 17               .WORD   POUT
0347+  05F3 89 0D               .WORD   ON
0348+  05F5 0A 0C               .WORD   NULL
0349+  05F7 1E 17               .WORD   WAIT
0350+  05F9 BD 13               .WORD   DEF
0351+  05FB 67 17               .WORD   POKE
0352+  05FD AF 1E               .WORD   DOKE
0353+  05FF 1A 0D               .WORD   REM
0354+  0601 95 1E               .WORD   LINES
0355+  0603 88 1E               .WORD   CLS
0356+  0605 8D 1E               .WORD   WIDTH
0357+  0607 C5 1F               .WORD   MONITR
0358+  0609 04 31               .WORD   PSET
0359+  060B 07 31               .WORD   RESET
0360+  060D CB 0D               .WORD   PRINT
0361+  060F F7 0B               .WORD   CONT
0362+  0611 3D 0A               .WORD   LIST
0363+  0613 72 0C               .WORD   CLEAR
0364+  0615 1A 0D               .WORD   REM
0365+  0617 1A 0D               .WORD   REM
0366+  0619 35 08               .WORD   NEW
0367+  061B             
0368+  061B             ; RESERVED WORD TOKEN VALUES
0369+  061B             
0370+  061B             ZEND    .EQU    080H            ; END
0371+  061B             ZFOR    .EQU    081H            ; FOR
0372+  061B             ZDATA   .EQU    083H            ; DATA
0373+  061B             ZGOTO   .EQU    088H            ; GOTO
0374+  061B             ZGOSUB  .EQU    08CH            ; GOSUB
0375+  061B             ZREM    .EQU    08EH            ; REM
0376+  061B             ZPRINT  .EQU    09EH            ; PRINT
0377+  061B             ZNEW    .EQU    0A4H            ; NEW
0378+  061B             
0379+  061B             ZTAB    .EQU    0A5H            ; TAB
0380+  061B             ZTO     .EQU    0A6H            ; TO
0381+  061B             ZFN     .EQU    0A7H            ; FN
0382+  061B             ZSPC    .EQU    0A8H            ; SPC
0383+  061B             ZTHEN   .EQU    0A9H            ; THEN
0384+  061B             ZNOT    .EQU    0AAH            ; NOT
0385+  061B             ZSTEP   .EQU    0ABH            ; STEP
0386+  061B             
0387+  061B             ZPLUS   .EQU    0ACH            ; +
0388+  061B             ZMINUS  .EQU    0ADH            ; -
0389+  061B             ZTIMES  .EQU    0AEH            ; *
0390+  061B             ZDIV    .EQU    0AFH            ; /
0391+  061B             ZOR     .EQU    0B2H            ; OR
0392+  061B             ZGTR    .EQU    0B3H            ; >
0393+  061B             ZEQUAL  .EQU    0B4H            ; M
0394+  061B             ZLTH    .EQU    0B5H            ; <
0395+  061B             ZSGN    .EQU    0B6H            ; SGN
0396+  061B             ZPOINT  .EQU    0C7H            ; POINT
0397+  061B             ZLEFT   .EQU    0CDH +2         ; LEFT$
0398+  061B             
0399+  061B             ; ARITHMETIC PRECEDENCE TABLE
0400+  061B             
0401+  061B 79          PRITAB: .BYTE   79H             ; Precedence value
0402+  061C 51 1B               .WORD   PADD            ; FPREG = <last> + FPREG
0403+  061E             
0404+  061E 79                  .BYTE   79H             ; Precedence value
0405+  061F 85 17               .WORD   PSUB            ; FPREG = <last> - FPREG
0406+  0621             
0407+  0621 7C                  .BYTE   7CH             ; Precedence value
0408+  0622 C3 18               .WORD   MULT            ; PPREG = <last> * FPREG
0409+  0624             
0410+  0624 7C                  .BYTE   7CH             ; Precedence value
0411+  0625 24 19               .WORD   DIV             ; FPREG = <last> / FPREG
0412+  0627             
0413+  0627 7F                  .BYTE   7FH             ; Precedence value
0414+  0628 72 1C               .WORD   POWER           ; FPREG = <last> ^ FPREG
0415+  062A             
0416+  062A 50                  .BYTE   50H             ; Precedence value
0417+  062B 38 11               .WORD   PAND            ; FPREG = <last> AND FPREG
0418+  062D             
0419+  062D 46                  .BYTE   46H             ; Precedence value
0420+  062E 37 11               .WORD   POR             ; FPREG = <last> OR FPREG
0421+  0630             
0422+  0630             ; BASIC ERROR CODE LIST
0423+  0630             
0424+  0630 4E 46       ERRORS: .BYTE   "NF"            ; NEXT without FOR
0425+  0632 53 4E               .BYTE   "SN"            ; Syntax error
0426+  0634 52 47               .BYTE   "RG"            ; RETURN without GOSUB
0427+  0636 4F 44               .BYTE   "OD"            ; Out of DATA
0428+  0638 46 43               .BYTE   "FC"            ; Illegal function call
0429+  063A 4F 56               .BYTE   "OV"            ; Overflow error
0430+  063C 4F 4D               .BYTE   "OM"            ; Out of memory
0431+  063E 55 4C               .BYTE   "UL"            ; Undefined line
0432+  0640 42 53               .BYTE   "BS"            ; Bad subscript
0433+  0642 44 44               .BYTE   "DD"            ; Re-DIMensioned array
0434+  0644 2F 30               .BYTE   "/0"            ; Division by zero
0435+  0646 49 44               .BYTE   "ID"            ; Illegal direct
0436+  0648 54 4D               .BYTE   "TM"            ; Type mis-match
0437+  064A 4F 53               .BYTE   "OS"            ; Out of string space
0438+  064C 4C 53               .BYTE   "LS"            ; String too long
0439+  064E 53 54               .BYTE   "ST"            ; String formula too complex
0440+  0650 43 4E               .BYTE   "CN"            ; Can't CONTinue
0441+  0652 55 46               .BYTE   "UF"            ; Undefined FN function
0442+  0654 4D 4F               .BYTE   "MO"            ; Missing operand
0443+  0656 48 58               .BYTE   "HX"            ; HEX error
0444+  0658 42 4E               .BYTE   "BN"            ; BIN error
0445+  065A             
0446+  065A             ; INITIALISATION TABLE -------------------------------------------------------
0447+  065A             
0448+  065A C3 20 04    INITAB: JP      WARMST          ; Warm start jump
0449+  065D C3 48 0C            JP      FCERR           ; "USR (X)" jump (Set to Error)
0450+  0660 D3 00               OUT     (0),A           ; "OUT p,n" skeleton
0451+  0662 C9                  RET
0452+  0663 D6 00               SUB     0               ; Division support routine
0453+  0665 6F                  LD      L,A
0454+  0666 7C                  LD      A,H
0455+  0667 DE 00               SBC     A,0
0456+  0669 67                  LD      H,A
0457+  066A 78                  LD      A,B
0458+  066B DE 00               SBC     A,0
0459+  066D 47                  LD      B,A
0460+  066E 3E 00               LD      A,0
0461+  0670 C9                  RET
0462+  0671 00 00 00            .BYTE   0,0,0                   ; Random number seed table used by RND
0463+  0674 35 4A CA 99         .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
0464+  0678 39 1C 76 98         .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
0465+  067C 22 95 B3 98         .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
0466+  0680 0A DD 47 98         .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
0467+  0684 53 D1 99 99         .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
0468+  0688 0A 1A 9F 98         .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
0469+  068C 65 BC CD 98         .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
0470+  0690 D6 77 3E 98         .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
0471+  0694 52 C7 4F 80         .BYTE   052H,0C7H,04FH,080H     ; Last random number
0472+  0698 DB 00               IN      A,(0)           ; INP (x) skeleton
0473+  069A C9                  RET
0474+  069B 01                  .BYTE   1               ; POS (x) number (1)
0475+  069C FF                  .BYTE   255             ; Terminal width (255 = no auto CRLF)
0476+  069D 1C                  .BYTE   28              ; Width for commas (3 columns)
0477+  069E 00                  .BYTE   0               ; No nulls after input bytes
0478+  069F 00                  .BYTE   0               ; Output enabled (^O off)
0479+  06A0 14 00               .WORD   20              ; Initial lines counter
0480+  06A2 14 00               .WORD   20              ; Initial lines number
0481+  06A4 00 00               .WORD   0               ; Array load/save check sum
0482+  06A6 00                  .BYTE   0               ; Break not by NMI
0483+  06A7 00                  .BYTE   0               ; Break flag
0484+  06A8 C3 6E 09            JP      TTYLIN          ; Input reflection (set to TTY)
0485+  06AB C3 00 00            JP      $0000           ; POINT reflection unused
0486+  06AE C3 00 00            JP      $0000           ; SET reflection
0487+  06B1 C3 00 00            JP      $0000          	; RESET reflection
0488+  06B4 0D 32               .WORD   STLOOK          ; Temp string space
0489+  06B6 FE FF               .WORD   -2              ; Current line number (cold)
0490+  06B8 AA 31               .WORD   PROGST+1        ; Start of program text
0491+  06BA             INITBE:                         
0492+  06BA             
0493+  06BA             ; END OF INITIALISATION TABLE ---------------------------------------------------
0494+  06BA             
0495+  06BA 20 45 72 72 ERRMSG: .BYTE   " Error",0
0495+  06BE 6F 72 00 
0496+  06C1 20 69 6E 20 INMSG:  .BYTE   " in ",0
0496+  06C5 00 
0497+  06C6             ZERBYT  .EQU    $-1             ; A zero byte
0498+  06C6 4F 6B 0D 0A OKMSG:  .BYTE   "Ok",CR,LF,0,0
0498+  06CA 00 00 
0499+  06CC 42 72 65 61 BRKMSG: .BYTE   "Break",0
0499+  06D0 6B 00 
0500+  06D2             
0501+  06D2 21 04 00    BAKSTK: LD      HL,4            ; Look for "FOR" block with
0502+  06D5 39                  ADD     HL,SP           ; same index as specified
0503+  06D6 7E          LOKFOR: LD      A,(HL)          ; Get block ID
0504+  06D7 23                  INC     HL              ; Point to index address
0505+  06D8 FE 81               CP      ZFOR            ; Is it a "FOR" token
0506+  06DA C0                  RET     NZ              ; No - exit
0507+  06DB 4E                  LD      C,(HL)          ; BC = Address of "FOR" index
0508+  06DC 23                  INC     HL
0509+  06DD 46                  LD      B,(HL)
0510+  06DE 23                  INC     HL              ; Point to sign of STEP
0511+  06DF E5                  PUSH    HL              ; Save pointer to sign
0512+  06E0 69                  LD      L,C             ; HL = address of "FOR" index
0513+  06E1 60                  LD      H,B
0514+  06E2 7A                  LD      A,D             ; See if an index was specified
0515+  06E3 B3                  OR      E               ; DE = 0 if no index specified
0516+  06E4 EB                  EX      DE,HL           ; Specified index into HL
0517+  06E5 CA EC 06            JP      Z,INDFND        ; Skip if no index given
0518+  06E8 EB                  EX      DE,HL           ; Index back into DE
0519+  06E9 CD F1 09            CALL    CPDEHL          ; Compare index with one given
0520+  06EC 01 0D 00    INDFND: LD      BC,16-3         ; Offset to next block
0521+  06EF E1                  POP     HL              ; Restore pointer to sign
0522+  06F0 C8                  RET     Z               ; Return if block found
0523+  06F1 09                  ADD     HL,BC           ; Point to next block
0524+  06F2 C3 D6 06            JP      LOKFOR          ; Keep on looking
0525+  06F5             
0526+  06F5 CD 0F 07    MOVUP:  CALL    ENFMEM          ; See if enough memory
0527+  06F8 C5          MOVSTR: PUSH    BC              ; Save end of source
0528+  06F9 E3                  EX      (SP),HL         ; Swap source and dest" end
0529+  06FA C1                  POP     BC              ; Get end of destination
0530+  06FB CD F1 09    MOVLP:  CALL    CPDEHL          ; See if list moved
0531+  06FE 7E                  LD      A,(HL)          ; Get byte
0532+  06FF 02                  LD      (BC),A          ; Move it
0533+  0700 C8                  RET     Z               ; Exit if all done
0534+  0701 0B                  DEC     BC              ; Next byte to move to
0535+  0702 2B                  DEC     HL              ; Next byte to move
0536+  0703 C3 FB 06            JP      MOVLP           ; Loop until all bytes moved
0537+  0706             
0538+  0706 E5          CHKSTK: PUSH    HL              ; Save code string address
0539+  0707 2A 8A 31            LD      HL,(ARREND)     ; Lowest free memory
0540+  070A 06 00               LD      B,0             ; BC = Number of levels to test
0541+  070C 09                  ADD     HL,BC           ; 2 Bytes for each level
0542+  070D 09                  ADD     HL,BC
0543+  070E 3E                  .BYTE   3EH             ; Skip "PUSH HL"
0544+  070F E5          ENFMEM: PUSH    HL              ; Save code string address
0545+  0710 3E D0               LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
0546+  0712 95                  SUB     L
0547+  0713 6F                  LD      L,A
0548+  0714 3E FF               LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
0549+  0716 9C                  SBC     A,H
0550+  0717 DA 1E 07            JP      C,OMERR         ; Not enough - ?OM Error
0551+  071A 67                  LD      H,A
0552+  071B 39                  ADD     HL,SP           ; Test if stack is overflowed
0553+  071C E1                  POP     HL              ; Restore code string address
0554+  071D D8                  RET     C               ; Return if enough mmory
0555+  071E 1E 0C       OMERR:  LD      E,OM            ; ?OM Error
0556+  0720 C3 3D 07            JP      ERROR
0557+  0723             
0558+  0723 2A 79 31    DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
0559+  0726 22 0C 31            LD      (LINEAT),HL     ; Save as current line
0560+  0729 1E 02       SNERR:  LD      E,SN            ; ?SN Error
0561+  072B 01                  .BYTE   01H             ; Skip "LD E,DZ"
0562+  072C 1E 14       DZERR:  LD      E,DZ            ; ?/0 Error
0563+  072E 01                  .BYTE   01H             ; Skip "LD E,NF"
0564+  072F 1E 00       NFERR:  LD      E,NF            ; ?NF Error
0565+  0731 01                  .BYTE   01H             ; Skip "LD E,DD"
0566+  0732 1E 12       DDERR:  LD      E,DD            ; ?DD Error
0567+  0734 01                  .BYTE   01H             ; Skip "LD E,UF"
0568+  0735 1E 22       UFERR:  LD      E,UF            ; ?UF Error
0569+  0737 01                  .BYTE   01H             ; Skip "LD E,OV
0570+  0738 1E 0A       OVERR:  LD      E,OV            ; ?OV Error
0571+  073A 01                  .BYTE   01H             ; Skip "LD E,TM"
0572+  073B 1E 18       TMERR:  LD      E,TM            ; ?TM Error
0573+  073D             
0574+  073D CD 5B 08    ERROR:  CALL    CLREG           ; Clear registers and stack
0575+  0740 32 F5 30            LD      (CTLOFG),A      ; Enable output (A is 0)
0576+  0743 CD 1C 0E            CALL    STTLIN          ; Start new line
0577+  0746 21 30 06            LD      HL,ERRORS       ; Point to error codes
0578+  0749 57                  LD      D,A             ; D = 0 (A is 0)
0579+  074A 3E 3F               LD      A,'?'
0580+  074C CD 02 0A            CALL    OUTC            ; Output '?'
0581+  074F 19                  ADD     HL,DE           ; Offset to correct error code
0582+  0750 7E                  LD      A,(HL)          ; First character
0583+  0751 CD 02 0A            CALL    OUTC            ; Output it
0584+  0754 CD 81 0B            CALL    GETCHR          ; Get next character
0585+  0757 CD 02 0A            CALL    OUTC            ; Output it
0586+  075A 21 BA 06            LD      HL,ERRMSG       ; "Error" message
0587+  075D CD C7 14    ERRIN:  CALL    PRS             ; Output message
0588+  0760 2A 0C 31            LD      HL,(LINEAT)     ; Get line of error
0589+  0763 11 FE FF            LD      DE,-2           ; Cold start error if -2
0590+  0766 CD F1 09            CALL    CPDEHL          ; See if cold start error
0591+  0769 CA 8D 03            JP      Z,CSTART        ; Cold start error - Restart
0592+  076C 7C                  LD      A,H             ; Was it a direct error?
0593+  076D A5                  AND     L               ; Line = -1 if direct error
0594+  076E 3C                  INC     A
0595+  076F C4 62 1B            CALL    NZ,LINEIN       ; No - output line of error
0596+  0772 3E                  .BYTE   3EH             ; Skip "POP BC"
0597+  0773 C1          POPNOK: POP     BC              ; Drop address in input buffer
0598+  0774             
0599+  0774 AF          PRNTOK: XOR     A               ; Output "Ok" and get command
0600+  0775 32 F5 30            LD      (CTLOFG),A      ; Enable output
0601+  0778 CD 1C 0E            CALL    STTLIN          ; Start new line
0602+  077B 21 C6 06            LD      HL,OKMSG        ; "Ok" message
0603+  077E CD C7 14            CALL    PRS             ; Output "Ok"
0604+  0781 21 FF FF    GETCMD: LD      HL,-1           ; Flag direct mode
0605+  0784 22 0C 31            LD      (LINEAT),HL     ; Save as current line
0606+  0787 CD 6E 09            CALL    GETLIN          ; Get an input line
0607+  078A DA 81 07            JP      C,GETCMD        ; Get line again if break
0608+  078D CD 81 0B            CALL    GETCHR          ; Get first character
0609+  0790 3C                  INC     A               ; Test if end of line
0610+  0791 3D                  DEC     A               ; Without affecting Carry
0611+  0792 CA 81 07            JP      Z,GETCMD        ; Nothing entered - Get another
0612+  0795 F5                  PUSH    AF              ; Save Carry status
0613+  0796 CD 4D 0C            CALL    ATOH            ; Get line number into DE
0614+  0799 D5                  PUSH    DE              ; Save line number
0615+  079A CD 85 08            CALL    CRUNCH          ; Tokenise rest of line
0616+  079D 47                  LD      B,A             ; Length of tokenised line
0617+  079E D1                  POP     DE              ; Restore line number
0618+  079F F1                  POP     AF              ; Restore Carry
0619+  07A0 D2 61 0B            JP      NC,EXCUTE       ; No line number - Direct mode
0620+  07A3 D5                  PUSH    DE              ; Save line number
0621+  07A4 C5                  PUSH    BC              ; Save length of tokenised line
0622+  07A5 AF                  XOR     A
0623+  07A6 32 7C 31            LD      (LSTBIN),A      ; Clear last byte input
0624+  07A9 CD 81 0B            CALL    GETCHR          ; Get next character
0625+  07AC B7                  OR      A               ; Set flags
0626+  07AD F5                  PUSH    AF              ; And save them
0627+  07AE CD 15 08            CALL    SRCHLN          ; Search for line number in DE
0628+  07B1 DA BA 07            JP      C,LINFND        ; Jump if line found
0629+  07B4 F1                  POP     AF              ; Get status
0630+  07B5 F5                  PUSH    AF              ; And re-save
0631+  07B6 CA EE 0C            JP      Z,ULERR         ; Nothing after number - Error
0632+  07B9 B7                  OR      A               ; Clear Carry
0633+  07BA C5          LINFND: PUSH    BC              ; Save address of line in prog
0634+  07BB D2 D1 07            JP      NC,INEWLN       ; Line not found - Insert new
0635+  07BE EB                  EX      DE,HL           ; Next line address in DE
0636+  07BF 2A 86 31            LD      HL,(PROGND)     ; End of program
0637+  07C2 1A          SFTPRG: LD      A,(DE)          ; Shift rest of program down
0638+  07C3 02                  LD      (BC),A
0639+  07C4 03                  INC     BC              ; Next destination
0640+  07C5 13                  INC     DE              ; Next source
0641+  07C6 CD F1 09            CALL    CPDEHL          ; All done?
0642+  07C9 C2 C2 07            JP      NZ,SFTPRG       ; More to do
0643+  07CC 60                  LD      H,B             ; HL - New end of program
0644+  07CD 69                  LD      L,C
0645+  07CE 22 86 31            LD      (PROGND),HL     ; Update end of program
0646+  07D1             
0647+  07D1 D1          INEWLN: POP     DE              ; Get address of line,
0648+  07D2 F1                  POP     AF              ; Get status
0649+  07D3 CA F8 07            JP      Z,SETPTR        ; No text - Set up pointers
0650+  07D6 2A 86 31            LD      HL,(PROGND)     ; Get end of program
0651+  07D9 E3                  EX      (SP),HL         ; Get length of input line
0652+  07DA C1                  POP     BC              ; End of program to BC
0653+  07DB 09                  ADD     HL,BC           ; Find new end
0654+  07DC E5                  PUSH    HL              ; Save new end
0655+  07DD CD F5 06            CALL    MOVUP           ; Make space for line
0656+  07E0 E1                  POP     HL              ; Restore new end
0657+  07E1 22 86 31            LD      (PROGND),HL     ; Update end of program pointer
0658+  07E4 EB                  EX      DE,HL           ; Get line to move up in HL
0659+  07E5 74                  LD      (HL),H          ; Save MSB
0660+  07E6 D1                  POP     DE              ; Get new line number
0661+  07E7 23                  INC     HL              ; Skip pointer
0662+  07E8 23                  INC     HL
0663+  07E9 73                  LD      (HL),E          ; Save LSB of line number
0664+  07EA 23                  INC     HL
0665+  07EB 72                  LD      (HL),D          ; Save MSB of line number
0666+  07EC 23                  INC     HL              ; To first byte in line
0667+  07ED 11 11 31            LD      DE,BUFFER       ; Copy buffer to program
0668+  07F0 1A          MOVBUF: LD      A,(DE)          ; Get source
0669+  07F1 77                  LD      (HL),A          ; Save destinations
0670+  07F2 23                  INC     HL              ; Next source
0671+  07F3 13                  INC     DE              ; Next destination
0672+  07F4 B7                  OR      A               ; Done?
0673+  07F5 C2 F0 07            JP      NZ,MOVBUF       ; No - Repeat
0674+  07F8 CD 41 08    SETPTR: CALL    RUNFST          ; Set line pointers
0675+  07FB 23                  INC     HL              ; To LSB of pointer
0676+  07FC EB                  EX      DE,HL           ; Address to DE
0677+  07FD 62          PTRLP:  LD      H,D             ; Address to HL
0678+  07FE 6B                  LD      L,E
0679+  07FF 7E                  LD      A,(HL)          ; Get LSB of pointer
0680+  0800 23                  INC     HL              ; To MSB of pointer
0681+  0801 B6                  OR      (HL)            ; Compare with MSB pointer
0682+  0802 CA 81 07            JP      Z,GETCMD        ; Get command line if end
0683+  0805 23                  INC     HL              ; To LSB of line number
0684+  0806 23                  INC     HL              ; Skip line number
0685+  0807 23                  INC     HL              ; Point to first byte in line
0686+  0808 AF                  XOR     A               ; Looking for 00 byte
0687+  0809 BE          FNDEND: CP      (HL)            ; Found end of line?
0688+  080A 23                  INC     HL              ; Move to next byte
0689+  080B C2 09 08            JP      NZ,FNDEND       ; No - Keep looking
0690+  080E EB                  EX      DE,HL           ; Next line address to HL
0691+  080F 73                  LD      (HL),E          ; Save LSB of pointer
0692+  0810 23                  INC     HL
0693+  0811 72                  LD      (HL),D          ; Save MSB of pointer
0694+  0812 C3 FD 07            JP      PTRLP           ; Do next line
0695+  0815             
0696+  0815 2A 0E 31    SRCHLN: LD      HL,(BASTXT)     ; Start of program text
0697+  0818 44          SRCHLP: LD      B,H             ; BC = Address to look at
0698+  0819 4D                  LD      C,L
0699+  081A 7E                  LD      A,(HL)          ; Get address of next line
0700+  081B 23                  INC     HL
0701+  081C B6                  OR      (HL)            ; End of program found?
0702+  081D 2B                  DEC     HL
0703+  081E C8                  RET     Z               ; Yes - Line not found
0704+  081F 23                  INC     HL
0705+  0820 23                  INC     HL
0706+  0821 7E                  LD      A,(HL)          ; Get LSB of line number
0707+  0822 23                  INC     HL
0708+  0823 66                  LD      H,(HL)          ; Get MSB of line number
0709+  0824 6F                  LD      L,A
0710+  0825 CD F1 09            CALL    CPDEHL          ; Compare with line in DE
0711+  0828 60                  LD      H,B             ; HL = Start of this line
0712+  0829 69                  LD      L,C
0713+  082A 7E                  LD      A,(HL)          ; Get LSB of next line address
0714+  082B 23                  INC     HL
0715+  082C 66                  LD      H,(HL)          ; Get MSB of next line address
0716+  082D 6F                  LD      L,A             ; Next line to HL
0717+  082E 3F                  CCF
0718+  082F C8                  RET     Z               ; Lines found - Exit
0719+  0830 3F                  CCF
0720+  0831 D0                  RET     NC              ; Line not found,at line after
0721+  0832 C3 18 08            JP      SRCHLP          ; Keep looking
0722+  0835             
0723+  0835 C0          NEW:    RET     NZ              ; Return if any more on line
0724+  0836 2A 0E 31    CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
0725+  0839 AF                  XOR     A               ; Set program area to empty
0726+  083A 77                  LD      (HL),A          ; Save LSB = 00
0727+  083B 23                  INC     HL
0728+  083C 77                  LD      (HL),A          ; Save MSB = 00
0729+  083D 23                  INC     HL
0730+  083E 22 86 31            LD      (PROGND),HL     ; Set program end
0731+  0841             
0732+  0841 2A 0E 31    RUNFST: LD      HL,(BASTXT)     ; Clear all variables
0733+  0844 2B                  DEC     HL
0734+  0845             
0735+  0845 22 7E 31    INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
0736+  0848 2A 5F 31            LD      HL,(LSTRAM)     ; Get end of RAM
0737+  084B 22 73 31            LD      (STRBOT),HL     ; Clear string space
0738+  084E AF                  XOR     A
0739+  084F CD 91 0B            CALL    RESTOR          ; Reset DATA pointers
0740+  0852 2A 86 31            LD      HL,(PROGND)     ; Get end of program
0741+  0855 22 88 31            LD      (VAREND),HL     ; Clear variables
0742+  0858 22 8A 31            LD      (ARREND),HL     ; Clear arrays
0743+  085B             
0744+  085B C1          CLREG:  POP     BC              ; Save return address
0745+  085C 2A 0A 31            LD      HL,(STRSPC)     ; Get end of working RAN
0746+  085F F9                  LD      SP,HL           ; Set stack
0747+  0860 21 63 31            LD      HL,TMSTPL       ; Temporary string pool
0748+  0863 22 61 31            LD      (TMSTPT),HL     ; Reset temporary string ptr
0749+  0866 AF                  XOR     A               ; A = 00
0750+  0867 6F                  LD      L,A             ; HL = 0000
0751+  0868 67                  LD      H,A
0752+  0869 22 84 31            LD      (CONTAD),HL     ; No CONTinue
0753+  086C 32 7B 31            LD      (FORFLG),A      ; Clear FOR flag
0754+  086F 22 8E 31            LD      (FNRGNM),HL     ; Clear FN argument
0755+  0872 E5                  PUSH    HL              ; HL = 0000
0756+  0873 C5                  PUSH    BC              ; Put back return
0757+  0874 2A 7E 31    DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
0758+  0877 C9                  RET                     ; Return to execution driver
0759+  0878             
0760+  0878 3E 3F       PROMPT: LD      A,'?'           ; '?'
0761+  087A CD 02 0A            CALL    OUTC            ; Output character
0762+  087D 3E 20               LD      A,' '           ; Space
0763+  087F CD 02 0A            CALL    OUTC            ; Output character
0764+  0882 C3 FE 30            JP      RINPUT          ; Get input line
0765+  0885             
0766+  0885 AF          CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
0767+  0886 32 5E 31            LD      (DATFLG),A      ; Reset literal flag
0768+  0889 0E 05               LD      C,2+3           ; 2 byte number and 3 nulls
0769+  088B 11 11 31            LD      DE,BUFFER       ; Start of input buffer
0770+  088E 7E          CRNCLP: LD      A,(HL)          ; Get byte
0771+  088F FE 20               CP      ' '             ; Is it a space?
0772+  0891 CA 0D 09            JP      Z,MOVDIR        ; Yes - Copy direct
0773+  0894 47                  LD      B,A             ; Save character
0774+  0895 FE 22               CP      '"'             ; Is it a quote?
0775+  0897 CA 2D 09            JP      Z,CPYLIT        ; Yes - Copy literal string
0776+  089A B7                  OR      A               ; Is it end of buffer?
0777+  089B CA 34 09            JP      Z,ENDBUF        ; Yes - End buffer
0778+  089E 3A 5E 31            LD      A,(DATFLG)      ; Get data type
0779+  08A1 B7                  OR      A               ; Literal?
0780+  08A2 7E                  LD      A,(HL)          ; Get byte to copy
0781+  08A3 C2 0D 09            JP      NZ,MOVDIR       ; Literal - Copy direct
0782+  08A6 FE 3F               CP      '?'             ; Is it '?' short for PRINT
0783+  08A8 3E 9E               LD      A,ZPRINT        ; "PRINT" token
0784+  08AA CA 0D 09            JP      Z,MOVDIR        ; Yes - replace it
0785+  08AD 7E                  LD      A,(HL)          ; Get byte again
0786+  08AE FE 30               CP      '0'             ; Is it less than '0'
0787+  08B0 DA B8 08            JP      C,FNDWRD        ; Yes - Look for reserved words
0788+  08B3 FE 3C               CP      60; ";"+1           ; Is it "0123456789:;" ?
0789+  08B5 DA 0D 09            JP      C,MOVDIR        ; Yes - copy it direct
0790+  08B8 D5          FNDWRD: PUSH    DE              ; Look for reserved words
0791+  08B9 11 B1 04            LD      DE,WORDS-1      ; Point to table
0792+  08BC C5                  PUSH    BC              ; Save count
0793+  08BD 01 09 09            LD      BC,RETNAD       ; Where to return to
0794+  08C0 C5                  PUSH    BC              ; Save return address
0795+  08C1 06 7F               LD      B,ZEND-1        ; First token value -1
0796+  08C3 7E                  LD      A,(HL)          ; Get byte
0797+  08C4 FE 61               CP      'a'             ; Less than 'a' ?
0798+  08C6 DA D1 08            JP      C,SEARCH        ; Yes - search for words
0799+  08C9 FE 7B               CP      'z'+1           ; Greater than 'z' ?
0800+  08CB D2 D1 08            JP      NC,SEARCH       ; Yes - search for words
0801+  08CE E6 5F               AND     01011111B       ; Force upper case
0802+  08D0 77                  LD      (HL),A          ; Replace byte
0803+  08D1 4E          SEARCH: LD      C,(HL)          ; Search for a word
0804+  08D2 EB                  EX      DE,HL
0805+  08D3 23          GETNXT: INC     HL              ; Get next reserved word
0806+  08D4 B6                  OR      (HL)            ; Start of word?
0807+  08D5 F2 D3 08            JP      P,GETNXT        ; No - move on
0808+  08D8 04                  INC     B               ; Increment token value
0809+  08D9 7E                  LD      A, (HL)         ; Get byte from table
0810+  08DA E6 7F               AND     01111111B       ; Strip bit 7
0811+  08DC C8                  RET     Z               ; Return if end of list
0812+  08DD B9                  CP      C               ; Same character as in buffer?
0813+  08DE C2 D3 08            JP      NZ,GETNXT       ; No - get next word
0814+  08E1 EB                  EX      DE,HL
0815+  08E2 E5                  PUSH    HL              ; Save start of word
0816+  08E3             
0817+  08E3 13          NXTBYT: INC     DE              ; Look through rest of word
0818+  08E4 1A                  LD      A,(DE)          ; Get byte from table
0819+  08E5 B7                  OR      A               ; End of word ?
0820+  08E6 FA 05 09            JP      M,MATCH         ; Yes - Match found
0821+  08E9 4F                  LD      C,A             ; Save it
0822+  08EA 78                  LD      A,B             ; Get token value
0823+  08EB FE 88               CP      ZGOTO           ; Is it "GOTO" token ?
0824+  08ED C2 F4 08            JP      NZ,NOSPC        ; No - Don't allow spaces
0825+  08F0 CD 81 0B            CALL    GETCHR          ; Get next character
0826+  08F3 2B                  DEC     HL              ; Cancel increment from GETCHR
0827+  08F4 23          NOSPC:  INC     HL              ; Next byte
0828+  08F5 7E                  LD      A,(HL)          ; Get byte
0829+  08F6 FE 61               CP      'a'             ; Less than 'a' ?
0830+  08F8 DA FD 08            JP      C,NOCHNG        ; Yes - don't change
0831+  08FB E6 5F               AND     01011111B       ; Make upper case
0832+  08FD B9          NOCHNG: CP      C               ; Same as in buffer ?
0833+  08FE CA E3 08            JP      Z,NXTBYT        ; Yes - keep testing
0834+  0901 E1                  POP     HL              ; Get back start of word
0835+  0902 C3 D1 08            JP      SEARCH          ; Look at next word
0836+  0905             
0837+  0905 48          MATCH:  LD      C,B             ; Word found - Save token value
0838+  0906 F1                  POP     AF              ; Throw away return
0839+  0907 EB                  EX      DE,HL
0840+  0908 C9                  RET                     ; Return to "RETNAD"
0841+  0909 EB          RETNAD: EX      DE,HL           ; Get address in string
0842+  090A 79                  LD      A,C             ; Get token value
0843+  090B C1                  POP     BC              ; Restore buffer length
0844+  090C D1                  POP     DE              ; Get destination address
0845+  090D 23          MOVDIR: INC     HL              ; Next source in buffer
0846+  090E 12                  LD      (DE),A          ; Put byte in buffer
0847+  090F 13                  INC     DE              ; Move up buffer
0848+  0910 0C                  INC     C               ; Increment length of buffer
0849+  0911 D6 3A               SUB     ':'             ; End of statement?
0850+  0913 CA 1B 09            JP      Z,SETLIT        ; Jump if multi-statement line
0851+  0916 FE 49               CP      ZDATA-3AH       ; Is it DATA statement ?
0852+  0918 C2 1E 09            JP      NZ,TSTREM       ; No - see if REM
0853+  091B 32 5E 31    SETLIT: LD      (DATFLG),A      ; Set literal flag
0854+  091E D6 54       TSTREM: SUB     ZREM-3AH        ; Is it REM?
0855+  0920 C2 8E 08            JP      NZ,CRNCLP       ; No - Leave flag
0856+  0923 47                  LD      B,A             ; Copy rest of buffer
0857+  0924 7E          NXTCHR: LD      A,(HL)          ; Get byte
0858+  0925 B7                  OR      A               ; End of line ?
0859+  0926 CA 34 09            JP      Z,ENDBUF        ; Yes - Terminate buffer
0860+  0929 B8                  CP      B               ; End of statement ?
0861+  092A CA 0D 09            JP      Z,MOVDIR        ; Yes - Get next one
0862+  092D 23          CPYLIT: INC     HL              ; Move up source string
0863+  092E 12                  LD      (DE),A          ; Save in destination
0864+  092F 0C                  INC     C               ; Increment length
0865+  0930 13                  INC     DE              ; Move up destination
0866+  0931 C3 24 09            JP      NXTCHR          ; Repeat
0867+  0934             
0868+  0934 21 10 31    ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
0869+  0937 12                  LD      (DE),A          ; Mark end of buffer (A = 00)
0870+  0938 13                  INC     DE
0871+  0939 12                  LD      (DE),A          ; A = 00
0872+  093A 13                  INC     DE
0873+  093B 12                  LD      (DE),A          ; A = 00
0874+  093C C9                  RET
0875+  093D             
0876+  093D 3A F4 30    DODEL:  LD      A,(NULFLG)      ; Get null flag status
0877+  0940 B7                  OR      A               ; Is it zero?
0878+  0941 3E 00               LD      A,0             ; Zero A - Leave flags
0879+  0943 32 F4 30            LD      (NULFLG),A      ; Zero null flag
0880+  0946 C2 51 09            JP      NZ,ECHDEL       ; Set - Echo it
0881+  0949 05                  DEC     B               ; Decrement length
0882+  094A CA 6E 09            JP      Z,GETLIN        ; Get line again if empty
0883+  094D CD 02 0A            CALL    OUTC            ; Output null character
0884+  0950 3E                  .BYTE   3EH             ; Skip "DEC B"
0885+  0951 05          ECHDEL: DEC     B               ; Count bytes in buffer
0886+  0952 2B                  DEC     HL              ; Back space buffer
0887+  0953 CA 65 09            JP      Z,OTKLN         ; No buffer - Try again
0888+  0956 7E                  LD      A,(HL)          ; Get deleted byte
0889+  0957 CD 02 0A            CALL    OUTC            ; Echo it
0890+  095A C3 77 09            JP      MORINP          ; Get more input
0891+  095D             
0892+  095D 05          DELCHR: DEC     B               ; Count bytes in buffer
0893+  095E 2B                  DEC     HL              ; Back space buffer
0894+  095F CD 02 0A            CALL    OUTC            ; Output character in A
0895+  0962 C2 77 09            JP      NZ,MORINP       ; Not end - Get more
0896+  0965 CD 02 0A    OTKLN:  CALL    OUTC            ; Output character in A
0897+  0968 CD 29 0E    KILIN:  CALL    PRNTCRLF        ; Output CRLF
0898+  096B C3 6E 09            JP      TTYLIN          ; Get line again
0899+  096E             
0900+  096E             GETLIN:
0901+  096E 21 11 31    TTYLIN: LD      HL,BUFFER       ; Get a line by character
0902+  0971 06 01               LD      B,1             ; Set buffer as empty
0903+  0973 AF                  XOR     A
0904+  0974 32 F4 30            LD      (NULFLG),A      ; Clear null flag
0905+  0977 CD 2C 0A    MORINP: CALL    CLOTST          ; Get character and test ^O
0906+  097A 4F                  LD      C,A             ; Save character in C
0907+  097B FE 7F               CP      DEL             ; Delete character?
0908+  097D CA 3D 09            JP      Z,DODEL         ; Yes - Process it
0909+  0980 3A F4 30            LD      A,(NULFLG)      ; Get null flag
0910+  0983 B7                  OR      A               ; Test null flag status
0911+  0984 CA 90 09            JP      Z,PROCES        ; Reset - Process character
0912+  0987 3E 00               LD      A,0             ; Set a null
0913+  0989 CD 02 0A            CALL    OUTC            ; Output null
0914+  098C AF                  XOR     A               ; Clear A
0915+  098D 32 F4 30            LD      (NULFLG),A      ; Reset null flag
0916+  0990 79          PROCES: LD      A,C             ; Get character
0917+  0991 FE 07               CP      CTRLG           ; Bell?
0918+  0993 CA D4 09            JP      Z,PUTCTL        ; Yes - Save it
0919+  0996 FE 03               CP      CTRLC           ; Is it control "C"?
0920+  0998 CC 29 0E            CALL    Z,PRNTCRLF      ; Yes - Output CRLF
0921+  099B 37                  SCF                     ; Flag break
0922+  099C C8                  RET     Z               ; Return if control "C"
0923+  099D FE 0D               CP      CR              ; Is it enter?
0924+  099F CA 24 0E            JP      Z,ENDINP        ; Yes - Terminate input
0925+  09A2 FE 15               CP      CTRLU           ; Is it control "U"?
0926+  09A4 CA 68 09            JP      Z,KILIN         ; Yes - Get another line
0927+  09A7 FE 40               CP      '@'             ; Is it "kill line"?
0928+  09A9 CA 65 09            JP      Z,OTKLN         ; Yes - Kill line
0929+  09AC FE 5F               CP      '_'             ; Is it delete?
0930+  09AE CA 5D 09            JP      Z,DELCHR        ; Yes - Delete character
0931+  09B1 FE 08               CP      BKSP            ; Is it backspace?
0932+  09B3 CA 5D 09            JP      Z,DELCHR        ; Yes - Delete character
0933+  09B6 FE 12               CP      CTRLR           ; Is it control "R"?
0934+  09B8 C2 CF 09            JP      NZ,PUTBUF       ; No - Put in buffer
0935+  09BB C5                  PUSH    BC              ; Save buffer length
0936+  09BC D5                  PUSH    DE              ; Save DE
0937+  09BD E5                  PUSH    HL              ; Save buffer address
0938+  09BE 36 00               LD      (HL),0          ; Mark end of buffer
0939+  09C0 CD D9 1F            CALL    OUTNCR          ; Output and do CRLF
0940+  09C3 21 11 31            LD      HL,BUFFER       ; Point to buffer start
0941+  09C6 CD C7 14            CALL    PRS             ; Output buffer
0942+  09C9 E1                  POP     HL              ; Restore buffer address
0943+  09CA D1                  POP     DE              ; Restore DE
0944+  09CB C1                  POP     BC              ; Restore buffer length
0945+  09CC C3 77 09            JP      MORINP          ; Get another character
0946+  09CF             
0947+  09CF FE 20       PUTBUF: CP      ' '             ; Is it a control code?
0948+  09D1 DA 77 09            JP      C,MORINP        ; Yes - Ignore
0949+  09D4 78          PUTCTL: LD      A,B             ; Get number of bytes in buffer
0950+  09D5 FE 49               CP      72+1            ; Test for line overflow
0951+  09D7 3E 07               LD      A,CTRLG         ; Set a bell
0952+  09D9 D2 E9 09            JP      NC,OUTNBS       ; Ring bell if buffer full
0953+  09DC 79                  LD      A,C             ; Get character
0954+  09DD 71                  LD      (HL),C          ; Save in buffer
0955+  09DE 32 7C 31            LD      (LSTBIN),A      ; Save last input byte
0956+  09E1 23                  INC     HL              ; Move up buffer
0957+  09E2 04                  INC     B               ; Increment length
0958+  09E3 CD 02 0A    OUTIT:  CALL    OUTC            ; Output the character entered
0959+  09E6 C3 77 09            JP      MORINP          ; Get another character
0960+  09E9             
0961+  09E9 CD 02 0A    OUTNBS: CALL    OUTC            ; Output bell and back over it
0962+  09EC 3E 08               LD      A,BKSP          ; Set back space
0963+  09EE C3 E3 09            JP      OUTIT           ; Output it and get more
0964+  09F1             
0965+  09F1 7C          CPDEHL: LD      A,H             ; Get H
0966+  09F2 92                  SUB     D               ; Compare with D
0967+  09F3 C0                  RET     NZ              ; Different - Exit
0968+  09F4 7D                  LD      A,L             ; Get L
0969+  09F5 93                  SUB     E               ; Compare with E
0970+  09F6 C9                  RET                     ; Return status
0971+  09F7             
0972+  09F7 7E          CHKSYN: LD      A,(HL)          ; Check syntax of character
0973+  09F8 E3                  EX      (SP),HL         ; Address of test byte
0974+  09F9 BE                  CP      (HL)            ; Same as in code string?
0975+  09FA 23                  INC     HL              ; Return address
0976+  09FB E3                  EX      (SP),HL         ; Put it back
0977+  09FC CA 81 0B            JP      Z,GETCHR        ; Yes - Get next character
0978+  09FF C3 29 07            JP      SNERR           ; Different - ?SN Error
0979+  0A02             
0980+  0A02 F5          OUTC:   PUSH    AF              ; Save character
0981+  0A03 3A F5 30            LD      A,(CTLOFG)      ; Get control "O" flag
0982+  0A06 B7                  OR      A               ; Is it set?
0983+  0A07 C2 FC 14            JP      NZ,POPAF        ; Yes - don't output
0984+  0A0A F1                  POP     AF              ; Restore character
0985+  0A0B C5                  PUSH    BC              ; Save buffer length
0986+  0A0C F5                  PUSH    AF              ; Save character
0987+  0A0D FE 20               CP      ' '             ; Is it a control code?
0988+  0A0F DA 26 0A            JP      C,DINPOS        ; Yes - Don't INC POS(X)
0989+  0A12 3A F2 30            LD      A,(LWIDTH)      ; Get line width
0990+  0A15 47                  LD      B,A             ; To B
0991+  0A16 3A 5B 31            LD      A,(CURPOS)      ; Get cursor position
0992+  0A19 04                  INC     B               ; Width 255?
0993+  0A1A CA 22 0A            JP      Z,INCLEN        ; Yes - No width limit
0994+  0A1D 05                  DEC     B               ; Restore width
0995+  0A1E B8                  CP      B               ; At end of line?
0996+  0A1F CC 29 0E            CALL    Z,PRNTCRLF      ; Yes - output CRLF
0997+  0A22 3C          INCLEN: INC     A               ; Move on one character
0998+  0A23 32 5B 31            LD      (CURPOS),A      ; Save new position
0999+  0A26 F1          DINPOS: POP     AF              ; Restore character
1000+  0A27 C1                  POP     BC              ; Restore buffer length
1001+  0A28 CD C2 1F            CALL    MONOUT          ; Send it
1002+  0A2B C9                  RET
1003+  0A2C             
1004+  0A2C CD 86 1E    CLOTST: CALL    GETINP          ; Get input character
1005+  0A2F E6 7F               AND     01111111B       ; Strip bit 7
1006+  0A31 FE 0F               CP      CTRLO           ; Is it control "O"?
1007+  0A33 C0                  RET     NZ              ; No don't flip flag
1008+  0A34 3A F5 30            LD      A,(CTLOFG)      ; Get flag
1009+  0A37 2F                  CPL                     ; Flip it
1010+  0A38 32 F5 30            LD      (CTLOFG),A      ; Put it back
1011+  0A3B AF                  XOR     A               ; Null character
1012+  0A3C C9                  RET
1013+  0A3D             
1014+  0A3D CD 4D 0C    LIST:   CALL    ATOH            ; ASCII number to DE
1015+  0A40 C0                  RET     NZ              ; Return if anything extra
1016+  0A41 C1                  POP     BC              ; Rubbish - Not needed
1017+  0A42 CD 15 08            CALL    SRCHLN          ; Search for line number in DE
1018+  0A45 C5                  PUSH    BC              ; Save address of line
1019+  0A46 CD 93 0A            CALL    SETLIN          ; Set up lines counter
1020+  0A49 E1          LISTLP: POP     HL              ; Restore address of line
1021+  0A4A 4E                  LD      C,(HL)          ; Get LSB of next line
1022+  0A4B 23                  INC     HL
1023+  0A4C 46                  LD      B,(HL)          ; Get MSB of next line
1024+  0A4D 23                  INC     HL
1025+  0A4E 78                  LD      A,B             ; BC = 0 (End of program)?
1026+  0A4F B1                  OR      C
1027+  0A50 CA 74 07            JP      Z,PRNTOK        ; Yes - Go to command mode
1028+  0A53 CD 9C 0A            CALL    COUNT           ; Count lines
1029+  0A56 CD AC 0B            CALL    TSTBRK          ; Test for break key
1030+  0A59 C5                  PUSH    BC              ; Save address of next line
1031+  0A5A CD 29 0E            CALL    PRNTCRLF        ; Output CRLF
1032+  0A5D 5E                  LD      E,(HL)          ; Get LSB of line number
1033+  0A5E 23                  INC     HL
1034+  0A5F 56                  LD      D,(HL)          ; Get MSB of line number
1035+  0A60 23                  INC     HL
1036+  0A61 E5                  PUSH    HL              ; Save address of line start
1037+  0A62 EB                  EX      DE,HL           ; Line number to HL
1038+  0A63 CD 6A 1B            CALL    PRNTHL          ; Output line number in decimal
1039+  0A66 3E 20               LD      A,' '           ; Space after line number
1040+  0A68 E1                  POP     HL              ; Restore start of line address
1041+  0A69 CD 02 0A    LSTLP2: CALL    OUTC            ; Output character in A
1042+  0A6C 7E          LSTLP3: LD      A,(HL)          ; Get next byte in line
1043+  0A6D B7                  OR      A               ; End of line?
1044+  0A6E 23                  INC     HL              ; To next byte in line
1045+  0A6F CA 49 0A            JP      Z,LISTLP        ; Yes - get next line
1046+  0A72 F2 69 0A            JP      P,LSTLP2        ; No token - output it
1047+  0A75 D6 7F               SUB     ZEND-1          ; Find and output word
1048+  0A77 4F                  LD      C,A             ; Token offset+1 to C
1049+  0A78 11 B2 04            LD      DE,WORDS        ; Reserved word list
1050+  0A7B 1A          FNDTOK: LD      A,(DE)          ; Get character in list
1051+  0A7C 13                  INC     DE              ; Move on to next
1052+  0A7D B7                  OR      A               ; Is it start of word?
1053+  0A7E F2 7B 0A            JP      P,FNDTOK        ; No - Keep looking for word
1054+  0A81 0D                  DEC     C               ; Count words
1055+  0A82 C2 7B 0A            JP      NZ,FNDTOK       ; Not there - keep looking
1056+  0A85 E6 7F       OUTWRD: AND     01111111B       ; Strip bit 7
1057+  0A87 CD 02 0A            CALL    OUTC            ; Output first character
1058+  0A8A 1A                  LD      A,(DE)          ; Get next character
1059+  0A8B 13                  INC     DE              ; Move on to next
1060+  0A8C B7                  OR      A               ; Is it end of word?
1061+  0A8D F2 85 0A            JP      P,OUTWRD        ; No - output the rest
1062+  0A90 C3 6C 0A            JP      LSTLP3          ; Next byte in line
1063+  0A93             
1064+  0A93 E5          SETLIN: PUSH    HL              ; Set up LINES counter
1065+  0A94 2A F8 30            LD      HL,(LINESN)     ; Get LINES number
1066+  0A97 22 F6 30            LD      (LINESC),HL     ; Save in LINES counter
1067+  0A9A E1                  POP     HL
1068+  0A9B C9                  RET
1069+  0A9C             
1070+  0A9C E5          COUNT:  PUSH    HL              ; Save code string address
1071+  0A9D D5                  PUSH    DE
1072+  0A9E 2A F6 30            LD      HL,(LINESC)     ; Get LINES counter
1073+  0AA1 11 FF FF            LD      DE,-1
1074+  0AA4 ED 5A               ADC     HL,DE           ; Decrement
1075+  0AA6 22 F6 30            LD      (LINESC),HL     ; Put it back
1076+  0AA9 D1                  POP     DE
1077+  0AAA E1                  POP     HL              ; Restore code string address
1078+  0AAB F0                  RET     P               ; Return if more lines to go
1079+  0AAC E5                  PUSH    HL              ; Save code string address
1080+  0AAD 2A F8 30            LD      HL,(LINESN)     ; Get LINES number
1081+  0AB0 22 F6 30            LD      (LINESC),HL     ; Reset LINES counter
1082+  0AB3 CD 86 1E            CALL    GETINP          ; Get input character
1083+  0AB6 FE 03               CP      CTRLC           ; Is it control "C"?
1084+  0AB8 CA BF 0A            JP      Z,RSLNBK        ; Yes - Reset LINES and break
1085+  0ABB E1                  POP     HL              ; Restore code string address
1086+  0ABC C3 9C 0A            JP      COUNT           ; Keep on counting
1087+  0ABF             
1088+  0ABF 2A F8 30    RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1089+  0AC2 22 F6 30            LD      (LINESC),HL     ; Reset LINES counter
1090+  0AC5 C3 23 04            JP      BRKRET          ; Go and output "Break"
1091+  0AC8             
1092+  0AC8 3E 64       FOR:    LD      A,64H           ; Flag "FOR" assignment
1093+  0ACA 32 7B 31            LD      (FORFLG),A      ; Save "FOR" flag
1094+  0ACD CD 2F 0D            CALL    LET             ; Set up initial index
1095+  0AD0 C1                  POP     BC              ; Drop RETurn address
1096+  0AD1 E5                  PUSH    HL              ; Save code string address
1097+  0AD2 CD 18 0D            CALL    DATA            ; Get next statement address
1098+  0AD5 22 77 31            LD      (LOOPST),HL     ; Save it for start of loop
1099+  0AD8 21 02 00            LD      HL,2            ; Offset for "FOR" block
1100+  0ADB 39                  ADD     HL,SP           ; Point to it
1101+  0ADC CD D6 06    FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1102+  0ADF D1                  POP     DE              ; Get code string address
1103+  0AE0 C2 F8 0A            JP      NZ,FORFND       ; No nesting found
1104+  0AE3 09                  ADD     HL,BC           ; Move into "FOR" block
1105+  0AE4 D5                  PUSH    DE              ; Save code string address
1106+  0AE5 2B                  DEC     HL
1107+  0AE6 56                  LD      D,(HL)          ; Get MSB of loop statement
1108+  0AE7 2B                  DEC     HL
1109+  0AE8 5E                  LD      E,(HL)          ; Get LSB of loop statement
1110+  0AE9 23                  INC     HL
1111+  0AEA 23                  INC     HL
1112+  0AEB E5                  PUSH    HL              ; Save block address
1113+  0AEC 2A 77 31            LD      HL,(LOOPST)     ; Get address of loop statement
1114+  0AEF CD F1 09            CALL    CPDEHL          ; Compare the FOR loops
1115+  0AF2 E1                  POP     HL              ; Restore block address
1116+  0AF3 C2 DC 0A            JP      NZ,FORSLP       ; Different FORs - Find another
1117+  0AF6 D1                  POP     DE              ; Restore code string address
1118+  0AF7 F9                  LD      SP,HL           ; Remove all nested loops
1119+  0AF8             
1120+  0AF8 EB          FORFND: EX      DE,HL           ; Code string address to HL
1121+  0AF9 0E 08               LD      C,8
1122+  0AFB CD 06 07            CALL    CHKSTK          ; Check for 8 levels of stack
1123+  0AFE E5                  PUSH    HL              ; Save code string address
1124+  0AFF 2A 77 31            LD      HL,(LOOPST)     ; Get first statement of loop
1125+  0B02 E3                  EX      (SP),HL         ; Save and restore code string
1126+  0B03 E5                  PUSH    HL              ; Re-save code string address
1127+  0B04 2A 0C 31            LD      HL,(LINEAT)     ; Get current line number
1128+  0B07 E3                  EX      (SP),HL         ; Save and restore code string
1129+  0B08 CD F1 0F            CALL    TSTNUM          ; Make sure it's a number
1130+  0B0B CD F7 09            CALL    CHKSYN          ; Make sure "TO" is next
1131+  0B0E A6                  .BYTE   ZTO          ; "TO" token
1132+  0B0F CD EE 0F            CALL    GETNUM          ; Get "TO" expression value
1133+  0B12 E5                  PUSH    HL              ; Save code string address
1134+  0B13 CD 1C 1A            CALL    BCDEFP          ; Move "TO" value to BCDE
1135+  0B16 E1                  POP     HL              ; Restore code string address
1136+  0B17 C5                  PUSH    BC              ; Save "TO" value in block
1137+  0B18 D5                  PUSH    DE
1138+  0B19 01 00 81            LD      BC,8100H        ; BCDE - 1 (default STEP)
1139+  0B1C 51                  LD      D,C             ; C=0
1140+  0B1D 5A                  LD      E,D             ; D=0
1141+  0B1E 7E                  LD      A,(HL)          ; Get next byte in code string
1142+  0B1F FE AB               CP      ZSTEP           ; See if "STEP" is stated
1143+  0B21 3E 01               LD      A,1             ; Sign of step = 1
1144+  0B23 C2 34 0B            JP      NZ,SAVSTP       ; No STEP given - Default to 1
1145+  0B26 CD 81 0B            CALL    GETCHR          ; Jump over "STEP" token
1146+  0B29 CD EE 0F            CALL    GETNUM          ; Get step value
1147+  0B2C E5                  PUSH    HL              ; Save code string address
1148+  0B2D CD 1C 1A            CALL    BCDEFP          ; Move STEP to BCDE
1149+  0B30 CD D0 19            CALL    TSTSGN          ; Test sign of FPREG
1150+  0B33 E1                  POP     HL              ; Restore code string address
1151+  0B34 C5          SAVSTP: PUSH    BC              ; Save the STEP value in block
1152+  0B35 D5                  PUSH    DE
1153+  0B36 F5                  PUSH    AF              ; Save sign of STEP
1154+  0B37 33                  INC     SP              ; Don't save flags
1155+  0B38 E5                  PUSH    HL              ; Save code string address
1156+  0B39 2A 7E 31            LD      HL,(BRKLIN)     ; Get address of index variable
1157+  0B3C E3                  EX      (SP),HL         ; Save and restore code string
1158+  0B3D 06 81       PUTFID: LD      B,ZFOR          ; "FOR" block marker
1159+  0B3F C5                  PUSH    BC              ; Save it
1160+  0B40 33                  INC     SP              ; Don't save C
1161+  0B41             
1162+  0B41 CD AC 0B    RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1163+  0B44 22 7E 31            LD      (BRKLIN),HL     ; Save code address for break
1164+  0B47 7E                  LD      A,(HL)          ; Get next byte in code string
1165+  0B48 FE 3A               CP      ':'             ; Multi statement line?
1166+  0B4A CA 61 0B            JP      Z,EXCUTE        ; Yes - Execute it
1167+  0B4D B7                  OR      A               ; End of line?
1168+  0B4E C2 29 07            JP      NZ,SNERR        ; No - Syntax error
1169+  0B51 23                  INC     HL              ; Point to address of next line
1170+  0B52 7E                  LD      A,(HL)          ; Get LSB of line pointer
1171+  0B53 23                  INC     HL
1172+  0B54 B6                  OR      (HL)            ; Is it zero (End of prog)?
1173+  0B55 CA D3 0B            JP      Z,ENDPRG        ; Yes - Terminate execution
1174+  0B58 23                  INC     HL              ; Point to line number
1175+  0B59 5E                  LD      E,(HL)          ; Get LSB of line number
1176+  0B5A 23                  INC     HL
1177+  0B5B 56                  LD      D,(HL)          ; Get MSB of line number
1178+  0B5C EB                  EX      DE,HL           ; Line number to HL
1179+  0B5D 22 0C 31            LD      (LINEAT),HL     ; Save as current line number
1180+  0B60 EB                  EX      DE,HL           ; Line number back to DE
1181+  0B61 CD 81 0B    EXCUTE: CALL    GETCHR          ; Get key word
1182+  0B64 11 41 0B            LD      DE,RUNCNT       ; Where to RETurn to
1183+  0B67 D5                  PUSH    DE              ; Save for RETurn
1184+  0B68 C8          IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1185+  0B69 D6 80       ONJMP:  SUB     ZEND            ; Is it a token?
1186+  0B6B DA 2F 0D            JP      C,LET           ; No - try to assign it
1187+  0B6E FE 25               CP      ZNEW+1-ZEND     ; END to NEW ?
1188+  0B70 D2 29 07            JP      NC,SNERR        ; Not a key word - ?SN Error
1189+  0B73 07                  RLCA                    ; Double it
1190+  0B74 4F                  LD      C,A             ; BC = Offset into table
1191+  0B75 06 00               LD      B,0
1192+  0B77 EB                  EX      DE,HL           ; Save code string address
1193+  0B78 21 D1 05            LD      HL,WORDTB       ; Keyword address table
1194+  0B7B 09                  ADD     HL,BC           ; Point to routine address
1195+  0B7C 4E                  LD      C,(HL)          ; Get LSB of routine address
1196+  0B7D 23                  INC     HL
1197+  0B7E 46                  LD      B,(HL)          ; Get MSB of routine address
1198+  0B7F C5                  PUSH    BC              ; Save routine address
1199+  0B80 EB                  EX      DE,HL           ; Restore code string address
1200+  0B81             
1201+  0B81 23          GETCHR: INC     HL              ; Point to next character
1202+  0B82 7E                  LD      A,(HL)          ; Get next code string byte
1203+  0B83 FE 3A               CP      ':'             ; Z if ':'
1204+  0B85 D0                  RET     NC              ; NC if > "9"
1205+  0B86 FE 20               CP      ' '
1206+  0B88 CA 81 0B            JP      Z,GETCHR        ; Skip over spaces
1207+  0B8B FE 30               CP      '0'
1208+  0B8D 3F                  CCF                     ; NC if < '0'
1209+  0B8E 3C                  INC     A               ; Test for zero - Leave carry
1210+  0B8F 3D                  DEC     A               ; Z if Null
1211+  0B90 C9                  RET
1212+  0B91             
1213+  0B91 EB          RESTOR: EX      DE,HL           ; Save code string address
1214+  0B92 2A 0E 31            LD      HL,(BASTXT)     ; Point to start of program
1215+  0B95 CA A6 0B            JP      Z,RESTNL        ; Just RESTORE - reset pointer
1216+  0B98 EB                  EX      DE,HL           ; Restore code string address
1217+  0B99 CD 4D 0C            CALL    ATOH            ; Get line number to DE
1218+  0B9C E5                  PUSH    HL              ; Save code string address
1219+  0B9D CD 15 08            CALL    SRCHLN          ; Search for line number in DE
1220+  0BA0 60                  LD      H,B             ; HL = Address of line
1221+  0BA1 69                  LD      L,C
1222+  0BA2 D1                  POP     DE              ; Restore code string address
1223+  0BA3 D2 EE 0C            JP      NC,ULERR        ; ?UL Error if not found
1224+  0BA6 2B          RESTNL: DEC     HL              ; Byte before DATA statement
1225+  0BA7 22 8C 31    UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1226+  0BAA EB                  EX      DE,HL           ; Restore code string address
1227+  0BAB C9                  RET
1228+  0BAC             
1229+  0BAC             
1230+  0BAC DF          TSTBRK: RST     18H             ; Check input status
1231+  0BAD C8                  RET     Z               ; No key, go back
1232+  0BAE D7                  RST     10H             ; Get the key into A
1233+  0BAF FE 1B               CP      ESC             ; Escape key?
1234+  0BB1 28 11               JR      Z,BRK           ; Yes, break
1235+  0BB3 FE 03               CP      CTRLC           ; <Ctrl-C>
1236+  0BB5 28 0D               JR      Z,BRK           ; Yes, break
1237+  0BB7 FE 13               CP      CTRLS           ; Stop scrolling?
1238+  0BB9 C0                  RET     NZ              ; Other key, ignore
1239+  0BBA             
1240+  0BBA             
1241+  0BBA D7          STALL:  RST     10H             ; Wait for key
1242+  0BBB FE 11               CP      CTRLQ           ; Resume scrolling?
1243+  0BBD C8                  RET      Z              ; Release the chokehold
1244+  0BBE FE 03               CP      CTRLC           ; Second break?
1245+  0BC0 28 07               JR      Z,STOP          ; Break during hold exits prog
1246+  0BC2 18 F6               JR      STALL           ; Loop until <Ctrl-Q> or <brk>
1247+  0BC4             
1248+  0BC4 3E FF       BRK     LD      A,$FF           ; Set BRKFLG
1249+  0BC6 32 FD 30            LD      (BRKFLG),A      ; Store it
1250+  0BC9             
1251+  0BC9             
1252+  0BC9 C0          STOP:   RET     NZ              ; Exit if anything else
1253+  0BCA F6                  .BYTE   0F6H            ; Flag "STOP"
1254+  0BCB C0          PEND:   RET     NZ              ; Exit if anything else
1255+  0BCC 22 7E 31            LD      (BRKLIN),HL     ; Save point of break
1256+  0BCF 21                  .BYTE   21H             ; Skip "OR 11111111B"
1257+  0BD0 F6 FF       INPBRK: OR      11111111B       ; Flag "Break" wanted
1258+  0BD2 C1                  POP     BC              ; Return not needed and more
1259+  0BD3 2A 0C 31    ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1260+  0BD6 F5                  PUSH    AF              ; Save STOP / END status
1261+  0BD7 7D                  LD      A,L             ; Is it direct break?
1262+  0BD8 A4                  AND     H
1263+  0BD9 3C                  INC     A               ; Line is -1 if direct break
1264+  0BDA CA E6 0B            JP      Z,NOLIN         ; Yes - No line number
1265+  0BDD 22 82 31            LD      (ERRLIN),HL     ; Save line of break
1266+  0BE0 2A 7E 31            LD      HL,(BRKLIN)     ; Get point of break
1267+  0BE3 22 84 31            LD      (CONTAD),HL     ; Save point to CONTinue
1268+  0BE6 AF          NOLIN:  XOR     A
1269+  0BE7 32 F5 30            LD      (CTLOFG),A      ; Enable output
1270+  0BEA CD 1C 0E            CALL    STTLIN          ; Start a new line
1271+  0BED F1                  POP     AF              ; Restore STOP / END status
1272+  0BEE 21 CC 06            LD      HL,BRKMSG       ; "Break" message
1273+  0BF1 C2 5D 07            JP      NZ,ERRIN        ; "in line" wanted?
1274+  0BF4 C3 74 07            JP      PRNTOK          ; Go to command mode
1275+  0BF7             
1276+  0BF7 2A 84 31    CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1277+  0BFA 7C                  LD      A,H             ; Is it zero?
1278+  0BFB B5                  OR      L
1279+  0BFC 1E 20               LD      E,CN            ; ?CN Error
1280+  0BFE CA 3D 07            JP      Z,ERROR         ; Yes - output "?CN Error"
1281+  0C01 EB                  EX      DE,HL           ; Save code string address
1282+  0C02 2A 82 31            LD      HL,(ERRLIN)     ; Get line of last break
1283+  0C05 22 0C 31            LD      (LINEAT),HL     ; Set up current line number
1284+  0C08 EB                  EX      DE,HL           ; Restore code string address
1285+  0C09 C9                  RET                     ; CONTinue where left off
1286+  0C0A             
1287+  0C0A CD 4F 17    NULL:   CALL    GETINT          ; Get integer 0-255
1288+  0C0D C0                  RET     NZ              ; Return if bad value
1289+  0C0E 32 F1 30            LD      (NULLS),A       ; Set nulls number
1290+  0C11 C9                  RET
1291+  0C12             
1292+  0C12             
1293+  0C12 E5          ACCSUM: PUSH    HL              ; Save address in array
1294+  0C13 2A FA 30            LD      HL,(CHKSUM)     ; Get check sum
1295+  0C16 06 00               LD      B,0             ; BC - Value of byte
1296+  0C18 4F                  LD      C,A
1297+  0C19 09                  ADD     HL,BC           ; Add byte to check sum
1298+  0C1A 22 FA 30            LD      (CHKSUM),HL     ; Re-save check sum
1299+  0C1D E1                  POP     HL              ; Restore address in array
1300+  0C1E C9                  RET
1301+  0C1F             
1302+  0C1F 7E          CHKLTR: LD      A,(HL)          ; Get byte
1303+  0C20 FE 41               CP      'A'             ; < 'a' ?
1304+  0C22 D8                  RET     C               ; Carry set if not letter
1305+  0C23 FE 5B               CP      'Z'+1           ; > 'z' ?
1306+  0C25 3F                  CCF
1307+  0C26 C9                  RET                     ; Carry set if not letter
1308+  0C27             
1309+  0C27 CD 81 0B    FPSINT: CALL    GETCHR          ; Get next character
1310+  0C2A CD EE 0F    POSINT: CALL    GETNUM          ; Get integer 0 to 32767
1311+  0C2D CD D0 19    DEPINT: CALL    TSTSGN          ; Test sign of FPREG
1312+  0C30 FA 48 0C            JP      M,FCERR         ; Negative - ?FC Error
1313+  0C33 3A 97 31    DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
1314+  0C36 FE 90               CP      80H+16          ; Exponent in range (16 bits)?
1315+  0C38 DA 78 1A            JP      C,FPINT         ; Yes - convert it
1316+  0C3B 01 80 90            LD      BC,9080H        ; BCDE = -32768
1317+  0C3E 11 00 00            LD      DE,0000
1318+  0C41 E5                  PUSH    HL              ; Save code string address
1319+  0C42 CD 4B 1A            CALL    CMPNUM          ; Compare FPREG with BCDE
1320+  0C45 E1                  POP     HL              ; Restore code string address
1321+  0C46 51                  LD      D,C             ; MSB to D
1322+  0C47 C8                  RET     Z               ; Return if in range
1323+  0C48 1E 08       FCERR:  LD      E,FC            ; ?FC Error
1324+  0C4A C3 3D 07            JP      ERROR           ; Output error-
1325+  0C4D             
1326+  0C4D 2B          ATOH:   DEC     HL              ; ASCII number to DE binary
1327+  0C4E 11 00 00    GETLN:  LD      DE,0            ; Get number to DE
1328+  0C51 CD 81 0B    GTLNLP: CALL    GETCHR          ; Get next character
1329+  0C54 D0                  RET     NC              ; Exit if not a digit
1330+  0C55 E5                  PUSH    HL              ; Save code string address
1331+  0C56 F5                  PUSH    AF              ; Save digit
1332+  0C57 21 98 19            LD      HL,65529/10     ; Largest number 65529
1333+  0C5A CD F1 09            CALL    CPDEHL          ; Number in range?
1334+  0C5D DA 29 07            JP      C,SNERR         ; No - ?SN Error
1335+  0C60 62                  LD      H,D             ; HL = Number
1336+  0C61 6B                  LD      L,E
1337+  0C62 19                  ADD     HL,DE           ; Times 2
1338+  0C63 29                  ADD     HL,HL           ; Times 4
1339+  0C64 19                  ADD     HL,DE           ; Times 5
1340+  0C65 29                  ADD     HL,HL           ; Times 10
1341+  0C66 F1                  POP     AF              ; Restore digit
1342+  0C67 D6 30               SUB     '0'             ; Make it 0 to 9
1343+  0C69 5F                  LD      E,A             ; DE = Value of digit
1344+  0C6A 16 00               LD      D,0
1345+  0C6C 19                  ADD     HL,DE           ; Add to number
1346+  0C6D EB                  EX      DE,HL           ; Number to DE
1347+  0C6E E1                  POP     HL              ; Restore code string address
1348+  0C6F C3 51 0C            JP      GTLNLP          ; Go to next character
1349+  0C72             
1350+  0C72 CA 45 08    CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
1351+  0C75 CD 2A 0C            CALL    POSINT          ; Get integer 0 to 32767 to DE
1352+  0C78 2B                  DEC     HL              ; Cancel increment
1353+  0C79 CD 81 0B            CALL    GETCHR          ; Get next character
1354+  0C7C E5                  PUSH    HL              ; Save code string address
1355+  0C7D 2A 5F 31            LD      HL,(LSTRAM)     ; Get end of RAM
1356+  0C80 CA 95 0C            JP      Z,STORED        ; No value given - Use stored
1357+  0C83 E1                  POP     HL              ; Restore code string address
1358+  0C84 CD F7 09            CALL    CHKSYN          ; Check for comma
1359+  0C87 2C                  .BYTE      ','
1360+  0C88 D5                  PUSH    DE              ; Save number
1361+  0C89 CD 2A 0C            CALL    POSINT          ; Get integer 0 to 32767
1362+  0C8C 2B                  DEC     HL              ; Cancel increment
1363+  0C8D CD 81 0B            CALL    GETCHR          ; Get next character
1364+  0C90 C2 29 07            JP      NZ,SNERR        ; ?SN Error if more on line
1365+  0C93 E3                  EX      (SP),HL         ; Save code string address
1366+  0C94 EB                  EX      DE,HL           ; Number to DE
1367+  0C95 7D          STORED: LD      A,L             ; Get LSB of new RAM top
1368+  0C96 93                  SUB     E               ; Subtract LSB of string space
1369+  0C97 5F                  LD      E,A             ; Save LSB
1370+  0C98 7C                  LD      A,H             ; Get MSB of new RAM top
1371+  0C99 9A                  SBC     A,D             ; Subtract MSB of string space
1372+  0C9A 57                  LD      D,A             ; Save MSB
1373+  0C9B DA 1E 07            JP      C,OMERR         ; ?OM Error if not enough mem
1374+  0C9E E5                  PUSH    HL              ; Save RAM top
1375+  0C9F 2A 86 31            LD      HL,(PROGND)     ; Get program end
1376+  0CA2 01 28 00            LD      BC,40           ; 40 Bytes minimum working RAM
1377+  0CA5 09                  ADD     HL,BC           ; Get lowest address
1378+  0CA6 CD F1 09            CALL    CPDEHL          ; Enough memory?
1379+  0CA9 D2 1E 07            JP      NC,OMERR        ; No - ?OM Error
1380+  0CAC EB                  EX      DE,HL           ; RAM top to HL
1381+  0CAD 22 0A 31            LD      (STRSPC),HL     ; Set new string space
1382+  0CB0 E1                  POP     HL              ; End of memory to use
1383+  0CB1 22 5F 31            LD      (LSTRAM),HL     ; Set new top of RAM
1384+  0CB4 E1                  POP     HL              ; Restore code string address
1385+  0CB5 C3 45 08            JP      INTVAR          ; Initialise variables
1386+  0CB8             
1387+  0CB8 CA 41 08    RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
1388+  0CBB CD 45 08            CALL    INTVAR          ; Initialise variables
1389+  0CBE 01 41 0B            LD      BC,RUNCNT       ; Execution driver loop
1390+  0CC1 C3 D4 0C            JP      RUNLIN          ; RUN from line number
1391+  0CC4             
1392+  0CC4 0E 03       GOSUB:  LD      C,3             ; 3 Levels of stack needed
1393+  0CC6 CD 06 07            CALL    CHKSTK          ; Check for 3 levels of stack
1394+  0CC9 C1                  POP     BC              ; Get return address
1395+  0CCA E5                  PUSH    HL              ; Save code string for RETURN
1396+  0CCB E5                  PUSH    HL              ; And for GOSUB routine
1397+  0CCC 2A 0C 31            LD      HL,(LINEAT)     ; Get current line
1398+  0CCF E3                  EX      (SP),HL         ; Into stack - Code string out
1399+  0CD0 3E 8C               LD      A,ZGOSUB        ; "GOSUB" token
1400+  0CD2 F5                  PUSH    AF              ; Save token
1401+  0CD3 33                  INC     SP              ; Don't save flags
1402+  0CD4             
1403+  0CD4 C5          RUNLIN: PUSH    BC              ; Save return address
1404+  0CD5 CD 4D 0C    GOTO:   CALL    ATOH            ; ASCII number to DE binary
1405+  0CD8 CD 1A 0D            CALL    REM             ; Get end of line
1406+  0CDB E5                  PUSH    HL              ; Save end of line
1407+  0CDC 2A 0C 31            LD      HL,(LINEAT)     ; Get current line
1408+  0CDF CD F1 09            CALL    CPDEHL          ; Line after current?
1409+  0CE2 E1                  POP     HL              ; Restore end of line
1410+  0CE3 23                  INC     HL              ; Start of next line
1411+  0CE4 DC 18 08            CALL    C,SRCHLP        ; Line is after current line
1412+  0CE7 D4 15 08            CALL    NC,SRCHLN       ; Line is before current line
1413+  0CEA 60                  LD      H,B             ; Set up code string address
1414+  0CEB 69                  LD      L,C
1415+  0CEC 2B                  DEC     HL              ; Incremented after
1416+  0CED D8                  RET     C               ; Line found
1417+  0CEE 1E 0E       ULERR:  LD      E,UL            ; ?UL Error
1418+  0CF0 C3 3D 07            JP      ERROR           ; Output error message
1419+  0CF3             
1420+  0CF3 C0          RETURN: RET     NZ              ; Return if not just RETURN
1421+  0CF4 16 FF               LD      D,-1            ; Flag "GOSUB" search
1422+  0CF6 CD D2 06            CALL    BAKSTK          ; Look "GOSUB" block
1423+  0CF9 F9                  LD      SP,HL           ; Kill all FORs in subroutine
1424+  0CFA FE 8C               CP      ZGOSUB          ; Test for "GOSUB" token
1425+  0CFC 1E 04               LD      E,RG            ; ?RG Error
1426+  0CFE C2 3D 07            JP      NZ,ERROR        ; Error if no "GOSUB" found
1427+  0D01 E1                  POP     HL              ; Get RETURN line number
1428+  0D02 22 0C 31            LD      (LINEAT),HL     ; Save as current
1429+  0D05 23                  INC     HL              ; Was it from direct statement?
1430+  0D06 7C                  LD      A,H
1431+  0D07 B5                  OR      L               ; Return to line
1432+  0D08 C2 12 0D            JP      NZ,RETLIN       ; No - Return to line
1433+  0D0B 3A 7C 31            LD      A,(LSTBIN)      ; Any INPUT in subroutine?
1434+  0D0E B7                  OR      A               ; If so buffer is corrupted
1435+  0D0F C2 73 07            JP      NZ,POPNOK       ; Yes - Go to command mode
1436+  0D12 21 41 0B    RETLIN: LD      HL,RUNCNT       ; Execution driver loop
1437+  0D15 E3                  EX      (SP),HL         ; Into stack - Code string out
1438+  0D16 3E                  .BYTE      3EH             ; Skip "POP HL"
1439+  0D17 E1          NXTDTA: POP     HL              ; Restore code string address
1440+  0D18             
1441+  0D18 01 3A       DATA:   .BYTE      01H,3AH         ; ':' End of statement
1442+  0D1A 0E 00       REM:    LD      C,0             ; 00  End of statement
1443+  0D1C 06 00               LD      B,0
1444+  0D1E 79          NXTSTL: LD      A,C             ; Statement and byte
1445+  0D1F 48                  LD      C,B
1446+  0D20 47                  LD      B,A             ; Statement end byte
1447+  0D21 7E          NXTSTT: LD      A,(HL)          ; Get byte
1448+  0D22 B7                  OR      A               ; End of line?
1449+  0D23 C8                  RET     Z               ; Yes - Exit
1450+  0D24 B8                  CP      B               ; End of statement?
1451+  0D25 C8                  RET     Z               ; Yes - Exit
1452+  0D26 23                  INC     HL              ; Next byte
1453+  0D27 FE 22               CP      '"'             ; Literal string?
1454+  0D29 CA 1E 0D            JP      Z,NXTSTL        ; Yes - Look for another '"'
1455+  0D2C C3 21 0D            JP      NXTSTT          ; Keep looking
1456+  0D2F             
1457+  0D2F CD E4 11    LET:    CALL    GETVAR          ; Get variable name
1458+  0D32 CD F7 09            CALL    CHKSYN          ; Make sure "=" follows
1459+  0D35 B4                  .BYTE      ZEQUAL          ; "=" token
1460+  0D36 D5                  PUSH    DE              ; Save address of variable
1461+  0D37 3A 5D 31            LD      A,(TYPE)        ; Get data type
1462+  0D3A F5                  PUSH    AF              ; Save type
1463+  0D3B CD 00 10            CALL    EVAL            ; Evaluate expression
1464+  0D3E F1                  POP     AF              ; Restore type
1465+  0D3F E3                  EX      (SP),HL         ; Save code - Get var addr
1466+  0D40 22 7E 31            LD      (BRKLIN),HL     ; Save address of variable
1467+  0D43 1F                  RRA                     ; Adjust type
1468+  0D44 CD F3 0F            CALL    CHKTYP          ; Check types are the same
1469+  0D47 CA 82 0D            JP      Z,LETNUM        ; Numeric - Move value
1470+  0D4A E5          LETSTR: PUSH    HL              ; Save address of string var
1471+  0D4B 2A 94 31            LD      HL,(FPREG)      ; Pointer to string entry
1472+  0D4E E5                  PUSH    HL              ; Save it on stack
1473+  0D4F 23                  INC     HL              ; Skip over length
1474+  0D50 23                  INC     HL
1475+  0D51 5E                  LD      E,(HL)          ; LSB of string address
1476+  0D52 23                  INC     HL
1477+  0D53 56                  LD      D,(HL)          ; MSB of string address
1478+  0D54 2A 0E 31            LD      HL,(BASTXT)     ; Point to start of program
1479+  0D57 CD F1 09            CALL    CPDEHL          ; Is string before program?
1480+  0D5A D2 71 0D            JP      NC,CRESTR       ; Yes - Create string entry
1481+  0D5D 2A 0A 31            LD      HL,(STRSPC)     ; Point to string space
1482+  0D60 CD F1 09            CALL    CPDEHL          ; Is string literal in program?
1483+  0D63 D1                  POP     DE              ; Restore address of string
1484+  0D64 D2 79 0D            JP      NC,MVSTPT       ; Yes - Set up pointer
1485+  0D67 21 6F 31            LD      HL,TMPSTR       ; Temporary string pool
1486+  0D6A CD F1 09            CALL    CPDEHL          ; Is string in temporary pool?
1487+  0D6D D2 79 0D            JP      NC,MVSTPT       ; No - Set up pointer
1488+  0D70 3E                  .BYTE   3EH             ; Skip "POP DE"
1489+  0D71 D1          CRESTR: POP     DE              ; Restore address of string
1490+  0D72 CD 28 16            CALL    BAKTMP          ; Back to last tmp-str entry
1491+  0D75 EB                  EX      DE,HL           ; Address of string entry
1492+  0D76 CD 61 14            CALL    SAVSTR          ; Save string in string area
1493+  0D79 CD 28 16    MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
1494+  0D7C E1                  POP     HL              ; Get string pointer
1495+  0D7D CD 2B 1A            CALL    DETHL4          ; Move string pointer to var
1496+  0D80 E1                  POP     HL              ; Restore code string address
1497+  0D81 C9                  RET
1498+  0D82             
1499+  0D82 E5          LETNUM: PUSH    HL              ; Save address of variable
1500+  0D83 CD 28 1A            CALL    FPTHL           ; Move value to variable
1501+  0D86 D1                  POP     DE              ; Restore address of variable
1502+  0D87 E1                  POP     HL              ; Restore code string address
1503+  0D88 C9                  RET
1504+  0D89             
1505+  0D89 CD 4F 17    ON:     CALL    GETINT          ; Get integer 0-255
1506+  0D8C 7E                  LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
1507+  0D8D 47                  LD      B,A             ; Save in B
1508+  0D8E FE 8C               CP      ZGOSUB          ; "GOSUB" token?
1509+  0D90 CA 98 0D            JP      Z,ONGO          ; Yes - Find line number
1510+  0D93 CD F7 09            CALL    CHKSYN          ; Make sure it's "GOTO"
1511+  0D96 88                  .BYTE   ZGOTO           ; "GOTO" token
1512+  0D97 2B                  DEC     HL              ; Cancel increment
1513+  0D98 4B          ONGO:   LD      C,E             ; Integer of branch value
1514+  0D99 0D          ONGOLP: DEC     C               ; Count branches
1515+  0D9A 78                  LD      A,B             ; Get "GOTO" or "GOSUB" token
1516+  0D9B CA 69 0B            JP      Z,ONJMP         ; Go to that line if right one
1517+  0D9E CD 4E 0C            CALL    GETLN           ; Get line number to DE
1518+  0DA1 FE 2C               CP      ','             ; Another line number?
1519+  0DA3 C0                  RET     NZ              ; No - Drop through
1520+  0DA4 C3 99 0D            JP      ONGOLP          ; Yes - loop
1521+  0DA7             
1522+  0DA7 CD 00 10    IF:     CALL    EVAL            ; Evaluate expression
1523+  0DAA 7E                  LD      A,(HL)          ; Get token
1524+  0DAB FE 88               CP      ZGOTO           ; "GOTO" token?
1525+  0DAD CA B5 0D            JP      Z,IFGO          ; Yes - Get line
1526+  0DB0 CD F7 09            CALL    CHKSYN          ; Make sure it's "THEN"
1527+  0DB3 A9                  .BYTE      ZTHEN           ; "THEN" token
1528+  0DB4 2B                  DEC     HL              ; Cancel increment
1529+  0DB5 CD F1 0F    IFGO:   CALL    TSTNUM          ; Make sure it's numeric
1530+  0DB8 CD D0 19            CALL    TSTSGN          ; Test state of expression
1531+  0DBB CA 1A 0D            JP      Z,REM           ; False - Drop through
1532+  0DBE CD 81 0B            CALL    GETCHR          ; Get next character
1533+  0DC1 DA D5 0C            JP      C,GOTO          ; Number - GOTO that line
1534+  0DC4 C3 68 0B            JP      IFJMP           ; Otherwise do statement
1535+  0DC7             
1536+  0DC7 2B          MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
1537+  0DC8 CD 81 0B            CALL    GETCHR          ; Get next character
1538+  0DCB CA 29 0E    PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
1539+  0DCE C8          PRNTLP: RET     Z               ; End of list - Exit
1540+  0DCF FE A5               CP      ZTAB            ; "TAB(" token?
1541+  0DD1 CA 5C 0E            JP      Z,DOTAB         ; Yes - Do TAB routine
1542+  0DD4 FE A8               CP      ZSPC            ; "SPC(" token?
1543+  0DD6 CA 5C 0E            JP      Z,DOTAB         ; Yes - Do SPC routine
1544+  0DD9 E5                  PUSH    HL              ; Save code string address
1545+  0DDA FE 2C               CP      ','             ; Comma?
1546+  0DDC CA 45 0E            JP      Z,DOCOM         ; Yes - Move to next zone
1547+  0DDF FE 3B               CP      59 ;";"         ; Semi-colon?
1548+  0DE1 CA 7F 0E            JP      Z,NEXITM        ; Do semi-colon routine
1549+  0DE4 C1                  POP     BC              ; Code string address to BC
1550+  0DE5 CD 00 10            CALL    EVAL            ; Evaluate expression
1551+  0DE8 E5                  PUSH    HL              ; Save code string address
1552+  0DE9 3A 5D 31            LD      A,(TYPE)        ; Get variable type
1553+  0DEC B7                  OR      A               ; Is it a string variable?
1554+  0DED C2 15 0E            JP      NZ,PRNTST       ; Yes - Output string contents
1555+  0DF0 CD 75 1B            CALL    NUMASC          ; Convert number to text
1556+  0DF3 CD 85 14            CALL    CRTST           ; Create temporary string
1557+  0DF6 36 20               LD      (HL),' '        ; Followed by a space
1558+  0DF8 2A 94 31            LD      HL,(FPREG)      ; Get length of output
1559+  0DFB 34                  INC     (HL)            ; Plus 1 for the space
1560+  0DFC 2A 94 31            LD      HL,(FPREG)      ; < Not needed >
1561+  0DFF 3A F2 30            LD      A,(LWIDTH)      ; Get width of line
1562+  0E02 47                  LD      B,A             ; To B
1563+  0E03 04                  INC     B               ; Width 255 (No limit)?
1564+  0E04 CA 11 0E            JP      Z,PRNTNB        ; Yes - Output number string
1565+  0E07 04                  INC     B               ; Adjust it
1566+  0E08 3A 5B 31            LD      A,(CURPOS)      ; Get cursor position
1567+  0E0B 86                  ADD     A,(HL)          ; Add length of string
1568+  0E0C 3D                  DEC     A               ; Adjust it
1569+  0E0D B8                  CP      B               ; Will output fit on this line?
1570+  0E0E D4 29 0E            CALL    NC,PRNTCRLF     ; No - CRLF first
1571+  0E11 CD CA 14    PRNTNB: CALL    PRS1            ; Output string at (HL)
1572+  0E14 AF                  XOR     A               ; Skip CALL by setting 'z' flag
1573+  0E15 C4 CA 14    PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
1574+  0E18 E1                  POP     HL              ; Restore code string address
1575+  0E19 C3 C7 0D            JP      MRPRNT          ; See if more to PRINT
1576+  0E1C             
1577+  0E1C 3A 5B 31    STTLIN: LD      A,(CURPOS)      ; Make sure on new line
1578+  0E1F B7                  OR      A               ; Already at start?
1579+  0E20 C8                  RET     Z               ; Yes - Do nothing
1580+  0E21 C3 29 0E            JP      PRNTCRLF        ; Start a new line
1581+  0E24             
1582+  0E24 36 00       ENDINP: LD      (HL),0          ; Mark end of buffer
1583+  0E26 21 10 31            LD      HL,BUFFER-1     ; Point to buffer
1584+  0E29 3E 0D       PRNTCRLF: LD    A,CR            ; Load a CR
1585+  0E2B CD 02 0A            CALL    OUTC            ; Output character
1586+  0E2E 3E 0A               LD      A,LF            ; Load a LF
1587+  0E30 CD 02 0A            CALL    OUTC            ; Output character
1588+  0E33 AF          DONULL: XOR     A               ; Set to position 0
1589+  0E34 32 5B 31            LD      (CURPOS),A      ; Store it
1590+  0E37 3A F1 30            LD      A,(NULLS)       ; Get number of nulls
1591+  0E3A 3D          NULLP:  DEC     A               ; Count them
1592+  0E3B C8                  RET     Z               ; Return if done
1593+  0E3C F5                  PUSH    AF              ; Save count
1594+  0E3D AF                  XOR     A               ; Load a null
1595+  0E3E CD 02 0A            CALL    OUTC            ; Output it
1596+  0E41 F1                  POP     AF              ; Restore count
1597+  0E42 C3 3A 0E            JP      NULLP           ; Keep counting
1598+  0E45             
1599+  0E45 3A F3 30    DOCOM:  LD      A,(COMMAN)      ; Get comma width
1600+  0E48 47                  LD      B,A             ; Save in B
1601+  0E49 3A 5B 31            LD      A,(CURPOS)      ; Get current position
1602+  0E4C B8                  CP      B               ; Within the limit?
1603+  0E4D D4 29 0E            CALL    NC,PRNTCRLF     ; No - output CRLF
1604+  0E50 D2 7F 0E            JP      NC,NEXITM       ; Get next item
1605+  0E53 D6 0E       ZONELP: SUB     14              ; Next zone of 14 characters
1606+  0E55 D2 53 0E            JP      NC,ZONELP       ; Repeat if more zones
1607+  0E58 2F                  CPL                     ; Number of spaces to output
1608+  0E59 C3 74 0E            JP      ASPCS           ; Output them
1609+  0E5C             
1610+  0E5C F5          DOTAB:  PUSH    AF              ; Save token
1611+  0E5D CD 4C 17            CALL    FNDNUM          ; Evaluate expression
1612+  0E60 CD F7 09            CALL    CHKSYN          ; Make sure ")" follows
1613+  0E63 29                  .BYTE   ")"
1614+  0E64 2B                  DEC     HL              ; Back space on to ")"
1615+  0E65 F1                  POP     AF              ; Restore token
1616+  0E66 D6 A8               SUB     ZSPC            ; Was it "SPC(" ?
1617+  0E68 E5                  PUSH    HL              ; Save code string address
1618+  0E69 CA 6F 0E            JP      Z,DOSPC         ; Yes - Do 'E' spaces
1619+  0E6C 3A 5B 31            LD      A,(CURPOS)      ; Get current position
1620+  0E6F 2F          DOSPC:  CPL                     ; Number of spaces to print to
1621+  0E70 83                  ADD     A,E             ; Total number to print
1622+  0E71 D2 7F 0E            JP      NC,NEXITM       ; TAB < Current POS(X)
1623+  0E74 3C          ASPCS:  INC     A               ; Output A spaces
1624+  0E75 47                  LD      B,A             ; Save number to print
1625+  0E76 3E 20               LD      A,' '           ; Space
1626+  0E78 CD 02 0A    SPCLP:  CALL    OUTC            ; Output character in A
1627+  0E7B 05                  DEC     B               ; Count them
1628+  0E7C C2 78 0E            JP      NZ,SPCLP        ; Repeat if more
1629+  0E7F E1          NEXITM: POP     HL              ; Restore code string address
1630+  0E80 CD 81 0B            CALL    GETCHR          ; Get next character
1631+  0E83 C3 CE 0D            JP      PRNTLP          ; More to print
1632+  0E86             
1633+  0E86 3F 52 65 64 REDO:   .BYTE   "?Redo from start",CR,LF,0
1633+  0E8A 6F 20 66 72 
1633+  0E8E 6F 6D 20 73 
1633+  0E92 74 61 72 74 
1633+  0E96 0D 0A 00 
1634+  0E99             
1635+  0E99 3A 7D 31    BADINP: LD      A,(READFG)      ; READ or INPUT?
1636+  0E9C B7                  OR      A
1637+  0E9D C2 23 07            JP      NZ,DATSNR       ; READ - ?SN Error
1638+  0EA0 C1                  POP     BC              ; Throw away code string addr
1639+  0EA1 21 86 0E            LD      HL,REDO         ; "Redo from start" message
1640+  0EA4 CD C7 14            CALL    PRS             ; Output string
1641+  0EA7 C3 74 08            JP      DOAGN           ; Do last INPUT again
1642+  0EAA             
1643+  0EAA CD 32 14    INPUT:  CALL    IDTEST          ; Test for illegal direct
1644+  0EAD 7E                  LD      A,(HL)          ; Get character after "INPUT"
1645+  0EAE FE 22               CP      '"'             ; Is there a prompt string?
1646+  0EB0 3E 00               LD      A,0             ; Clear A and leave flags
1647+  0EB2 32 F5 30            LD      (CTLOFG),A      ; Enable output
1648+  0EB5 C2 C4 0E            JP      NZ,NOPMPT       ; No prompt - get input
1649+  0EB8 CD 86 14            CALL    QTSTR           ; Get string terminated by '"'
1650+  0EBB CD F7 09            CALL    CHKSYN          ; Check for ';' after prompt
1651+  0EBE 3B                  .BYTE   ';'
1652+  0EBF E5                  PUSH    HL              ; Save code string address
1653+  0EC0 CD CA 14            CALL    PRS1            ; Output prompt string
1654+  0EC3 3E                  .BYTE   3EH             ; Skip "PUSH HL"
1655+  0EC4 E5          NOPMPT: PUSH    HL              ; Save code string address
1656+  0EC5 CD 78 08            CALL    PROMPT          ; Get input with "? " prompt
1657+  0EC8 C1                  POP     BC              ; Restore code string address
1658+  0EC9 DA D0 0B            JP      C,INPBRK        ; Break pressed - Exit
1659+  0ECC 23                  INC     HL              ; Next byte
1660+  0ECD 7E                  LD      A,(HL)          ; Get it
1661+  0ECE B7                  OR      A               ; End of line?
1662+  0ECF 2B                  DEC     HL              ; Back again
1663+  0ED0 C5                  PUSH    BC              ; Re-save code string address
1664+  0ED1 CA 17 0D            JP      Z,NXTDTA        ; Yes - Find next DATA stmt
1665+  0ED4 36 2C               LD      (HL),','        ; Store comma as separator
1666+  0ED6 C3 DE 0E            JP      NXTITM          ; Get next item
1667+  0ED9             
1668+  0ED9 E5          READ:   PUSH    HL              ; Save code string address
1669+  0EDA 2A 8C 31            LD      HL,(NXTDAT)     ; Next DATA statement
1670+  0EDD F6                  .BYTE   0F6H            ; Flag "READ"
1671+  0EDE AF          NXTITM: XOR     A               ; Flag "INPUT"
1672+  0EDF 32 7D 31            LD      (READFG),A      ; Save "READ"/"INPUT" flag
1673+  0EE2 E3                  EX      (SP),HL         ; Get code str' , Save pointer
1674+  0EE3 C3 EA 0E            JP      GTVLUS          ; Get values
1675+  0EE6             
1676+  0EE6 CD F7 09    NEDMOR: CALL    CHKSYN          ; Check for comma between items
1677+  0EE9 2C                  .BYTE      ','
1678+  0EEA CD E4 11    GTVLUS: CALL    GETVAR          ; Get variable name
1679+  0EED E3                  EX      (SP),HL         ; Save code str" , Get pointer
1680+  0EEE D5                  PUSH    DE              ; Save variable address
1681+  0EEF 7E                  LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
1682+  0EF0 FE 2C               CP      ','             ; Comma?
1683+  0EF2 CA 12 0F            JP      Z,ANTVLU        ; Yes - Get another value
1684+  0EF5 3A 7D 31            LD      A,(READFG)      ; Is it READ?
1685+  0EF8 B7                  OR      A
1686+  0EF9 C2 7F 0F            JP      NZ,FDTLP        ; Yes - Find next DATA stmt
1687+  0EFC 3E 3F               LD      A,'?'           ; More INPUT needed
1688+  0EFE CD 02 0A            CALL    OUTC            ; Output character
1689+  0F01 CD 78 08            CALL    PROMPT          ; Get INPUT with prompt
1690+  0F04 D1                  POP     DE              ; Variable address
1691+  0F05 C1                  POP     BC              ; Code string address
1692+  0F06 DA D0 0B            JP      C,INPBRK        ; Break pressed
1693+  0F09 23                  INC     HL              ; Point to next DATA byte
1694+  0F0A 7E                  LD      A,(HL)          ; Get byte
1695+  0F0B B7                  OR      A               ; Is it zero (No input) ?
1696+  0F0C 2B                  DEC     HL              ; Back space INPUT pointer
1697+  0F0D C5                  PUSH    BC              ; Save code string address
1698+  0F0E CA 17 0D            JP      Z,NXTDTA        ; Find end of buffer
1699+  0F11 D5                  PUSH    DE              ; Save variable address
1700+  0F12 3A 5D 31    ANTVLU: LD      A,(TYPE)        ; Check data type
1701+  0F15 B7                  OR      A               ; Is it numeric?
1702+  0F16 CA 3C 0F            JP      Z,INPBIN        ; Yes - Convert to binary
1703+  0F19 CD 81 0B            CALL    GETCHR          ; Get next character
1704+  0F1C 57                  LD      D,A             ; Save input character
1705+  0F1D 47                  LD      B,A             ; Again
1706+  0F1E FE 22               CP      '"'             ; Start of literal sting?
1707+  0F20 CA 30 0F            JP      Z,STRENT        ; Yes - Create string entry
1708+  0F23 3A 7D 31            LD      A,(READFG)      ; "READ" or "INPUT" ?
1709+  0F26 B7                  OR      A
1710+  0F27 57                  LD      D,A             ; Save 00 if "INPUT"
1711+  0F28 CA 2D 0F            JP      Z,ITMSEP        ; "INPUT" - End with 00
1712+  0F2B 16 3A               LD      D,':'           ; "DATA" - End with 00 or ':'
1713+  0F2D 06 2C       ITMSEP: LD      B,','           ; Item separator
1714+  0F2F 2B                  DEC     HL              ; Back space for DTSTR
1715+  0F30 CD 89 14    STRENT: CALL    DTSTR           ; Get string terminated by D
1716+  0F33 EB                  EX      DE,HL           ; String address to DE
1717+  0F34 21 47 0F            LD      HL,LTSTND       ; Where to go after LETSTR
1718+  0F37 E3                  EX      (SP),HL         ; Save HL , get input pointer
1719+  0F38 D5                  PUSH    DE              ; Save address of string
1720+  0F39 C3 4A 0D            JP      LETSTR          ; Assign string to variable
1721+  0F3C             
1722+  0F3C CD 81 0B    INPBIN: CALL    GETCHR          ; Get next character
1723+  0F3F CD D7 1A            CALL    ASCTFP          ; Convert ASCII to FP number
1724+  0F42 E3                  EX      (SP),HL         ; Save input ptr, Get var addr
1725+  0F43 CD 28 1A            CALL    FPTHL           ; Move FPREG to variable
1726+  0F46 E1                  POP     HL              ; Restore input pointer
1727+  0F47 2B          LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
1728+  0F48 CD 81 0B            CALL    GETCHR          ; Get next character
1729+  0F4B CA 53 0F            JP      Z,MORDT         ; End of line - More needed?
1730+  0F4E FE 2C               CP      ','             ; Another value?
1731+  0F50 C2 99 0E            JP      NZ,BADINP       ; No - Bad input
1732+  0F53 E3          MORDT:  EX      (SP),HL         ; Get code string address
1733+  0F54 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
1734+  0F55 CD 81 0B            CALL    GETCHR          ; Get next character
1735+  0F58 C2 E6 0E            JP      NZ,NEDMOR       ; More needed - Get it
1736+  0F5B D1                  POP     DE              ; Restore DATA pointer
1737+  0F5C 3A 7D 31            LD      A,(READFG)      ; "READ" or "INPUT" ?
1738+  0F5F B7                  OR      A
1739+  0F60 EB                  EX      DE,HL           ; DATA pointer to HL
1740+  0F61 C2 A7 0B            JP      NZ,UPDATA       ; Update DATA pointer if "READ"
1741+  0F64 D5                  PUSH    DE              ; Save code string address
1742+  0F65 B6                  OR      (HL)            ; More input given?
1743+  0F66 21 6E 0F            LD      HL,EXTIG        ; "?Extra ignored" message
1744+  0F69 C4 C7 14            CALL    NZ,PRS          ; Output string if extra given
1745+  0F6C E1                  POP     HL              ; Restore code string address
1746+  0F6D C9                  RET
1747+  0F6E             
1748+  0F6E 3F 45 78 74 EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
1748+  0F72 72 61 20 69 
1748+  0F76 67 6E 6F 72 
1748+  0F7A 65 64 0D 0A 
1748+  0F7E 00 
1749+  0F7F             
1750+  0F7F CD 18 0D    FDTLP:  CALL    DATA            ; Get next statement
1751+  0F82 B7                  OR      A               ; End of line?
1752+  0F83 C2 98 0F            JP      NZ,FANDT        ; No - See if DATA statement
1753+  0F86 23                  INC     HL
1754+  0F87 7E                  LD      A,(HL)          ; End of program?
1755+  0F88 23                  INC     HL
1756+  0F89 B6                  OR      (HL)            ; 00 00 Ends program
1757+  0F8A 1E 06               LD      E,OD            ; ?OD Error
1758+  0F8C CA 3D 07            JP      Z,ERROR         ; Yes - Out of DATA
1759+  0F8F 23                  INC     HL
1760+  0F90 5E                  LD      E,(HL)          ; LSB of line number
1761+  0F91 23                  INC     HL
1762+  0F92 56                  LD      D,(HL)          ; MSB of line number
1763+  0F93 EB                  EX      DE,HL
1764+  0F94 22 79 31            LD      (DATLIN),HL     ; Set line of current DATA item
1765+  0F97 EB                  EX      DE,HL
1766+  0F98 CD 81 0B    FANDT:  CALL    GETCHR          ; Get next character
1767+  0F9B FE 83               CP      ZDATA           ; "DATA" token
1768+  0F9D C2 7F 0F            JP      NZ,FDTLP        ; No "DATA" - Keep looking
1769+  0FA0 C3 12 0F            JP      ANTVLU          ; Found - Convert input
1770+  0FA3             
1771+  0FA3 11 00 00    NEXT:   LD      DE,0            ; In case no index given
1772+  0FA6 C4 E4 11    NEXT1:  CALL    NZ,GETVAR       ; Get index address
1773+  0FA9 22 7E 31            LD      (BRKLIN),HL     ; Save code string address
1774+  0FAC CD D2 06            CALL    BAKSTK          ; Look for "FOR" block
1775+  0FAF C2 2F 07            JP      NZ,NFERR        ; No "FOR" - ?NF Error
1776+  0FB2 F9                  LD      SP,HL           ; Clear nested loops
1777+  0FB3 D5                  PUSH    DE              ; Save index address
1778+  0FB4 7E                  LD      A,(HL)          ; Get sign of STEP
1779+  0FB5 23                  INC     HL
1780+  0FB6 F5                  PUSH    AF              ; Save sign of STEP
1781+  0FB7 D5                  PUSH    DE              ; Save index address
1782+  0FB8 CD 0E 1A            CALL    PHLTFP          ; Move index value to FPREG
1783+  0FBB E3                  EX      (SP),HL         ; Save address of TO value
1784+  0FBC E5                  PUSH    HL              ; Save address of index
1785+  0FBD CD 7B 17            CALL    ADDPHL          ; Add STEP to index value
1786+  0FC0 E1                  POP     HL              ; Restore address of index
1787+  0FC1 CD 28 1A            CALL    FPTHL           ; Move value to index variable
1788+  0FC4 E1                  POP     HL              ; Restore address of TO value
1789+  0FC5 CD 1F 1A            CALL    LOADFP          ; Move TO value to BCDE
1790+  0FC8 E5                  PUSH    HL              ; Save address of line of FOR
1791+  0FC9 CD 4B 1A            CALL    CMPNUM          ; Compare index with TO value
1792+  0FCC E1                  POP     HL              ; Restore address of line num
1793+  0FCD C1                  POP     BC              ; Address of sign of STEP
1794+  0FCE 90                  SUB     B               ; Compare with expected sign
1795+  0FCF CD 1F 1A            CALL    LOADFP          ; BC = Loop stmt,DE = Line num
1796+  0FD2 CA DE 0F            JP      Z,KILFOR        ; Loop finished - Terminate it
1797+  0FD5 EB                  EX      DE,HL           ; Loop statement line number
1798+  0FD6 22 0C 31            LD      (LINEAT),HL     ; Set loop line number
1799+  0FD9 69                  LD      L,C             ; Set code string to loop
1800+  0FDA 60                  LD      H,B
1801+  0FDB C3 3D 0B            JP      PUTFID          ; Put back "FOR" and continue
1802+  0FDE             
1803+  0FDE F9          KILFOR: LD      SP,HL           ; Remove "FOR" block
1804+  0FDF 2A 7E 31            LD      HL,(BRKLIN)     ; Code string after "NEXT"
1805+  0FE2 7E                  LD      A,(HL)          ; Get next byte in code string
1806+  0FE3 FE 2C               CP      ','             ; More NEXTs ?
1807+  0FE5 C2 41 0B            JP      NZ,RUNCNT       ; No - Do next statement
1808+  0FE8 CD 81 0B            CALL    GETCHR          ; Position to index name
1809+  0FEB CD A6 0F            CALL    NEXT1           ; Re-enter NEXT routine
1810+  0FEE             ; < will not RETurn to here , Exit to RUNCNT or Loop >
1811+  0FEE             
1812+  0FEE CD 00 10    GETNUM: CALL    EVAL            ; Get a numeric expression
1813+  0FF1 F6          TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
1814+  0FF2 37          TSTSTR: SCF                     ; Set carry (string)
1815+  0FF3 3A 5D 31    CHKTYP: LD      A,(TYPE)        ; Check types match
1816+  0FF6 8F                  ADC     A,A             ; Expected + actual
1817+  0FF7 B7                  OR      A               ; Clear carry , set parity
1818+  0FF8 E8                  RET     PE              ; Even parity - Types match
1819+  0FF9 C3 3B 07            JP      TMERR           ; Different types - Error
1820+  0FFC             
1821+  0FFC CD F7 09    OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
1822+  0FFF 28                  .BYTE   "("
1823+  1000 2B          EVAL:   DEC     HL              ; Evaluate expression & save
1824+  1001 16 00               LD      D,0             ; Precedence value
1825+  1003 D5          EVAL1:  PUSH    DE              ; Save precedence
1826+  1004 0E 01               LD      C,1
1827+  1006 CD 06 07            CALL    CHKSTK          ; Check for 1 level of stack
1828+  1009 CD 77 10            CALL    OPRND           ; Get next expression value
1829+  100C 22 80 31    EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
1830+  100F 2A 80 31    EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
1831+  1012 C1                  POP     BC              ; Precedence value and operator
1832+  1013 78                  LD      A,B             ; Get precedence value
1833+  1014 FE 78               CP      78H             ; "AND" or "OR" ?
1834+  1016 D4 F1 0F            CALL    NC,TSTNUM       ; No - Make sure it's a number
1835+  1019 7E                  LD      A,(HL)          ; Get next operator / function
1836+  101A 16 00               LD      D,0             ; Clear Last relation
1837+  101C D6 B3       RLTLP:  SUB     ZGTR            ; ">" Token
1838+  101E DA 38 10            JP      C,FOPRND        ; + - * / ^ AND OR - Test it
1839+  1021 FE 03               CP      ZLTH+1-ZGTR     ; < = >
1840+  1023 D2 38 10            JP      NC,FOPRND       ; Function - Call it
1841+  1026 FE 01               CP      ZEQUAL-ZGTR     ; "="
1842+  1028 17                  RLA                     ; <- Test for legal
1843+  1029 AA                  XOR     D               ; <- combinations of < = >
1844+  102A BA                  CP      D               ; <- by combining last token
1845+  102B 57                  LD      D,A             ; <- with current one
1846+  102C DA 29 07            JP      C,SNERR         ; Error if "<<' '==" or ">>"
1847+  102F 22 75 31            LD      (CUROPR),HL     ; Save address of current token
1848+  1032 CD 81 0B            CALL    GETCHR          ; Get next character
1849+  1035 C3 1C 10            JP      RLTLP           ; Treat the two as one
1850+  1038             
1851+  1038 7A          FOPRND: LD      A,D             ; < = > found ?
1852+  1039 B7                  OR      A
1853+  103A C2 5F 11            JP      NZ,TSTRED       ; Yes - Test for reduction
1854+  103D 7E                  LD      A,(HL)          ; Get operator token
1855+  103E 22 75 31            LD      (CUROPR),HL     ; Save operator address
1856+  1041 D6 AC               SUB     ZPLUS           ; Operator or function?
1857+  1043 D8                  RET     C               ; Neither - Exit
1858+  1044 FE 07               CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
1859+  1046 D0                  RET     NC              ; No - Exit
1860+  1047 5F                  LD      E,A             ; Coded operator
1861+  1048 3A 5D 31            LD      A,(TYPE)        ; Get data type
1862+  104B 3D                  DEC     A               ; FF = numeric , 00 = string
1863+  104C B3                  OR      E               ; Combine with coded operator
1864+  104D 7B                  LD      A,E             ; Get coded operator
1865+  104E CA BD 15            JP      Z,CONCAT        ; String concatenation
1866+  1051 07                  RLCA                    ; Times 2
1867+  1052 83                  ADD     A,E             ; Times 3
1868+  1053 5F                  LD      E,A             ; To DE (D is 0)
1869+  1054 21 1B 06            LD      HL,PRITAB       ; Precedence table
1870+  1057 19                  ADD     HL,DE           ; To the operator concerned
1871+  1058 78                  LD      A,B             ; Last operator precedence
1872+  1059 56                  LD      D,(HL)          ; Get evaluation precedence
1873+  105A BA                  CP      D               ; Compare with eval precedence
1874+  105B D0                  RET     NC              ; Exit if higher precedence
1875+  105C 23                  INC     HL              ; Point to routine address
1876+  105D CD F1 0F            CALL    TSTNUM          ; Make sure it's a number
1877+  1060             
1878+  1060 C5          STKTHS: PUSH    BC              ; Save last precedence & token
1879+  1061 01 0F 10            LD      BC,EVAL3        ; Where to go on prec' break
1880+  1064 C5                  PUSH    BC              ; Save on stack for return
1881+  1065 43                  LD      B,E             ; Save operator
1882+  1066 4A                  LD      C,D             ; Save precedence
1883+  1067 CD 01 1A            CALL    STAKFP          ; Move value to stack
1884+  106A 58                  LD      E,B             ; Restore operator
1885+  106B 51                  LD      D,C             ; Restore precedence
1886+  106C 4E                  LD      C,(HL)          ; Get LSB of routine address
1887+  106D 23                  INC     HL
1888+  106E 46                  LD      B,(HL)          ; Get MSB of routine address
1889+  106F 23                  INC     HL
1890+  1070 C5                  PUSH    BC              ; Save routine address
1891+  1071 2A 75 31            LD      HL,(CUROPR)     ; Address of current operator
1892+  1074 C3 03 10            JP      EVAL1           ; Loop until prec' break
1893+  1077             
1894+  1077 AF          OPRND:  XOR     A               ; Get operand routine
1895+  1078 32 5D 31            LD      (TYPE),A        ; Set numeric expected
1896+  107B CD 81 0B            CALL    GETCHR          ; Get next character
1897+  107E 1E 24               LD      E,MO            ; ?MO Error
1898+  1080 CA 3D 07            JP      Z,ERROR         ; No operand - Error
1899+  1083 DA D7 1A            JP      C,ASCTFP        ; Number - Get value
1900+  1086 CD 1F 0C            CALL    CHKLTR          ; See if a letter
1901+  1089 D2 DE 10            JP      NC,CONVAR       ; Letter - Find variable
1902+  108C FE 26               CP		'&'				; &H = HEX, &B = BINARY
1903+  108E 20 12               JR		NZ, NOTAMP
1904+  1090 CD 81 0B            CALL    GETCHR          ; Get next character
1905+  1093 FE 48               CP      'H'             ; Hex number indicated? [function added]
1906+  1095 CA 1B 1F            JP      Z,HEXTFP        ; Convert Hex to FPREG
1907+  1098 FE 42               CP      'B'             ; Binary number indicated? [function added]
1908+  109A CA 8B 1F            JP      Z,BINTFP        ; Convert Bin to FPREG
1909+  109D 1E 02               LD      E,SN            ; If neither then a ?SN Error
1910+  109F CA 3D 07            JP      Z,ERROR         ; 
1911+  10A2 FE AC       NOTAMP: CP      ZPLUS           ; '+' Token ?
1912+  10A4 CA 77 10            JP      Z,OPRND         ; Yes - Look for operand
1913+  10A7 FE 2E               CP      '.'             ; '.' ?
1914+  10A9 CA D7 1A            JP      Z,ASCTFP        ; Yes - Create FP number
1915+  10AC FE AD               CP      ZMINUS          ; '-' Token ?
1916+  10AE CA CD 10            JP      Z,MINUS         ; Yes - Do minus
1917+  10B1 FE 22               CP      '"'             ; Literal string ?
1918+  10B3 CA 86 14            JP      Z,QTSTR         ; Get string terminated by '"'
1919+  10B6 FE AA               CP      ZNOT            ; "NOT" Token ?
1920+  10B8 CA BF 11            JP      Z,EVNOT         ; Yes - Eval NOT expression
1921+  10BB FE A7               CP      ZFN             ; "FN" Token ?
1922+  10BD CA EA 13            JP      Z,DOFN          ; Yes - Do FN routine
1923+  10C0 D6 B6               SUB     ZSGN            ; Is it a function?
1924+  10C2 D2 EF 10            JP      NC,FNOFST       ; Yes - Evaluate function
1925+  10C5 CD FC 0F    EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
1926+  10C8 CD F7 09            CALL    CHKSYN          ; Make sure ")" follows
1927+  10CB 29                  .BYTE   ")"
1928+  10CC C9                  RET
1929+  10CD             
1930+  10CD 16 7D       MINUS:  LD      D,7DH           ; '-' precedence
1931+  10CF CD 03 10            CALL    EVAL1           ; Evaluate until prec' break
1932+  10D2 2A 80 31            LD      HL,(NXTOPR)     ; Get next operator address
1933+  10D5 E5                  PUSH    HL              ; Save next operator address
1934+  10D6 CD F9 19            CALL    INVSGN          ; Negate value
1935+  10D9 CD F1 0F    RETNUM: CALL    TSTNUM          ; Make sure it's a number
1936+  10DC E1                  POP     HL              ; Restore next operator address
1937+  10DD C9                  RET
1938+  10DE             
1939+  10DE CD E4 11    CONVAR: CALL    GETVAR          ; Get variable address to DE
1940+  10E1 E5          FRMEVL: PUSH    HL              ; Save code string address
1941+  10E2 EB                  EX      DE,HL           ; Variable address to HL
1942+  10E3 22 94 31            LD      (FPREG),HL      ; Save address of variable
1943+  10E6 3A 5D 31            LD      A,(TYPE)        ; Get type
1944+  10E9 B7                  OR      A               ; Numeric?
1945+  10EA CC 0E 1A            CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
1946+  10ED E1                  POP     HL              ; Restore code string address
1947+  10EE C9                  RET
1948+  10EF             
1949+  10EF 06 00       FNOFST: LD      B,0             ; Get address of function
1950+  10F1 07                  RLCA                    ; Double function offset
1951+  10F2 4F                  LD      C,A             ; BC = Offset in function table
1952+  10F3 C5                  PUSH    BC              ; Save adjusted token value
1953+  10F4 CD 81 0B            CALL    GETCHR          ; Get next character
1954+  10F7 79                  LD      A,C             ; Get adjusted token value
1955+  10F8 FE 31               CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1956+  10FA DA 16 11            JP      C,FNVAL         ; No - Do function
1957+  10FD CD FC 0F            CALL    OPNPAR          ; Evaluate expression  (X,...
1958+  1100 CD F7 09            CALL    CHKSYN          ; Make sure ',' follows
1959+  1103 2C                  .BYTE      ','
1960+  1104 CD F2 0F            CALL    TSTSTR          ; Make sure it's a string
1961+  1107 EB                  EX      DE,HL           ; Save code string address
1962+  1108 2A 94 31            LD      HL,(FPREG)      ; Get address of string
1963+  110B E3                  EX      (SP),HL         ; Save address of string
1964+  110C E5                  PUSH    HL              ; Save adjusted token value
1965+  110D EB                  EX      DE,HL           ; Restore code string address
1966+  110E CD 4F 17            CALL    GETINT          ; Get integer 0-255
1967+  1111 EB                  EX      DE,HL           ; Save code string address
1968+  1112 E3                  EX      (SP),HL         ; Save integer,HL = adj' token
1969+  1113 C3 1E 11            JP      GOFUNC          ; Jump to string function
1970+  1116             
1971+  1116 CD C5 10    FNVAL:  CALL    EVLPAR          ; Evaluate expression
1972+  1119 E3                  EX      (SP),HL         ; HL = Adjusted token value
1973+  111A 11 D9 10            LD      DE,RETNUM       ; Return number from function
1974+  111D D5                  PUSH    DE              ; Save on stack
1975+  111E 01 7A 04    GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
1976+  1121 09                  ADD     HL,BC           ; Point to right address
1977+  1122 4E                  LD      C,(HL)          ; Get LSB of address
1978+  1123 23                  INC     HL              ;
1979+  1124 66                  LD      H,(HL)          ; Get MSB of address
1980+  1125 69                  LD      L,C             ; Address to HL
1981+  1126 E9                  JP      (HL)            ; Jump to function
1982+  1127             
1983+  1127 15          SGNEXP: DEC     D               ; Dee to flag negative exponent
1984+  1128 FE AD               CP      ZMINUS          ; '-' token ?
1985+  112A C8                  RET     Z               ; Yes - Return
1986+  112B FE 2D               CP      '-'             ; '-' ASCII ?
1987+  112D C8                  RET     Z               ; Yes - Return
1988+  112E 14                  INC     D               ; Inc to flag positive exponent
1989+  112F FE 2B               CP      '+'             ; '+' ASCII ?
1990+  1131 C8                  RET     Z               ; Yes - Return
1991+  1132 FE AC               CP      ZPLUS           ; '+' token ?
1992+  1134 C8                  RET     Z               ; Yes - Return
1993+  1135 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
1994+  1136 C9                  RET                     ; Return "NZ"
1995+  1137             
1996+  1137 F6          POR:    .BYTE      0F6H            ; Flag "OR"
1997+  1138 AF          PAND:   XOR     A               ; Flag "AND"
1998+  1139 F5                  PUSH    AF              ; Save "AND" / "OR" flag
1999+  113A CD F1 0F            CALL    TSTNUM          ; Make sure it's a number
2000+  113D CD 33 0C            CALL    DEINT           ; Get integer -32768 to 32767
2001+  1140 F1                  POP     AF              ; Restore "AND" / "OR" flag
2002+  1141 EB                  EX      DE,HL           ; <- Get last
2003+  1142 C1                  POP     BC              ; <-  value
2004+  1143 E3                  EX      (SP),HL         ; <-  from
2005+  1144 EB                  EX      DE,HL           ; <-  stack
2006+  1145 CD 11 1A            CALL    FPBCDE          ; Move last value to FPREG
2007+  1148 F5                  PUSH    AF              ; Save "AND" / "OR" flag
2008+  1149 CD 33 0C            CALL    DEINT           ; Get integer -32768 to 32767
2009+  114C F1                  POP     AF              ; Restore "AND" / "OR" flag
2010+  114D C1                  POP     BC              ; Get value
2011+  114E 79                  LD      A,C             ; Get LSB
2012+  114F 21 A8 13            LD      HL,ACPASS       ; Address of save AC as current
2013+  1152 C2 5A 11            JP      NZ,POR1         ; Jump if OR
2014+  1155 A3                  AND     E               ; "AND" LSBs
2015+  1156 4F                  LD      C,A             ; Save LSB
2016+  1157 78                  LD      A,B             ; Get MBS
2017+  1158 A2                  AND     D               ; "AND" MSBs
2018+  1159 E9                  JP      (HL)            ; Save AC as current (ACPASS)
2019+  115A             
2020+  115A B3          POR1:   OR      E               ; "OR" LSBs
2021+  115B 4F                  LD      C,A             ; Save LSB
2022+  115C 78                  LD      A,B             ; Get MSB
2023+  115D B2                  OR      D               ; "OR" MSBs
2024+  115E E9                  JP      (HL)            ; Save AC as current (ACPASS)
2025+  115F             
2026+  115F 21 71 11    TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2027+  1162 3A 5D 31            LD      A,(TYPE)        ; Get data type
2028+  1165 1F                  RRA                     ; Carry set = string
2029+  1166 7A                  LD      A,D             ; Get last precedence value
2030+  1167 17                  RLA                     ; Times 2 plus carry
2031+  1168 5F                  LD      E,A             ; To E
2032+  1169 16 64               LD      D,64H           ; Relational precedence
2033+  116B 78                  LD      A,B             ; Get current precedence
2034+  116C BA                  CP      D               ; Compare with last
2035+  116D D0                  RET     NC              ; Eval if last was rel' or log'
2036+  116E C3 60 10            JP      STKTHS          ; Stack this one and get next
2037+  1171             
2038+  1171 73 11       CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
2039+  1173 79          CMPLG1: LD      A,C             ; Get data type
2040+  1174 B7                  OR      A
2041+  1175 1F                  RRA
2042+  1176 C1                  POP     BC              ; Get last expression to BCDE
2043+  1177 D1                  POP     DE
2044+  1178 F5                  PUSH    AF              ; Save status
2045+  1179 CD F3 0F            CALL    CHKTYP          ; Check that types match
2046+  117C 21 B5 11            LD      HL,CMPRES       ; Result to comparison
2047+  117F E5                  PUSH    HL              ; Save for RETurn
2048+  1180 CA 4B 1A            JP      Z,CMPNUM        ; Compare values if numeric
2049+  1183 AF                  XOR     A               ; Compare two strings
2050+  1184 32 5D 31            LD      (TYPE),A        ; Set type to numeric
2051+  1187 D5                  PUSH    DE              ; Save string name
2052+  1188 CD 0A 16            CALL    GSTRCU          ; Get current string
2053+  118B 7E                  LD      A,(HL)          ; Get length of string
2054+  118C 23                  INC     HL
2055+  118D 23                  INC     HL
2056+  118E 4E                  LD      C,(HL)          ; Get LSB of address
2057+  118F 23                  INC     HL
2058+  1190 46                  LD      B,(HL)          ; Get MSB of address
2059+  1191 D1                  POP     DE              ; Restore string name
2060+  1192 C5                  PUSH    BC              ; Save address of string
2061+  1193 F5                  PUSH    AF              ; Save length of string
2062+  1194 CD 0E 16            CALL    GSTRDE          ; Get second string
2063+  1197 CD 1F 1A            CALL    LOADFP          ; Get address of second string
2064+  119A F1                  POP     AF              ; Restore length of string 1
2065+  119B 57                  LD      D,A             ; Length to D
2066+  119C E1                  POP     HL              ; Restore address of string 1
2067+  119D 7B          CMPSTR: LD      A,E             ; Bytes of string 2 to do
2068+  119E B2                  OR      D               ; Bytes of string 1 to do
2069+  119F C8                  RET     Z               ; Exit if all bytes compared
2070+  11A0 7A                  LD      A,D             ; Get bytes of string 1 to do
2071+  11A1 D6 01               SUB     1
2072+  11A3 D8                  RET     C               ; Exit if end of string 1
2073+  11A4 AF                  XOR     A
2074+  11A5 BB                  CP      E               ; Bytes of string 2 to do
2075+  11A6 3C                  INC     A
2076+  11A7 D0                  RET     NC              ; Exit if end of string 2
2077+  11A8 15                  DEC     D               ; Count bytes in string 1
2078+  11A9 1D                  DEC     E               ; Count bytes in string 2
2079+  11AA 0A                  LD      A,(BC)          ; Byte in string 2
2080+  11AB BE                  CP      (HL)            ; Compare to byte in string 1
2081+  11AC 23                  INC     HL              ; Move up string 1
2082+  11AD 03                  INC     BC              ; Move up string 2
2083+  11AE CA 9D 11            JP      Z,CMPSTR        ; Same - Try next bytes
2084+  11B1 3F                  CCF                     ; Flag difference (">" or "<")
2085+  11B2 C3 DB 19            JP      FLGDIF          ; "<" gives -1 , ">" gives +1
2086+  11B5             
2087+  11B5 3C          CMPRES: INC     A               ; Increment current value
2088+  11B6 8F                  ADC     A,A             ; Double plus carry
2089+  11B7 C1                  POP     BC              ; Get other value
2090+  11B8 A0                  AND     B               ; Combine them
2091+  11B9 C6 FF               ADD     A,-1            ; Carry set if different
2092+  11BB 9F                  SBC     A,A             ; 00 - Equal , FF - Different
2093+  11BC C3 E2 19            JP      FLGREL          ; Set current value & continue
2094+  11BF             
2095+  11BF 16 5A       EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2096+  11C1 CD 03 10            CALL    EVAL1           ; Eval until precedence break
2097+  11C4 CD F1 0F            CALL    TSTNUM          ; Make sure it's a number
2098+  11C7 CD 33 0C            CALL    DEINT           ; Get integer -32768 - 32767
2099+  11CA 7B                  LD      A,E             ; Get LSB
2100+  11CB 2F                  CPL                     ; Invert LSB
2101+  11CC 4F                  LD      C,A             ; Save "NOT" of LSB
2102+  11CD 7A                  LD      A,D             ; Get MSB
2103+  11CE 2F                  CPL                     ; Invert MSB
2104+  11CF CD A8 13            CALL    ACPASS          ; Save AC as current
2105+  11D2 C1                  POP     BC              ; Clean up stack
2106+  11D3 C3 0F 10            JP      EVAL3           ; Continue evaluation
2107+  11D6             
2108+  11D6 2B          DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2109+  11D7 CD 81 0B            CALL    GETCHR          ; Get next character
2110+  11DA C8                  RET     Z               ; End of DIM statement
2111+  11DB CD F7 09            CALL    CHKSYN          ; Make sure ',' follows
2112+  11DE 2C                  .BYTE      ','
2113+  11DF 01 D6 11    DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2114+  11E2 C5                  PUSH    BC              ; Save on stack
2115+  11E3 F6                  .BYTE      0F6H            ; Flag "Create" variable
2116+  11E4 AF          GETVAR: XOR     A               ; Find variable address,to DE
2117+  11E5 32 5C 31            LD      (LCRFLG),A      ; Set locate / create flag
2118+  11E8 46                  LD      B,(HL)          ; Get First byte of name
2119+  11E9 CD 1F 0C    GTFNAM: CALL    CHKLTR          ; See if a letter
2120+  11EC DA 29 07            JP      C,SNERR         ; ?SN Error if not a letter
2121+  11EF AF                  XOR     A
2122+  11F0 4F                  LD      C,A             ; Clear second byte of name
2123+  11F1 32 5D 31            LD      (TYPE),A        ; Set type to numeric
2124+  11F4 CD 81 0B            CALL    GETCHR          ; Get next character
2125+  11F7 DA 00 12            JP      C,SVNAM2        ; Numeric - Save in name
2126+  11FA CD 1F 0C            CALL    CHKLTR          ; See if a letter
2127+  11FD DA 0D 12            JP      C,CHARTY        ; Not a letter - Check type
2128+  1200 4F          SVNAM2: LD      C,A             ; Save second byte of name
2129+  1201 CD 81 0B    ENDNAM: CALL    GETCHR          ; Get next character
2130+  1204 DA 01 12            JP      C,ENDNAM        ; Numeric - Get another
2131+  1207 CD 1F 0C            CALL    CHKLTR          ; See if a letter
2132+  120A D2 01 12            JP      NC,ENDNAM       ; Letter - Get another
2133+  120D D6 24       CHARTY: SUB     '$'             ; String variable?
2134+  120F C2 1C 12            JP      NZ,NOTSTR       ; No - Numeric variable
2135+  1212 3C                  INC     A               ; A = 1 (string type)
2136+  1213 32 5D 31            LD      (TYPE),A        ; Set type to string
2137+  1216 0F                  RRCA                    ; A = 80H , Flag for string
2138+  1217 81                  ADD     A,C             ; 2nd byte of name has bit 7 on
2139+  1218 4F                  LD      C,A             ; Resave second byte on name
2140+  1219 CD 81 0B            CALL    GETCHR          ; Get next character
2141+  121C 3A 7B 31    NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2142+  121F 3D                  DEC     A
2143+  1220 CA C9 12            JP      Z,ARLDSV        ; Yes - Get array name
2144+  1223 F2 2C 12            JP      P,NSCFOR        ; No array with "FOR" or "FN"
2145+  1226 7E                  LD      A,(HL)          ; Get byte again
2146+  1227 D6 28               SUB     '('             ; Subscripted variable?
2147+  1229 CA A1 12            JP      Z,SBSCPT        ; Yes - Sort out subscript
2148+  122C             
2149+  122C AF          NSCFOR: XOR     A               ; Simple variable
2150+  122D 32 7B 31            LD      (FORFLG),A      ; Clear "FOR" flag
2151+  1230 E5                  PUSH    HL              ; Save code string address
2152+  1231 50                  LD      D,B             ; DE = Variable name to find
2153+  1232 59                  LD      E,C
2154+  1233 2A 8E 31            LD      HL,(FNRGNM)     ; FN argument name
2155+  1236 CD F1 09            CALL    CPDEHL          ; Is it the FN argument?
2156+  1239 11 90 31            LD      DE,FNARG        ; Point to argument value
2157+  123C CA 11 19            JP      Z,POPHRT        ; Yes - Return FN argument value
2158+  123F 2A 88 31            LD      HL,(VAREND)     ; End of variables
2159+  1242 EB                  EX      DE,HL           ; Address of end of search
2160+  1243 2A 86 31            LD      HL,(PROGND)     ; Start of variables address
2161+  1246 CD F1 09    FNDVAR: CALL    CPDEHL          ; End of variable list table?
2162+  1249 CA 5F 12            JP      Z,CFEVAL        ; Yes - Called from EVAL?
2163+  124C 79                  LD      A,C             ; Get second byte of name
2164+  124D 96                  SUB     (HL)            ; Compare with name in list
2165+  124E 23                  INC     HL              ; Move on to first byte
2166+  124F C2 54 12            JP      NZ,FNTHR        ; Different - Find another
2167+  1252 78                  LD      A,B             ; Get first byte of name
2168+  1253 96                  SUB     (HL)            ; Compare with name in list
2169+  1254 23          FNTHR:  INC     HL              ; Move on to LSB of value
2170+  1255 CA 93 12            JP      Z,RETADR        ; Found - Return address
2171+  1258 23                  INC     HL              ; <- Skip
2172+  1259 23                  INC     HL              ; <- over
2173+  125A 23                  INC     HL              ; <- F.P.
2174+  125B 23                  INC     HL              ; <- value
2175+  125C C3 46 12            JP      FNDVAR          ; Keep looking
2176+  125F             
2177+  125F E1          CFEVAL: POP     HL              ; Restore code string address
2178+  1260 E3                  EX      (SP),HL         ; Get return address
2179+  1261 D5                  PUSH    DE              ; Save address of variable
2180+  1262 11 E1 10            LD      DE,FRMEVL       ; Return address in EVAL
2181+  1265 CD F1 09            CALL    CPDEHL          ; Called from EVAL ?
2182+  1268 D1                  POP     DE              ; Restore address of variable
2183+  1269 CA 96 12            JP      Z,RETNUL        ; Yes - Return null variable
2184+  126C E3                  EX      (SP),HL         ; Put back return
2185+  126D E5                  PUSH    HL              ; Save code string address
2186+  126E C5                  PUSH    BC              ; Save variable name
2187+  126F 01 06 00            LD      BC,6            ; 2 byte name plus 4 byte data
2188+  1272 2A 8A 31            LD      HL,(ARREND)     ; End of arrays
2189+  1275 E5                  PUSH    HL              ; Save end of arrays
2190+  1276 09                  ADD     HL,BC           ; Move up 6 bytes
2191+  1277 C1                  POP     BC              ; Source address in BC
2192+  1278 E5                  PUSH    HL              ; Save new end address
2193+  1279 CD F5 06            CALL    MOVUP           ; Move arrays up
2194+  127C E1                  POP     HL              ; Restore new end address
2195+  127D 22 8A 31            LD      (ARREND),HL     ; Set new end address
2196+  1280 60                  LD      H,B             ; End of variables to HL
2197+  1281 69                  LD      L,C
2198+  1282 22 88 31            LD      (VAREND),HL     ; Set new end address
2199+  1285             
2200+  1285 2B          ZEROLP: DEC     HL              ; Back through to zero variable
2201+  1286 36 00               LD      (HL),0          ; Zero byte in variable
2202+  1288 CD F1 09            CALL    CPDEHL          ; Done them all?
2203+  128B C2 85 12            JP      NZ,ZEROLP       ; No - Keep on going
2204+  128E D1                  POP     DE              ; Get variable name
2205+  128F 73                  LD      (HL),E          ; Store second character
2206+  1290 23                  INC     HL
2207+  1291 72                  LD      (HL),D          ; Store first character
2208+  1292 23                  INC     HL
2209+  1293 EB          RETADR: EX      DE,HL           ; Address of variable in DE
2210+  1294 E1                  POP     HL              ; Restore code string address
2211+  1295 C9                  RET
2212+  1296             
2213+  1296 32 97 31    RETNUL: LD      (FPEXP),A       ; Set result to zero
2214+  1299 21 C5 06            LD      HL,ZERBYT       ; Also set a null string
2215+  129C 22 94 31            LD      (FPREG),HL      ; Save for EVAL
2216+  129F E1                  POP     HL              ; Restore code string address
2217+  12A0 C9                  RET
2218+  12A1             
2219+  12A1 E5          SBSCPT: PUSH    HL              ; Save code string address
2220+  12A2 2A 5C 31            LD      HL,(LCRFLG)     ; Locate/Create and Type
2221+  12A5 E3                  EX      (SP),HL         ; Save and get code string
2222+  12A6 57                  LD      D,A             ; Zero number of dimensions
2223+  12A7 D5          SCPTLP: PUSH    DE              ; Save number of dimensions
2224+  12A8 C5                  PUSH    BC              ; Save array name
2225+  12A9 CD 27 0C            CALL    FPSINT          ; Get subscript (0-32767)
2226+  12AC C1                  POP     BC              ; Restore array name
2227+  12AD F1                  POP     AF              ; Get number of dimensions
2228+  12AE EB                  EX      DE,HL
2229+  12AF E3                  EX      (SP),HL         ; Save subscript value
2230+  12B0 E5                  PUSH    HL              ; Save LCRFLG and TYPE
2231+  12B1 EB                  EX      DE,HL
2232+  12B2 3C                  INC     A               ; Count dimensions
2233+  12B3 57                  LD      D,A             ; Save in D
2234+  12B4 7E                  LD      A,(HL)          ; Get next byte in code string
2235+  12B5 FE 2C               CP      ','             ; Comma (more to come)?
2236+  12B7 CA A7 12            JP      Z,SCPTLP        ; Yes - More subscripts
2237+  12BA CD F7 09            CALL    CHKSYN          ; Make sure ")" follows
2238+  12BD 29                  .BYTE      ")"
2239+  12BE 22 80 31            LD      (NXTOPR),HL     ; Save code string address
2240+  12C1 E1                  POP     HL              ; Get LCRFLG and TYPE
2241+  12C2 22 5C 31            LD      (LCRFLG),HL     ; Restore Locate/create & type
2242+  12C5 1E 00               LD      E,0             ; Flag not CSAVE* or CLOAD*
2243+  12C7 D5                  PUSH    DE              ; Save number of dimensions (D)
2244+  12C8 11                  .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
2245+  12C9             
2246+  12C9 E5          ARLDSV: PUSH    HL              ; Save code string address
2247+  12CA F5                  PUSH    AF              ; A = 00 , Flags set = Z,N
2248+  12CB 2A 88 31            LD      HL,(VAREND)     ; Start of arrays
2249+  12CE 3E                  .BYTE      3EH             ; Skip "ADD HL,DE"
2250+  12CF 19          FNDARY: ADD     HL,DE           ; Move to next array start
2251+  12D0 EB                  EX      DE,HL
2252+  12D1 2A 8A 31            LD      HL,(ARREND)     ; End of arrays
2253+  12D4 EB                  EX      DE,HL           ; Current array pointer
2254+  12D5 CD F1 09            CALL    CPDEHL          ; End of arrays found?
2255+  12D8 CA 01 13            JP      Z,CREARY        ; Yes - Create array
2256+  12DB 7E                  LD      A,(HL)          ; Get second byte of name
2257+  12DC B9                  CP      C               ; Compare with name given
2258+  12DD 23                  INC     HL              ; Move on
2259+  12DE C2 E3 12            JP      NZ,NXTARY       ; Different - Find next array
2260+  12E1 7E                  LD      A,(HL)          ; Get first byte of name
2261+  12E2 B8                  CP      B               ; Compare with name given
2262+  12E3 23          NXTARY: INC     HL              ; Move on
2263+  12E4 5E                  LD      E,(HL)          ; Get LSB of next array address
2264+  12E5 23                  INC     HL
2265+  12E6 56                  LD      D,(HL)          ; Get MSB of next array address
2266+  12E7 23                  INC     HL
2267+  12E8 C2 CF 12            JP      NZ,FNDARY       ; Not found - Keep looking
2268+  12EB 3A 5C 31            LD      A,(LCRFLG)      ; Found Locate or Create it?
2269+  12EE B7                  OR      A
2270+  12EF C2 32 07            JP      NZ,DDERR        ; Create - ?DD Error
2271+  12F2 F1                  POP     AF              ; Locate - Get number of dim'ns
2272+  12F3 44                  LD      B,H             ; BC Points to array dim'ns
2273+  12F4 4D                  LD      C,L
2274+  12F5 CA 11 19            JP      Z,POPHRT        ; Jump if array load/save
2275+  12F8 96                  SUB     (HL)            ; Same number of dimensions?
2276+  12F9 CA 5F 13            JP      Z,FINDEL        ; Yes - Find element
2277+  12FC 1E 10       BSERR:  LD      E,BS            ; ?BS Error
2278+  12FE C3 3D 07            JP      ERROR           ; Output error
2279+  1301             
2280+  1301 11 04 00    CREARY: LD      DE,4            ; 4 Bytes per entry
2281+  1304 F1                  POP     AF              ; Array to save or 0 dim'ns?
2282+  1305 CA 48 0C            JP      Z,FCERR         ; Yes - ?FC Error
2283+  1308 71                  LD      (HL),C          ; Save second byte of name
2284+  1309 23                  INC     HL
2285+  130A 70                  LD      (HL),B          ; Save first byte of name
2286+  130B 23                  INC     HL
2287+  130C 4F                  LD      C,A             ; Number of dimensions to C
2288+  130D CD 06 07            CALL    CHKSTK          ; Check if enough memory
2289+  1310 23                  INC     HL              ; Point to number of dimensions
2290+  1311 23                  INC     HL
2291+  1312 22 75 31            LD      (CUROPR),HL     ; Save address of pointer
2292+  1315 71                  LD      (HL),C          ; Set number of dimensions
2293+  1316 23                  INC     HL
2294+  1317 3A 5C 31            LD      A,(LCRFLG)      ; Locate of Create?
2295+  131A 17                  RLA                     ; Carry set = Create
2296+  131B 79                  LD      A,C             ; Get number of dimensions
2297+  131C 01 0B 00    CRARLP: LD      BC,10+1         ; Default dimension size 10
2298+  131F D2 24 13            JP      NC,DEFSIZ       ; Locate - Set default size
2299+  1322 C1                  POP     BC              ; Get specified dimension size
2300+  1323 03                  INC     BC              ; Include zero element
2301+  1324 71          DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2302+  1325 23                  INC     HL
2303+  1326 70                  LD      (HL),B          ; Save MSB of dimension size
2304+  1327 23                  INC     HL
2305+  1328 F5                  PUSH    AF              ; Save num' of dim'ns an status
2306+  1329 E5                  PUSH    HL              ; Save address of dim'n size
2307+  132A CD BC 1A            CALL    MLDEBC          ; Multiply DE by BC to find
2308+  132D EB                  EX      DE,HL           ; amount of mem needed (to DE)
2309+  132E E1                  POP     HL              ; Restore address of dimension
2310+  132F F1                  POP     AF              ; Restore number of dimensions
2311+  1330 3D                  DEC     A               ; Count them
2312+  1331 C2 1C 13            JP      NZ,CRARLP       ; Do next dimension if more
2313+  1334 F5                  PUSH    AF              ; Save locate/create flag
2314+  1335 42                  LD      B,D             ; MSB of memory needed
2315+  1336 4B                  LD      C,E             ; LSB of memory needed
2316+  1337 EB                  EX      DE,HL
2317+  1338 19                  ADD     HL,DE           ; Add bytes to array start
2318+  1339 DA 1E 07            JP      C,OMERR         ; Too big - Error
2319+  133C CD 0F 07            CALL    ENFMEM          ; See if enough memory
2320+  133F 22 8A 31            LD      (ARREND),HL     ; Save new end of array
2321+  1342             
2322+  1342 2B          ZERARY: DEC     HL              ; Back through array data
2323+  1343 36 00               LD      (HL),0          ; Set array element to zero
2324+  1345 CD F1 09            CALL    CPDEHL          ; All elements zeroed?
2325+  1348 C2 42 13            JP      NZ,ZERARY       ; No - Keep on going
2326+  134B 03                  INC     BC              ; Number of bytes + 1
2327+  134C 57                  LD      D,A             ; A=0
2328+  134D 2A 75 31            LD      HL,(CUROPR)     ; Get address of array
2329+  1350 5E                  LD      E,(HL)          ; Number of dimensions
2330+  1351 EB                  EX      DE,HL           ; To HL
2331+  1352 29                  ADD     HL,HL           ; Two bytes per dimension size
2332+  1353 09                  ADD     HL,BC           ; Add number of bytes
2333+  1354 EB                  EX      DE,HL           ; Bytes needed to DE
2334+  1355 2B                  DEC     HL
2335+  1356 2B                  DEC     HL
2336+  1357 73                  LD      (HL),E          ; Save LSB of bytes needed
2337+  1358 23                  INC     HL
2338+  1359 72                  LD      (HL),D          ; Save MSB of bytes needed
2339+  135A 23                  INC     HL
2340+  135B F1                  POP     AF              ; Locate / Create?
2341+  135C DA 83 13            JP      C,ENDDIM        ; A is 0 , End if create
2342+  135F 47          FINDEL: LD      B,A             ; Find array element
2343+  1360 4F                  LD      C,A
2344+  1361 7E                  LD      A,(HL)          ; Number of dimensions
2345+  1362 23                  INC     HL
2346+  1363 16                  .BYTE      16H             ; Skip "POP HL"
2347+  1364 E1          FNDELP: POP     HL              ; Address of next dim' size
2348+  1365 5E                  LD      E,(HL)          ; Get LSB of dim'n size
2349+  1366 23                  INC     HL
2350+  1367 56                  LD      D,(HL)          ; Get MSB of dim'n size
2351+  1368 23                  INC     HL
2352+  1369 E3                  EX      (SP),HL         ; Save address - Get index
2353+  136A F5                  PUSH    AF              ; Save number of dim'ns
2354+  136B CD F1 09            CALL    CPDEHL          ; Dimension too large?
2355+  136E D2 FC 12            JP      NC,BSERR        ; Yes - ?BS Error
2356+  1371 E5                  PUSH    HL              ; Save index
2357+  1372 CD BC 1A            CALL    MLDEBC          ; Multiply previous by size
2358+  1375 D1                  POP     DE              ; Index supplied to DE
2359+  1376 19                  ADD     HL,DE           ; Add index to pointer
2360+  1377 F1                  POP     AF              ; Number of dimensions
2361+  1378 3D                  DEC     A               ; Count them
2362+  1379 44                  LD      B,H             ; MSB of pointer
2363+  137A 4D                  LD      C,L             ; LSB of pointer
2364+  137B C2 64 13            JP      NZ,FNDELP       ; More - Keep going
2365+  137E 29                  ADD     HL,HL           ; 4 Bytes per element
2366+  137F 29                  ADD     HL,HL
2367+  1380 C1                  POP     BC              ; Start of array
2368+  1381 09                  ADD     HL,BC           ; Point to element
2369+  1382 EB                  EX      DE,HL           ; Address of element to DE
2370+  1383 2A 80 31    ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
2371+  1386 C9                  RET
2372+  1387             
2373+  1387 2A 8A 31    FRE:    LD      HL,(ARREND)     ; Start of free memory
2374+  138A EB                  EX      DE,HL           ; To DE
2375+  138B 21 00 00            LD      HL,0            ; End of free memory
2376+  138E 39                  ADD     HL,SP           ; Current stack value
2377+  138F 3A 5D 31            LD      A,(TYPE)        ; Dummy argument type
2378+  1392 B7                  OR      A
2379+  1393 CA A3 13            JP      Z,FRENUM        ; Numeric - Free variable space
2380+  1396 CD 0A 16            CALL    GSTRCU          ; Current string to pool
2381+  1399 CD 0A 15            CALL    GARBGE          ; Garbage collection
2382+  139C 2A 0A 31            LD      HL,(STRSPC)     ; Bottom of string space in use
2383+  139F EB                  EX      DE,HL           ; To DE
2384+  13A0 2A 73 31            LD      HL,(STRBOT)     ; Bottom of string space
2385+  13A3 7D          FRENUM: LD      A,L             ; Get LSB of end
2386+  13A4 93                  SUB     E               ; Subtract LSB of beginning
2387+  13A5 4F                  LD      C,A             ; Save difference if C
2388+  13A6 7C                  LD      A,H             ; Get MSB of end
2389+  13A7 9A                  SBC     A,D             ; Subtract MSB of beginning
2390+  13A8 41          ACPASS: LD      B,C             ; Return integer AC
2391+  13A9 50          ABPASS: LD      D,B             ; Return integer AB
2392+  13AA 1E 00               LD      E,0
2393+  13AC 21 5D 31            LD      HL,TYPE         ; Point to type
2394+  13AF 73                  LD      (HL),E          ; Set type to numeric
2395+  13B0 06 90               LD      B,80H+16        ; 16 bit integer
2396+  13B2 C3 E7 19            JP      RETINT          ; Return the integr
2397+  13B5             
2398+  13B5 3A 5B 31    POS:    LD      A,(CURPOS)      ; Get cursor position
2399+  13B8 47          PASSA:  LD      B,A             ; Put A into AB
2400+  13B9 AF                  XOR     A               ; Zero A
2401+  13BA C3 A9 13            JP      ABPASS          ; Return integer AB
2402+  13BD             
2403+  13BD CD 40 14    DEF:    CALL    CHEKFN          ; Get "FN" and name
2404+  13C0 CD 32 14            CALL    IDTEST          ; Test for illegal direct
2405+  13C3 01 18 0D            LD      BC,DATA         ; To get next statement
2406+  13C6 C5                  PUSH    BC              ; Save address for RETurn
2407+  13C7 D5                  PUSH    DE              ; Save address of function ptr
2408+  13C8 CD F7 09            CALL    CHKSYN          ; Make sure "(" follows
2409+  13CB 28                  .BYTE      "("
2410+  13CC CD E4 11            CALL    GETVAR          ; Get argument variable name
2411+  13CF E5                  PUSH    HL              ; Save code string address
2412+  13D0 EB                  EX      DE,HL           ; Argument address to HL
2413+  13D1 2B                  DEC     HL
2414+  13D2 56                  LD      D,(HL)          ; Get first byte of arg name
2415+  13D3 2B                  DEC     HL
2416+  13D4 5E                  LD      E,(HL)          ; Get second byte of arg name
2417+  13D5 E1                  POP     HL              ; Restore code string address
2418+  13D6 CD F1 0F            CALL    TSTNUM          ; Make sure numeric argument
2419+  13D9 CD F7 09            CALL    CHKSYN          ; Make sure ")" follows
2420+  13DC 29                  .BYTE      ")"
2421+  13DD CD F7 09            CALL    CHKSYN          ; Make sure "=" follows
2422+  13E0 B4                  .BYTE      ZEQUAL          ; "=" token
2423+  13E1 44                  LD      B,H             ; Code string address to BC
2424+  13E2 4D                  LD      C,L
2425+  13E3 E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2426+  13E4 71                  LD      (HL),C          ; Save LSB of FN code string
2427+  13E5 23                  INC     HL
2428+  13E6 70                  LD      (HL),B          ; Save MSB of FN code string
2429+  13E7 C3 7F 14            JP      SVSTAD          ; Save address and do function
2430+  13EA             
2431+  13EA CD 40 14    DOFN:   CALL    CHEKFN          ; Make sure FN follows
2432+  13ED D5                  PUSH    DE              ; Save function pointer address
2433+  13EE CD C5 10            CALL    EVLPAR          ; Evaluate expression in "()"
2434+  13F1 CD F1 0F            CALL    TSTNUM          ; Make sure numeric result
2435+  13F4 E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2436+  13F5 5E                  LD      E,(HL)          ; Get LSB of FN code string
2437+  13F6 23                  INC     HL
2438+  13F7 56                  LD      D,(HL)          ; Get MSB of FN code string
2439+  13F8 23                  INC     HL
2440+  13F9 7A                  LD      A,D             ; And function DEFined?
2441+  13FA B3                  OR      E
2442+  13FB CA 35 07            JP      Z,UFERR         ; No - ?UF Error
2443+  13FE 7E                  LD      A,(HL)          ; Get LSB of argument address
2444+  13FF 23                  INC     HL
2445+  1400 66                  LD      H,(HL)          ; Get MSB of argument address
2446+  1401 6F                  LD      L,A             ; HL = Arg variable address
2447+  1402 E5                  PUSH    HL              ; Save it
2448+  1403 2A 8E 31            LD      HL,(FNRGNM)     ; Get old argument name
2449+  1406 E3                  EX      (SP),HL ;       ; Save old , Get new
2450+  1407 22 8E 31            LD      (FNRGNM),HL     ; Set new argument name
2451+  140A 2A 92 31            LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2452+  140D E5                  PUSH    HL              ; Save it
2453+  140E 2A 90 31            LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
2454+  1411 E5                  PUSH    HL              ; Save it
2455+  1412 21 90 31            LD      HL,FNARG        ; HL = Value of argument
2456+  1415 D5                  PUSH    DE              ; Save FN code string address
2457+  1416 CD 28 1A            CALL    FPTHL           ; Move FPREG to argument
2458+  1419 E1                  POP     HL              ; Get FN code string address
2459+  141A CD EE 0F            CALL    GETNUM          ; Get value from function
2460+  141D 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2461+  141E CD 81 0B            CALL    GETCHR          ; Get next character
2462+  1421 C2 29 07            JP      NZ,SNERR        ; Bad character in FN - Error
2463+  1424 E1                  POP     HL              ; Get MSB,EXP of old arg
2464+  1425 22 90 31            LD      (FNARG),HL      ; Restore it
2465+  1428 E1                  POP     HL              ; Get LSB,NLSB of old arg
2466+  1429 22 92 31            LD      (FNARG+2),HL    ; Restore it
2467+  142C E1                  POP     HL              ; Get name of old arg
2468+  142D 22 8E 31            LD      (FNRGNM),HL     ; Restore it
2469+  1430 E1                  POP     HL              ; Restore code string address
2470+  1431 C9                  RET
2471+  1432             
2472+  1432 E5          IDTEST: PUSH    HL              ; Save code string address
2473+  1433 2A 0C 31            LD      HL,(LINEAT)     ; Get current line number
2474+  1436 23                  INC     HL              ; -1 means direct statement
2475+  1437 7C                  LD      A,H
2476+  1438 B5                  OR      L
2477+  1439 E1                  POP     HL              ; Restore code string address
2478+  143A C0                  RET     NZ              ; Return if in program
2479+  143B 1E 16               LD      E,ID            ; ?ID Error
2480+  143D C3 3D 07            JP      ERROR
2481+  1440             
2482+  1440 CD F7 09    CHEKFN: CALL    CHKSYN          ; Make sure FN follows
2483+  1443 A7                  .BYTE      ZFN             ; "FN" token
2484+  1444 3E 80               LD      A,80H
2485+  1446 32 7B 31            LD      (FORFLG),A      ; Flag FN name to find
2486+  1449 B6                  OR      (HL)            ; FN name has bit 7 set
2487+  144A 47                  LD      B,A             ; in first byte of name
2488+  144B CD E9 11            CALL    GTFNAM          ; Get FN name
2489+  144E C3 F1 0F            JP      TSTNUM          ; Make sure numeric function
2490+  1451             
2491+  1451 CD F1 0F    STR:    CALL    TSTNUM          ; Make sure it's a number
2492+  1454 CD 75 1B            CALL    NUMASC          ; Turn number into text
2493+  1457 CD 85 14    STR1:   CALL    CRTST           ; Create string entry for it
2494+  145A CD 0A 16            CALL    GSTRCU          ; Current string to pool
2495+  145D 01 65 16            LD      BC,TOPOOL       ; Save in string pool
2496+  1460 C5                  PUSH    BC              ; Save address on stack
2497+  1461             
2498+  1461 7E          SAVSTR: LD      A,(HL)          ; Get string length
2499+  1462 23                  INC     HL
2500+  1463 23                  INC     HL
2501+  1464 E5                  PUSH    HL              ; Save pointer to string
2502+  1465 CD E0 14            CALL    TESTR           ; See if enough string space
2503+  1468 E1                  POP     HL              ; Restore pointer to string
2504+  1469 4E                  LD      C,(HL)          ; Get LSB of address
2505+  146A 23                  INC     HL
2506+  146B 46                  LD      B,(HL)          ; Get MSB of address
2507+  146C CD 79 14            CALL    CRTMST          ; Create string entry
2508+  146F E5                  PUSH    HL              ; Save pointer to MSB of addr
2509+  1470 6F                  LD      L,A             ; Length of string
2510+  1471 CD FD 15            CALL    TOSTRA          ; Move to string area
2511+  1474 D1                  POP     DE              ; Restore pointer to MSB
2512+  1475 C9                  RET
2513+  1476             
2514+  1476 CD E0 14    MKTMST: CALL    TESTR           ; See if enough string space
2515+  1479 21 6F 31    CRTMST: LD      HL,TMPSTR       ; Temporary string
2516+  147C E5                  PUSH    HL              ; Save it
2517+  147D 77                  LD      (HL),A          ; Save length of string
2518+  147E 23                  INC     HL
2519+  147F 23          SVSTAD: INC     HL
2520+  1480 73                  LD      (HL),E          ; Save LSB of address
2521+  1481 23                  INC     HL
2522+  1482 72                  LD      (HL),D          ; Save MSB of address
2523+  1483 E1                  POP     HL              ; Restore pointer
2524+  1484 C9                  RET
2525+  1485             
2526+  1485 2B          CRTST:  DEC     HL              ; DEC - INCed after
2527+  1486 06 22       QTSTR:  LD      B,'"'           ; Terminating quote
2528+  1488 50                  LD      D,B             ; Quote to D
2529+  1489 E5          DTSTR:  PUSH    HL              ; Save start
2530+  148A 0E FF               LD      C,-1            ; Set counter to -1
2531+  148C 23          QTSTLP: INC     HL              ; Move on
2532+  148D 7E                  LD      A,(HL)          ; Get byte
2533+  148E 0C                  INC     C               ; Count bytes
2534+  148F B7                  OR      A               ; End of line?
2535+  1490 CA 9B 14            JP      Z,CRTSTE        ; Yes - Create string entry
2536+  1493 BA                  CP      D               ; Terminator D found?
2537+  1494 CA 9B 14            JP      Z,CRTSTE        ; Yes - Create string entry
2538+  1497 B8                  CP      B               ; Terminator B found?
2539+  1498 C2 8C 14            JP      NZ,QTSTLP       ; No - Keep looking
2540+  149B FE 22       CRTSTE: CP      '"'             ; End with '"'?
2541+  149D CC 81 0B            CALL    Z,GETCHR        ; Yes - Get next character
2542+  14A0 E3                  EX      (SP),HL         ; Starting quote
2543+  14A1 23                  INC     HL              ; First byte of string
2544+  14A2 EB                  EX      DE,HL           ; To DE
2545+  14A3 79                  LD      A,C             ; Get length
2546+  14A4 CD 79 14            CALL    CRTMST          ; Create string entry
2547+  14A7 11 6F 31    TSTOPL: LD      DE,TMPSTR       ; Temporary string
2548+  14AA 2A 61 31            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2549+  14AD 22 94 31            LD      (FPREG),HL      ; Save address of string ptr
2550+  14B0 3E 01               LD      A,1
2551+  14B2 32 5D 31            LD      (TYPE),A        ; Set type to string
2552+  14B5 CD 2B 1A            CALL    DETHL4          ; Move string to pool
2553+  14B8 CD F1 09            CALL    CPDEHL          ; Out of string pool?
2554+  14BB 22 61 31            LD      (TMSTPT),HL     ; Save new pointer
2555+  14BE E1                  POP     HL              ; Restore code string address
2556+  14BF 7E                  LD      A,(HL)          ; Get next code byte
2557+  14C0 C0                  RET     NZ              ; Return if pool OK
2558+  14C1 1E 1E               LD      E,ST            ; ?ST Error
2559+  14C3 C3 3D 07            JP      ERROR           ; String pool overflow
2560+  14C6             
2561+  14C6 23          PRNUMS: INC     HL              ; Skip leading space
2562+  14C7 CD 85 14    PRS:    CALL    CRTST           ; Create string entry for it
2563+  14CA CD 0A 16    PRS1:   CALL    GSTRCU          ; Current string to pool
2564+  14CD CD 1F 1A            CALL    LOADFP          ; Move string block to BCDE
2565+  14D0 1C                  INC     E               ; Length + 1
2566+  14D1 1D          PRSLP:  DEC     E               ; Count characters
2567+  14D2 C8                  RET     Z               ; End of string
2568+  14D3 0A                  LD      A,(BC)          ; Get byte to output
2569+  14D4 CD 02 0A            CALL    OUTC            ; Output character in A
2570+  14D7 FE 0D               CP      CR              ; Return?
2571+  14D9 CC 33 0E            CALL    Z,DONULL        ; Yes - Do nulls
2572+  14DC 03                  INC     BC              ; Next byte in string
2573+  14DD C3 D1 14            JP      PRSLP           ; More characters to output
2574+  14E0             
2575+  14E0 B7          TESTR:  OR      A               ; Test if enough room
2576+  14E1 0E                  .BYTE      0EH             ; No garbage collection done
2577+  14E2 F1          GRBDON: POP     AF              ; Garbage collection done
2578+  14E3 F5                  PUSH    AF              ; Save status
2579+  14E4 2A 0A 31            LD      HL,(STRSPC)     ; Bottom of string space in use
2580+  14E7 EB                  EX      DE,HL           ; To DE
2581+  14E8 2A 73 31            LD      HL,(STRBOT)     ; Bottom of string area
2582+  14EB 2F                  CPL                     ; Negate length (Top down)
2583+  14EC 4F                  LD      C,A             ; -Length to BC
2584+  14ED 06 FF               LD      B,-1            ; BC = -ve length of string
2585+  14EF 09                  ADD     HL,BC           ; Add to bottom of space in use
2586+  14F0 23                  INC     HL              ; Plus one for 2's complement
2587+  14F1 CD F1 09            CALL    CPDEHL          ; Below string RAM area?
2588+  14F4 DA FE 14            JP      C,TESTOS        ; Tidy up if not done else err
2589+  14F7 22 73 31            LD      (STRBOT),HL     ; Save new bottom of area
2590+  14FA 23                  INC     HL              ; Point to first byte of string
2591+  14FB EB                  EX      DE,HL           ; Address to DE
2592+  14FC F1          POPAF:  POP     AF              ; Throw away status push
2593+  14FD C9                  RET
2594+  14FE             
2595+  14FE F1          TESTOS: POP     AF              ; Garbage collect been done?
2596+  14FF 1E 1A               LD      E,OS            ; ?OS Error
2597+  1501 CA 3D 07            JP      Z,ERROR         ; Yes - Not enough string apace
2598+  1504 BF                  CP      A               ; Flag garbage collect done
2599+  1505 F5                  PUSH    AF              ; Save status
2600+  1506 01 E2 14            LD      BC,GRBDON       ; Garbage collection done
2601+  1509 C5                  PUSH    BC              ; Save for RETurn
2602+  150A 2A 5F 31    GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
2603+  150D 22 73 31    GARBLP: LD      (STRBOT),HL     ; Reset string pointer
2604+  1510 21 00 00            LD      HL,0
2605+  1513 E5                  PUSH    HL              ; Flag no string found
2606+  1514 2A 0A 31            LD      HL,(STRSPC)     ; Get bottom of string space
2607+  1517 E5                  PUSH    HL              ; Save bottom of string space
2608+  1518 21 63 31            LD      HL,TMSTPL       ; Temporary string pool
2609+  151B EB          GRBLP:  EX      DE,HL
2610+  151C 2A 61 31            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2611+  151F EB                  EX      DE,HL
2612+  1520 CD F1 09            CALL    CPDEHL          ; Temporary string pool done?
2613+  1523 01 1B 15            LD      BC,GRBLP        ; Loop until string pool done
2614+  1526 C2 6F 15            JP      NZ,STPOOL       ; No - See if in string area
2615+  1529 2A 86 31            LD      HL,(PROGND)     ; Start of simple variables
2616+  152C EB          SMPVAR: EX      DE,HL
2617+  152D 2A 88 31            LD      HL,(VAREND)     ; End of simple variables
2618+  1530 EB                  EX      DE,HL
2619+  1531 CD F1 09            CALL    CPDEHL          ; All simple strings done?
2620+  1534 CA 42 15            JP      Z,ARRLP         ; Yes - Do string arrays
2621+  1537 7E                  LD      A,(HL)          ; Get type of variable
2622+  1538 23                  INC     HL
2623+  1539 23                  INC     HL
2624+  153A B7                  OR      A               ; "S" flag set if string
2625+  153B CD 72 15            CALL    STRADD          ; See if string in string area
2626+  153E C3 2C 15            JP      SMPVAR          ; Loop until simple ones done
2627+  1541             
2628+  1541 C1          GNXARY: POP     BC              ; Scrap address of this array
2629+  1542 EB          ARRLP:  EX      DE,HL
2630+  1543 2A 8A 31            LD      HL,(ARREND)     ; End of string arrays
2631+  1546 EB                  EX      DE,HL
2632+  1547 CD F1 09            CALL    CPDEHL          ; All string arrays done?
2633+  154A CA 98 15            JP      Z,SCNEND        ; Yes - Move string if found
2634+  154D CD 1F 1A            CALL    LOADFP          ; Get array name to BCDE
2635+  1550 7B                  LD      A,E             ; Get type of array     
2636+  1551 E5                  PUSH    HL              ; Save address of num of dim'ns
2637+  1552 09                  ADD     HL,BC           ; Start of next array
2638+  1553 B7                  OR      A               ; Test type of array
2639+  1554 F2 41 15            JP      P,GNXARY        ; Numeric array - Ignore it
2640+  1557 22 75 31            LD      (CUROPR),HL     ; Save address of next array
2641+  155A E1                  POP     HL              ; Get address of num of dim'ns
2642+  155B 4E                  LD      C,(HL)          ; BC = Number of dimensions
2643+  155C 06 00               LD      B,0
2644+  155E 09                  ADD     HL,BC           ; Two bytes per dimension size
2645+  155F 09                  ADD     HL,BC
2646+  1560 23                  INC     HL              ; Plus one for number of dim'ns
2647+  1561 EB          GRBARY: EX      DE,HL
2648+  1562 2A 75 31            LD      HL,(CUROPR)     ; Get address of next array
2649+  1565 EB                  EX      DE,HL
2650+  1566 CD F1 09            CALL    CPDEHL          ; Is this array finished?
2651+  1569 CA 42 15            JP      Z,ARRLP         ; Yes - Get next one
2652+  156C 01 61 15            LD      BC,GRBARY       ; Loop until array all done
2653+  156F C5          STPOOL: PUSH    BC              ; Save return address
2654+  1570 F6 80               OR      80H             ; Flag string type
2655+  1572 7E          STRADD: LD      A,(HL)          ; Get string length
2656+  1573 23                  INC     HL
2657+  1574 23                  INC     HL
2658+  1575 5E                  LD      E,(HL)          ; Get LSB of string address
2659+  1576 23                  INC     HL
2660+  1577 56                  LD      D,(HL)          ; Get MSB of string address
2661+  1578 23                  INC     HL
2662+  1579 F0                  RET     P               ; Not a string - Return
2663+  157A B7                  OR      A               ; Set flags on string length
2664+  157B C8                  RET     Z               ; Null string - Return
2665+  157C 44                  LD      B,H             ; Save variable pointer
2666+  157D 4D                  LD      C,L
2667+  157E 2A 73 31            LD      HL,(STRBOT)     ; Bottom of new area
2668+  1581 CD F1 09            CALL    CPDEHL          ; String been done?
2669+  1584 60                  LD      H,B             ; Restore variable pointer
2670+  1585 69                  LD      L,C
2671+  1586 D8                  RET     C               ; String done - Ignore
2672+  1587 E1                  POP     HL              ; Return address
2673+  1588 E3                  EX      (SP),HL         ; Lowest available string area
2674+  1589 CD F1 09            CALL    CPDEHL          ; String within string area?
2675+  158C E3                  EX      (SP),HL         ; Lowest available string area
2676+  158D E5                  PUSH    HL              ; Re-save return address
2677+  158E 60                  LD      H,B             ; Restore variable pointer
2678+  158F 69                  LD      L,C
2679+  1590 D0                  RET     NC              ; Outside string area - Ignore
2680+  1591 C1                  POP     BC              ; Get return , Throw 2 away
2681+  1592 F1                  POP     AF              ; 
2682+  1593 F1                  POP     AF              ; 
2683+  1594 E5                  PUSH    HL              ; Save variable pointer
2684+  1595 D5                  PUSH    DE              ; Save address of current
2685+  1596 C5                  PUSH    BC              ; Put back return address
2686+  1597 C9                  RET                     ; Go to it
2687+  1598             
2688+  1598 D1          SCNEND: POP     DE              ; Addresses of strings
2689+  1599 E1                  POP     HL              ; 
2690+  159A 7D                  LD      A,L             ; HL = 0 if no more to do
2691+  159B B4                  OR      H
2692+  159C C8                  RET     Z               ; No more to do - Return
2693+  159D 2B                  DEC     HL
2694+  159E 46                  LD      B,(HL)          ; MSB of address of string
2695+  159F 2B                  DEC     HL
2696+  15A0 4E                  LD      C,(HL)          ; LSB of address of string
2697+  15A1 E5                  PUSH    HL              ; Save variable address
2698+  15A2 2B                  DEC     HL
2699+  15A3 2B                  DEC     HL
2700+  15A4 6E                  LD      L,(HL)          ; HL = Length of string
2701+  15A5 26 00               LD      H,0
2702+  15A7 09                  ADD     HL,BC           ; Address of end of string+1
2703+  15A8 50                  LD      D,B             ; String address to DE
2704+  15A9 59                  LD      E,C
2705+  15AA 2B                  DEC     HL              ; Last byte in string
2706+  15AB 44                  LD      B,H             ; Address to BC
2707+  15AC 4D                  LD      C,L
2708+  15AD 2A 73 31            LD      HL,(STRBOT)     ; Current bottom of string area
2709+  15B0 CD F8 06            CALL    MOVSTR          ; Move string to new address
2710+  15B3 E1                  POP     HL              ; Restore variable address
2711+  15B4 71                  LD      (HL),C          ; Save new LSB of address
2712+  15B5 23                  INC     HL
2713+  15B6 70                  LD      (HL),B          ; Save new MSB of address
2714+  15B7 69                  LD      L,C             ; Next string area+1 to HL
2715+  15B8 60                  LD      H,B
2716+  15B9 2B                  DEC     HL              ; Next string area address
2717+  15BA C3 0D 15            JP      GARBLP          ; Look for more strings
2718+  15BD             
2719+  15BD C5          CONCAT: PUSH    BC              ; Save prec' opr & code string
2720+  15BE E5                  PUSH    HL              ; 
2721+  15BF 2A 94 31            LD      HL,(FPREG)      ; Get first string
2722+  15C2 E3                  EX      (SP),HL         ; Save first string
2723+  15C3 CD 77 10            CALL    OPRND           ; Get second string
2724+  15C6 E3                  EX      (SP),HL         ; Restore first string
2725+  15C7 CD F2 0F            CALL    TSTSTR          ; Make sure it's a string
2726+  15CA 7E                  LD      A,(HL)          ; Get length of second string
2727+  15CB E5                  PUSH    HL              ; Save first string
2728+  15CC 2A 94 31            LD      HL,(FPREG)      ; Get second string
2729+  15CF E5                  PUSH    HL              ; Save second string
2730+  15D0 86                  ADD     A,(HL)          ; Add length of second string
2731+  15D1 1E 1C               LD      E,LS            ; ?LS Error
2732+  15D3 DA 3D 07            JP      C,ERROR         ; String too long - Error
2733+  15D6 CD 76 14            CALL    MKTMST          ; Make temporary string
2734+  15D9 D1                  POP     DE              ; Get second string to DE
2735+  15DA CD 0E 16            CALL    GSTRDE          ; Move to string pool if needed
2736+  15DD E3                  EX      (SP),HL         ; Get first string
2737+  15DE CD 0D 16            CALL    GSTRHL          ; Move to string pool if needed
2738+  15E1 E5                  PUSH    HL              ; Save first string
2739+  15E2 2A 71 31            LD      HL,(TMPSTR+2)   ; Temporary string address
2740+  15E5 EB                  EX      DE,HL           ; To DE
2741+  15E6 CD F4 15            CALL    SSTSA           ; First string to string area
2742+  15E9 CD F4 15            CALL    SSTSA           ; Second string to string area
2743+  15EC 21 0C 10            LD      HL,EVAL2        ; Return to evaluation loop
2744+  15EF E3                  EX      (SP),HL         ; Save return,get code string
2745+  15F0 E5                  PUSH    HL              ; Save code string address
2746+  15F1 C3 A7 14            JP      TSTOPL          ; To temporary string to pool
2747+  15F4             
2748+  15F4 E1          SSTSA:  POP     HL              ; Return address
2749+  15F5 E3                  EX      (SP),HL         ; Get string block,save return
2750+  15F6 7E                  LD      A,(HL)          ; Get length of string
2751+  15F7 23                  INC     HL
2752+  15F8 23                  INC     HL
2753+  15F9 4E                  LD      C,(HL)          ; Get LSB of string address
2754+  15FA 23                  INC     HL
2755+  15FB 46                  LD      B,(HL)          ; Get MSB of string address
2756+  15FC 6F                  LD      L,A             ; Length to L
2757+  15FD 2C          TOSTRA: INC     L               ; INC - DECed after
2758+  15FE 2D          TSALP:  DEC     L               ; Count bytes moved
2759+  15FF C8                  RET     Z               ; End of string - Return
2760+  1600 0A                  LD      A,(BC)          ; Get source
2761+  1601 12                  LD      (DE),A          ; Save destination
2762+  1602 03                  INC     BC              ; Next source
2763+  1603 13                  INC     DE              ; Next destination
2764+  1604 C3 FE 15            JP      TSALP           ; Loop until string moved
2765+  1607             
2766+  1607 CD F2 0F    GETSTR: CALL    TSTSTR          ; Make sure it's a string
2767+  160A 2A 94 31    GSTRCU: LD      HL,(FPREG)      ; Get current string
2768+  160D EB          GSTRHL: EX      DE,HL           ; Save DE
2769+  160E CD 28 16    GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
2770+  1611 EB                  EX      DE,HL           ; Restore DE
2771+  1612 C0                  RET     NZ              ; No - Return
2772+  1613 D5                  PUSH    DE              ; Save string
2773+  1614 50                  LD      D,B             ; String block address to DE
2774+  1615 59                  LD      E,C
2775+  1616 1B                  DEC     DE              ; Point to length
2776+  1617 4E                  LD      C,(HL)          ; Get string length
2777+  1618 2A 73 31            LD      HL,(STRBOT)     ; Current bottom of string area
2778+  161B CD F1 09            CALL    CPDEHL          ; Last one in string area?
2779+  161E C2 26 16            JP      NZ,POPHL        ; No - Return
2780+  1621 47                  LD      B,A             ; Clear B (A=0)
2781+  1622 09                  ADD     HL,BC           ; Remove string from str' area
2782+  1623 22 73 31            LD      (STRBOT),HL     ; Save new bottom of str' area
2783+  1626 E1          POPHL:  POP     HL              ; Restore string
2784+  1627 C9                  RET
2785+  1628             
2786+  1628 2A 61 31    BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
2787+  162B 2B                  DEC     HL              ; Back
2788+  162C 46                  LD      B,(HL)          ; Get MSB of address
2789+  162D 2B                  DEC     HL              ; Back
2790+  162E 4E                  LD      C,(HL)          ; Get LSB of address
2791+  162F 2B                  DEC     HL              ; Back
2792+  1630 2B                  DEC     HL              ; Back
2793+  1631 CD F1 09            CALL    CPDEHL          ; String last in string pool?
2794+  1634 C0                  RET     NZ              ; Yes - Leave it
2795+  1635 22 61 31            LD      (TMSTPT),HL     ; Save new string pool top
2796+  1638 C9                  RET
2797+  1639             
2798+  1639 01 B8 13    LEN:    LD      BC,PASSA        ; To return integer A
2799+  163C C5                  PUSH    BC              ; Save address
2800+  163D CD 07 16    GETLEN: CALL    GETSTR          ; Get string and its length
2801+  1640 AF                  XOR     A
2802+  1641 57                  LD      D,A             ; Clear D
2803+  1642 32 5D 31            LD      (TYPE),A        ; Set type to numeric
2804+  1645 7E                  LD      A,(HL)          ; Get length of string
2805+  1646 B7                  OR      A               ; Set status flags
2806+  1647 C9                  RET
2807+  1648             
2808+  1648 01 B8 13    ASC:    LD      BC,PASSA        ; To return integer A
2809+  164B C5                  PUSH    BC              ; Save address
2810+  164C CD 3D 16    GTFLNM: CALL    GETLEN          ; Get length of string
2811+  164F CA 48 0C            JP      Z,FCERR         ; Null string - Error
2812+  1652 23                  INC     HL
2813+  1653 23                  INC     HL
2814+  1654 5E                  LD      E,(HL)          ; Get LSB of address
2815+  1655 23                  INC     HL
2816+  1656 56                  LD      D,(HL)          ; Get MSB of address
2817+  1657 1A                  LD      A,(DE)          ; Get first byte of string
2818+  1658 C9                  RET
2819+  1659             
2820+  1659 3E 01       CHR:    LD      A,1             ; One character string
2821+  165B CD 76 14            CALL    MKTMST          ; Make a temporary string
2822+  165E CD 52 17            CALL    MAKINT          ; Make it integer A
2823+  1661 2A 71 31            LD      HL,(TMPSTR+2)   ; Get address of string
2824+  1664 73                  LD      (HL),E          ; Save character
2825+  1665 C1          TOPOOL: POP     BC              ; Clean up stack
2826+  1666 C3 A7 14            JP      TSTOPL          ; Temporary string to pool
2827+  1669             
2828+  1669 CD 02 17    LEFT:   CALL    LFRGNM          ; Get number and ending ")"
2829+  166C AF                  XOR     A               ; Start at first byte in string
2830+  166D E3          RIGHT1: EX      (SP),HL         ; Save code string,Get string
2831+  166E 4F                  LD      C,A             ; Starting position in string
2832+  166F E5          MID1:   PUSH    HL              ; Save string block address
2833+  1670 7E                  LD      A,(HL)          ; Get length of string
2834+  1671 B8                  CP      B               ; Compare with number given
2835+  1672 DA 77 16            JP      C,ALLFOL        ; All following bytes required
2836+  1675 78                  LD      A,B             ; Get new length
2837+  1676 11                  .BYTE      11H             ; Skip "LD C,0"
2838+  1677 0E 00       ALLFOL: LD      C,0             ; First byte of string
2839+  1679 C5                  PUSH    BC              ; Save position in string
2840+  167A CD E0 14            CALL    TESTR           ; See if enough string space
2841+  167D C1                  POP     BC              ; Get position in string
2842+  167E E1                  POP     HL              ; Restore string block address
2843+  167F E5                  PUSH    HL              ; And re-save it
2844+  1680 23                  INC     HL
2845+  1681 23                  INC     HL
2846+  1682 46                  LD      B,(HL)          ; Get LSB of address
2847+  1683 23                  INC     HL
2848+  1684 66                  LD      H,(HL)          ; Get MSB of address
2849+  1685 68                  LD      L,B             ; HL = address of string
2850+  1686 06 00               LD      B,0             ; BC = starting address
2851+  1688 09                  ADD     HL,BC           ; Point to that byte
2852+  1689 44                  LD      B,H             ; BC = source string
2853+  168A 4D                  LD      C,L
2854+  168B CD 79 14            CALL    CRTMST          ; Create a string entry
2855+  168E 6F                  LD      L,A             ; Length of new string
2856+  168F CD FD 15            CALL    TOSTRA          ; Move string to string area
2857+  1692 D1                  POP     DE              ; Clear stack
2858+  1693 CD 0E 16            CALL    GSTRDE          ; Move to string pool if needed
2859+  1696 C3 A7 14            JP      TSTOPL          ; Temporary string to pool
2860+  1699             
2861+  1699 CD 02 17    RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
2862+  169C D1                  POP     DE              ; Get string length
2863+  169D D5                  PUSH    DE              ; And re-save
2864+  169E 1A                  LD      A,(DE)          ; Get length
2865+  169F 90                  SUB     B               ; Move back N bytes
2866+  16A0 C3 6D 16            JP      RIGHT1          ; Go and get sub-string
2867+  16A3             
2868+  16A3 EB          MID:    EX      DE,HL           ; Get code string address
2869+  16A4 7E                  LD      A,(HL)          ; Get next byte ',' or ")"
2870+  16A5 CD 07 17            CALL    MIDNUM          ; Get number supplied
2871+  16A8 04                  INC     B               ; Is it character zero?
2872+  16A9 05                  DEC     B
2873+  16AA CA 48 0C            JP      Z,FCERR         ; Yes - Error
2874+  16AD C5                  PUSH    BC              ; Save starting position
2875+  16AE 1E FF               LD      E,255           ; All of string
2876+  16B0 FE 29               CP      ')'             ; Any length given?
2877+  16B2 CA BC 16            JP      Z,RSTSTR        ; No - Rest of string
2878+  16B5 CD F7 09            CALL    CHKSYN          ; Make sure ',' follows
2879+  16B8 2C                  .BYTE      ','
2880+  16B9 CD 4F 17            CALL    GETINT          ; Get integer 0-255
2881+  16BC CD F7 09    RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
2882+  16BF 29                  .BYTE      ")"
2883+  16C0 F1                  POP     AF              ; Restore starting position
2884+  16C1 E3                  EX      (SP),HL         ; Get string,8ave code string
2885+  16C2 01 6F 16            LD      BC,MID1         ; Continuation of MID$ routine
2886+  16C5 C5                  PUSH    BC              ; Save for return
2887+  16C6 3D                  DEC     A               ; Starting position-1
2888+  16C7 BE                  CP      (HL)            ; Compare with length
2889+  16C8 06 00               LD      B,0             ; Zero bytes length
2890+  16CA D0                  RET     NC              ; Null string if start past end
2891+  16CB 4F                  LD      C,A             ; Save starting position-1
2892+  16CC 7E                  LD      A,(HL)          ; Get length of string
2893+  16CD 91                  SUB     C               ; Subtract start
2894+  16CE BB                  CP      E               ; Enough string for it?
2895+  16CF 47                  LD      B,A             ; Save maximum length available
2896+  16D0 D8                  RET     C               ; Truncate string if needed
2897+  16D1 43                  LD      B,E             ; Set specified length
2898+  16D2 C9                  RET                     ; Go and create string
2899+  16D3             
2900+  16D3 CD 3D 16    VAL:    CALL    GETLEN          ; Get length of string
2901+  16D6 CA F0 17            JP      Z,RESZER        ; Result zero
2902+  16D9 5F                  LD      E,A             ; Save length
2903+  16DA 23                  INC     HL
2904+  16DB 23                  INC     HL
2905+  16DC 7E                  LD      A,(HL)          ; Get LSB of address
2906+  16DD 23                  INC     HL
2907+  16DE 66                  LD      H,(HL)          ; Get MSB of address
2908+  16DF 6F                  LD      L,A             ; HL = String address
2909+  16E0 E5                  PUSH    HL              ; Save string address
2910+  16E1 19                  ADD     HL,DE
2911+  16E2 46                  LD      B,(HL)          ; Get end of string+1 byte
2912+  16E3 72                  LD      (HL),D          ; Zero it to terminate
2913+  16E4 E3                  EX      (SP),HL         ; Save string end,get start
2914+  16E5 C5                  PUSH    BC              ; Save end+1 byte
2915+  16E6 7E                  LD      A,(HL)          ; Get starting byte
2916+  16E7 FE 24           CP	'$'		; Hex number indicated? [function added]
2917+  16E9 C2 F1 16        JP	NZ,VAL1
2918+  16EC CD 1B 1F        CALL	HEXTFP		; Convert Hex to FPREG
2919+  16EF 18 0D           JR	VAL3
2920+  16F1 FE 25       VAL1:	CP	'%'		; Binary number indicated? [function added]
2921+  16F3 C2 FB 16        JP	NZ,VAL2
2922+  16F6 CD 8B 1F        CALL	BINTFP		; Convert Bin to FPREG
2923+  16F9 18 03           JR	VAL3
2924+  16FB CD D7 1A    VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
2925+  16FE C1          VAL3:   POP     BC              ; Restore end+1 byte
2926+  16FF E1                  POP     HL              ; Restore end+1 address
2927+  1700 70                  LD      (HL),B          ; Put back original byte
2928+  1701 C9                  RET
2929+  1702             
2930+  1702 EB          LFRGNM: EX      DE,HL           ; Code string address to HL
2931+  1703 CD F7 09            CALL    CHKSYN          ; Make sure ")" follows
2932+  1706 29                  .BYTE      ")"
2933+  1707 C1          MIDNUM: POP     BC              ; Get return address
2934+  1708 D1                  POP     DE              ; Get number supplied
2935+  1709 C5                  PUSH    BC              ; Re-save return address
2936+  170A 43                  LD      B,E             ; Number to B
2937+  170B C9                  RET
2938+  170C             
2939+  170C CD 52 17    INP:    CALL    MAKINT          ; Make it integer A
2940+  170F 32 EF 30            LD      (INPORT),A      ; Set input port
2941+  1712 CD EE 30            CALL    INPSUB          ; Get input from port
2942+  1715 C3 B8 13            JP      PASSA           ; Return integer A
2943+  1718             
2944+  1718 CD 3C 17    POUT:   CALL    SETIO           ; Set up port number
2945+  171B C3 B6 30            JP      OUTSUB          ; Output data and return
2946+  171E             
2947+  171E CD 3C 17    WAIT:   CALL    SETIO           ; Set up port number
2948+  1721 F5                  PUSH    AF              ; Save AND mask
2949+  1722 1E 00               LD      E,0             ; Assume zero if none given
2950+  1724 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2951+  1725 CD 81 0B            CALL    GETCHR          ; Get next character
2952+  1728 CA 32 17            JP      Z,NOXOR         ; No XOR byte given
2953+  172B CD F7 09            CALL    CHKSYN          ; Make sure ',' follows
2954+  172E 2C                  .BYTE      ','
2955+  172F CD 4F 17            CALL    GETINT          ; Get integer 0-255 to XOR with
2956+  1732 C1          NOXOR:  POP     BC              ; Restore AND mask
2957+  1733 CD EE 30    WAITLP: CALL    INPSUB          ; Get input
2958+  1736 AB                  XOR     E               ; Flip selected bits
2959+  1737 A0                  AND     B               ; Result non-zero?
2960+  1738 CA 33 17            JP      Z,WAITLP        ; No = keep waiting
2961+  173B C9                  RET
2962+  173C             
2963+  173C CD 4F 17    SETIO:  CALL    GETINT          ; Get integer 0-255
2964+  173F 32 EF 30            LD      (INPORT),A      ; Set input port
2965+  1742 32 B7 30            LD      (OTPORT),A      ; Set output port
2966+  1745 CD F7 09            CALL    CHKSYN          ; Make sure ',' follows
2967+  1748 2C                  .BYTE      ','
2968+  1749 C3 4F 17            JP      GETINT          ; Get integer 0-255 and return
2969+  174C             
2970+  174C CD 81 0B    FNDNUM: CALL    GETCHR          ; Get next character
2971+  174F CD EE 0F    GETINT: CALL    GETNUM          ; Get a number from 0 to 255
2972+  1752 CD 2D 0C    MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
2973+  1755 7A                  LD      A,D             ; Get MSB of number
2974+  1756 B7                  OR      A               ; Zero?
2975+  1757 C2 48 0C            JP      NZ,FCERR        ; No - Error
2976+  175A 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2977+  175B CD 81 0B            CALL    GETCHR          ; Get next character
2978+  175E 7B                  LD      A,E             ; Get number to A
2979+  175F C9                  RET
2980+  1760             
2981+  1760 CD 33 0C    PEEK:   CALL    DEINT           ; Get memory address
2982+  1763 1A                  LD      A,(DE)          ; Get byte in memory
2983+  1764 C3 B8 13            JP      PASSA           ; Return integer A
2984+  1767             
2985+  1767 CD EE 0F    POKE:   CALL    GETNUM          ; Get memory address
2986+  176A CD 33 0C            CALL    DEINT           ; Get integer -32768 to 3276
2987+  176D D5                  PUSH    DE              ; Save memory address
2988+  176E CD F7 09            CALL    CHKSYN          ; Make sure ',' follows
2989+  1771 2C                  .BYTE      ','
2990+  1772 CD 4F 17            CALL    GETINT          ; Get integer 0-255
2991+  1775 D1                  POP     DE              ; Restore memory address
2992+  1776 12                  LD      (DE),A          ; Load it into memory
2993+  1777 C9                  RET
2994+  1778             
2995+  1778 21 4E 1C    ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
2996+  177B CD 1F 1A    ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
2997+  177E C3 8A 17            JP      FPADD           ; Add BCDE to FPREG
2998+  1781             
2999+  1781 CD 1F 1A    SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3000+  1784 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3001+  1785 C1          PSUB:   POP     BC              ; Get FP number from stack
3002+  1786 D1                  POP     DE
3003+  1787 CD F9 19    SUBCDE: CALL    INVSGN          ; Negate FPREG
3004+  178A 78          FPADD:  LD      A,B             ; Get FP exponent
3005+  178B B7                  OR      A               ; Is number zero?
3006+  178C C8                  RET     Z               ; Yes - Nothing to add
3007+  178D 3A 97 31            LD      A,(FPEXP)       ; Get FPREG exponent
3008+  1790 B7                  OR      A               ; Is this number zero?
3009+  1791 CA 11 1A            JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3010+  1794 90                  SUB     B               ; BCDE number larger?
3011+  1795 D2 A4 17            JP      NC,NOSWAP       ; No - Don't swap them
3012+  1798 2F                  CPL                     ; Two's complement
3013+  1799 3C                  INC     A               ;  FP exponent
3014+  179A EB                  EX      DE,HL
3015+  179B CD 01 1A            CALL    STAKFP          ; Put FPREG on stack
3016+  179E EB                  EX      DE,HL
3017+  179F CD 11 1A            CALL    FPBCDE          ; Move BCDE to FPREG
3018+  17A2 C1                  POP     BC              ; Restore number from stack
3019+  17A3 D1                  POP     DE
3020+  17A4 FE 19       NOSWAP: CP      24+1            ; Second number insignificant?
3021+  17A6 D0                  RET     NC              ; Yes - First number is result
3022+  17A7 F5                  PUSH    AF              ; Save number of bits to scale
3023+  17A8 CD 36 1A            CALL    SIGNS           ; Set MSBs & sign of result
3024+  17AB 67                  LD      H,A             ; Save sign of result
3025+  17AC F1                  POP     AF              ; Restore scaling factor
3026+  17AD CD 4F 18            CALL    SCALE           ; Scale BCDE to same exponent
3027+  17B0 B4                  OR      H               ; Result to be positive?
3028+  17B1 21 94 31            LD      HL,FPREG        ; Point to FPREG
3029+  17B4 F2 CA 17            JP      P,MINCDE        ; No - Subtract FPREG from CDE
3030+  17B7 CD 2F 18            CALL    PLUCDE          ; Add FPREG to CDE
3031+  17BA D2 10 18            JP      NC,RONDUP       ; No overflow - Round it up
3032+  17BD 23                  INC     HL              ; Point to exponent
3033+  17BE 34                  INC     (HL)            ; Increment it
3034+  17BF CA 38 07            JP      Z,OVERR         ; Number overflowed - Error
3035+  17C2 2E 01               LD      L,1             ; 1 bit to shift right
3036+  17C4 CD 65 18            CALL    SHRT1           ; Shift result right
3037+  17C7 C3 10 18            JP      RONDUP          ; Round it up
3038+  17CA             
3039+  17CA AF          MINCDE: XOR     A               ; Clear A and carry
3040+  17CB 90                  SUB     B               ; Negate exponent
3041+  17CC 47                  LD      B,A             ; Re-save exponent
3042+  17CD 7E                  LD      A,(HL)          ; Get LSB of FPREG
3043+  17CE 9B                  SBC     A, E            ; Subtract LSB of BCDE
3044+  17CF 5F                  LD      E,A             ; Save LSB of BCDE
3045+  17D0 23                  INC     HL
3046+  17D1 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3047+  17D2 9A                  SBC     A,D             ; Subtract NMSB of BCDE
3048+  17D3 57                  LD      D,A             ; Save NMSB of BCDE
3049+  17D4 23                  INC     HL
3050+  17D5 7E                  LD      A,(HL)          ; Get MSB of FPREG
3051+  17D6 99                  SBC     A,C             ; Subtract MSB of BCDE
3052+  17D7 4F                  LD      C,A             ; Save MSB of BCDE
3053+  17D8 DC 3B 18    CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
3054+  17DB             
3055+  17DB 68          BNORM:  LD      L,B             ; L = Exponent
3056+  17DC 63                  LD      H,E             ; H = LSB
3057+  17DD AF                  XOR     A
3058+  17DE 47          BNRMLP: LD      B,A             ; Save bit count
3059+  17DF 79                  LD      A,C             ; Get MSB
3060+  17E0 B7                  OR      A               ; Is it zero?
3061+  17E1 C2 FD 17            JP      NZ,PNORM        ; No - Do it bit at a time
3062+  17E4 4A                  LD      C,D             ; MSB = NMSB
3063+  17E5 54                  LD      D,H             ; NMSB= LSB
3064+  17E6 65                  LD      H,L             ; LSB = VLSB
3065+  17E7 6F                  LD      L,A             ; VLSB= 0
3066+  17E8 78                  LD      A,B             ; Get exponent
3067+  17E9 D6 08               SUB     8               ; Count 8 bits
3068+  17EB FE E0               CP      -24-8           ; Was number zero?
3069+  17ED C2 DE 17            JP      NZ,BNRMLP       ; No - Keep normalising
3070+  17F0 AF          RESZER: XOR     A               ; Result is zero
3071+  17F1 32 97 31    SAVEXP: LD      (FPEXP),A       ; Save result as zero
3072+  17F4 C9                  RET
3073+  17F5             
3074+  17F5 05          NORMAL: DEC     B               ; Count bits
3075+  17F6 29                  ADD     HL,HL           ; Shift HL left
3076+  17F7 7A                  LD      A,D             ; Get NMSB
3077+  17F8 17                  RLA                     ; Shift left with last bit
3078+  17F9 57                  LD      D,A             ; Save NMSB
3079+  17FA 79                  LD      A,C             ; Get MSB
3080+  17FB 8F                  ADC     A,A             ; Shift left with last bit
3081+  17FC 4F                  LD      C,A             ; Save MSB
3082+  17FD F2 F5 17    PNORM:  JP      P,NORMAL        ; Not done - Keep going
3083+  1800 78                  LD      A,B             ; Number of bits shifted
3084+  1801 5C                  LD      E,H             ; Save HL in EB
3085+  1802 45                  LD      B,L
3086+  1803 B7                  OR      A               ; Any shifting done?
3087+  1804 CA 10 18            JP      Z,RONDUP        ; No - Round it up
3088+  1807 21 97 31            LD      HL,FPEXP        ; Point to exponent
3089+  180A 86                  ADD     A,(HL)          ; Add shifted bits
3090+  180B 77                  LD      (HL),A          ; Re-save exponent
3091+  180C D2 F0 17            JP      NC,RESZER       ; Underflow - Result is zero
3092+  180F C8                  RET     Z               ; Result is zero
3093+  1810 78          RONDUP: LD      A,B             ; Get VLSB of number
3094+  1811 21 97 31    RONDB:  LD      HL,FPEXP        ; Point to exponent
3095+  1814 B7                  OR      A               ; Any rounding?
3096+  1815 FC 22 18            CALL    M,FPROND        ; Yes - Round number up
3097+  1818 46                  LD      B,(HL)          ; B = Exponent
3098+  1819 23                  INC     HL
3099+  181A 7E                  LD      A,(HL)          ; Get sign of result
3100+  181B E6 80               AND     10000000B       ; Only bit 7 needed
3101+  181D A9                  XOR     C               ; Set correct sign
3102+  181E 4F                  LD      C,A             ; Save correct sign in number
3103+  181F C3 11 1A            JP      FPBCDE          ; Move BCDE to FPREG
3104+  1822             
3105+  1822 1C          FPROND: INC     E               ; Round LSB
3106+  1823 C0                  RET     NZ              ; Return if ok
3107+  1824 14                  INC     D               ; Round NMSB
3108+  1825 C0                  RET     NZ              ; Return if ok
3109+  1826 0C                  INC     C               ; Round MSB
3110+  1827 C0                  RET     NZ              ; Return if ok
3111+  1828 0E 80               LD      C,80H           ; Set normal value
3112+  182A 34                  INC     (HL)            ; Increment exponent
3113+  182B C0                  RET     NZ              ; Return if ok
3114+  182C C3 38 07            JP      OVERR           ; Overflow error
3115+  182F             
3116+  182F 7E          PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
3117+  1830 83                  ADD     A,E             ; Add LSB of BCDE
3118+  1831 5F                  LD      E,A             ; Save LSB of BCDE
3119+  1832 23                  INC     HL
3120+  1833 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3121+  1834 8A                  ADC     A,D             ; Add NMSB of BCDE
3122+  1835 57                  LD      D,A             ; Save NMSB of BCDE
3123+  1836 23                  INC     HL
3124+  1837 7E                  LD      A,(HL)          ; Get MSB of FPREG
3125+  1838 89                  ADC     A,C             ; Add MSB of BCDE
3126+  1839 4F                  LD      C,A             ; Save MSB of BCDE
3127+  183A C9                  RET
3128+  183B             
3129+  183B 21 98 31    COMPL:  LD      HL,SGNRES       ; Sign of result
3130+  183E 7E                  LD      A,(HL)          ; Get sign of result
3131+  183F 2F                  CPL                     ; Negate it
3132+  1840 77                  LD      (HL),A          ; Put it back
3133+  1841 AF                  XOR     A
3134+  1842 6F                  LD      L,A             ; Set L to zero
3135+  1843 90                  SUB     B               ; Negate exponent,set carry
3136+  1844 47                  LD      B,A             ; Re-save exponent
3137+  1845 7D                  LD      A,L             ; Load zero
3138+  1846 9B                  SBC     A,E             ; Negate LSB
3139+  1847 5F                  LD      E,A             ; Re-save LSB
3140+  1848 7D                  LD      A,L             ; Load zero
3141+  1849 9A                  SBC     A,D             ; Negate NMSB
3142+  184A 57                  LD      D,A             ; Re-save NMSB
3143+  184B 7D                  LD      A,L             ; Load zero
3144+  184C 99                  SBC     A,C             ; Negate MSB
3145+  184D 4F                  LD      C,A             ; Re-save MSB
3146+  184E C9                  RET
3147+  184F             
3148+  184F 06 00       SCALE:  LD      B,0             ; Clear underflow
3149+  1851 D6 08       SCALLP: SUB     8               ; 8 bits (a whole byte)?
3150+  1853 DA 5E 18            JP      C,SHRITE        ; No - Shift right A bits
3151+  1856 43                  LD      B,E             ; <- Shift
3152+  1857 5A                  LD      E,D             ; <- right
3153+  1858 51                  LD      D,C             ; <- eight
3154+  1859 0E 00               LD      C,0             ; <- bits
3155+  185B C3 51 18            JP      SCALLP          ; More bits to shift
3156+  185E             
3157+  185E C6 09       SHRITE: ADD     A,8+1           ; Adjust count
3158+  1860 6F                  LD      L,A             ; Save bits to shift
3159+  1861 AF          SHRLP:  XOR     A               ; Flag for all done
3160+  1862 2D                  DEC     L               ; All shifting done?
3161+  1863 C8                  RET     Z               ; Yes - Return
3162+  1864 79                  LD      A,C             ; Get MSB
3163+  1865 1F          SHRT1:  RRA                     ; Shift it right
3164+  1866 4F                  LD      C,A             ; Re-save
3165+  1867 7A                  LD      A,D             ; Get NMSB
3166+  1868 1F                  RRA                     ; Shift right with last bit
3167+  1869 57                  LD      D,A             ; Re-save it
3168+  186A 7B                  LD      A,E             ; Get LSB
3169+  186B 1F                  RRA                     ; Shift right with last bit
3170+  186C 5F                  LD      E,A             ; Re-save it
3171+  186D 78                  LD      A,B             ; Get underflow
3172+  186E 1F                  RRA                     ; Shift right with last bit
3173+  186F 47                  LD      B,A             ; Re-save underflow
3174+  1870 C3 61 18            JP      SHRLP           ; More bits to do
3175+  1873             
3176+  1873 00 00 00 81 UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
3177+  1877             
3178+  1877 03          LOGTAB: .BYTE      3                       ; Table used by LOG
3179+  1878 AA 56 19 80         .BYTE      0AAH,056H,019H,080H     ; 0.59898
3180+  187C F1 22 76 80         .BYTE      0F1H,022H,076H,080H     ; 0.96147
3181+  1880 45 AA 38 82         .BYTE      045H,0AAH,038H,082H     ; 2.88539
3182+  1884             
3183+  1884 CD D0 19    LOG:    CALL    TSTSGN          ; Test sign of value
3184+  1887 B7                  OR      A
3185+  1888 EA 48 0C            JP      PE,FCERR        ; ?FC Error if <= zero
3186+  188B 21 97 31            LD      HL,FPEXP        ; Point to exponent
3187+  188E 7E                  LD      A,(HL)          ; Get exponent
3188+  188F 01 35 80            LD      BC,8035H        ; BCDE = SQR(1/2)
3189+  1892 11 F3 04            LD      DE,04F3H
3190+  1895 90                  SUB     B               ; Scale value to be < 1
3191+  1896 F5                  PUSH    AF              ; Save scale factor
3192+  1897 70                  LD      (HL),B          ; Save new exponent
3193+  1898 D5                  PUSH    DE              ; Save SQR(1/2)
3194+  1899 C5                  PUSH    BC
3195+  189A CD 8A 17            CALL    FPADD           ; Add SQR(1/2) to value
3196+  189D C1                  POP     BC              ; Restore SQR(1/2)
3197+  189E D1                  POP     DE
3198+  189F 04                  INC     B               ; Make it SQR(2)
3199+  18A0 CD 26 19            CALL    DVBCDE          ; Divide by SQR(2)
3200+  18A3 21 73 18            LD      HL,UNITY        ; Point to 1.
3201+  18A6 CD 81 17            CALL    SUBPHL          ; Subtract FPREG from 1
3202+  18A9 21 77 18            LD      HL,LOGTAB       ; Coefficient table
3203+  18AC CD 18 1D            CALL    SUMSER          ; Evaluate sum of series
3204+  18AF 01 80 80            LD      BC,8080H        ; BCDE = -0.5
3205+  18B2 11 00 00            LD      DE,0000H
3206+  18B5 CD 8A 17            CALL    FPADD           ; Subtract 0.5 from FPREG
3207+  18B8 F1                  POP     AF              ; Restore scale factor
3208+  18B9 CD 4B 1B            CALL    RSCALE          ; Re-scale number
3209+  18BC 01 31 80    MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3210+  18BF 11 18 72            LD      DE,7218H
3211+  18C2 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3212+  18C3             
3213+  18C3 C1          MULT:   POP     BC              ; Get number from stack
3214+  18C4 D1                  POP     DE
3215+  18C5 CD D0 19    FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3216+  18C8 C8                  RET     Z               ; Return zero if zero
3217+  18C9 2E 00               LD      L,0             ; Flag add exponents
3218+  18CB CD 8E 19            CALL    ADDEXP          ; Add exponents
3219+  18CE 79                  LD      A,C             ; Get MSB of multiplier
3220+  18CF 32 A6 31            LD      (MULVAL),A      ; Save MSB of multiplier
3221+  18D2 EB                  EX      DE,HL
3222+  18D3 22 A7 31            LD      (MULVAL+1),HL   ; Save rest of multiplier
3223+  18D6 01 00 00            LD      BC,0            ; Partial product (BCDE) = zero
3224+  18D9 50                  LD      D,B
3225+  18DA 58                  LD      E,B
3226+  18DB 21 DB 17            LD      HL,BNORM        ; Address of normalise
3227+  18DE E5                  PUSH    HL              ; Save for return
3228+  18DF 21 E7 18            LD      HL,MULT8        ; Address of 8 bit multiply
3229+  18E2 E5                  PUSH    HL              ; Save for NMSB,MSB
3230+  18E3 E5                  PUSH    HL              ; 
3231+  18E4 21 94 31            LD      HL,FPREG        ; Point to number
3232+  18E7 7E          MULT8:  LD      A,(HL)          ; Get LSB of number
3233+  18E8 23                  INC     HL              ; Point to NMSB
3234+  18E9 B7                  OR      A               ; Test LSB
3235+  18EA CA 13 19            JP      Z,BYTSFT        ; Zero - shift to next byte
3236+  18ED E5                  PUSH    HL              ; Save address of number
3237+  18EE 2E 08               LD      L,8             ; 8 bits to multiply by
3238+  18F0 1F          MUL8LP: RRA                     ; Shift LSB right
3239+  18F1 67                  LD      H,A             ; Save LSB
3240+  18F2 79                  LD      A,C             ; Get MSB
3241+  18F3 D2 01 19            JP      NC,NOMADD       ; Bit was zero - Don't add
3242+  18F6 E5                  PUSH    HL              ; Save LSB and count
3243+  18F7 2A A7 31            LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3244+  18FA 19                  ADD     HL,DE           ; Add NMSB and LSB
3245+  18FB EB                  EX      DE,HL           ; Leave sum in DE
3246+  18FC E1                  POP     HL              ; Restore MSB and count
3247+  18FD 3A A6 31            LD      A,(MULVAL)      ; Get MSB of multiplier
3248+  1900 89                  ADC     A,C             ; Add MSB
3249+  1901 1F          NOMADD: RRA                     ; Shift MSB right
3250+  1902 4F                  LD      C,A             ; Re-save MSB
3251+  1903 7A                  LD      A,D             ; Get NMSB
3252+  1904 1F                  RRA                     ; Shift NMSB right
3253+  1905 57                  LD      D,A             ; Re-save NMSB
3254+  1906 7B                  LD      A,E             ; Get LSB
3255+  1907 1F                  RRA                     ; Shift LSB right
3256+  1908 5F                  LD      E,A             ; Re-save LSB
3257+  1909 78                  LD      A,B             ; Get VLSB
3258+  190A 1F                  RRA                     ; Shift VLSB right
3259+  190B 47                  LD      B,A             ; Re-save VLSB
3260+  190C 2D                  DEC     L               ; Count bits multiplied
3261+  190D 7C                  LD      A,H             ; Get LSB of multiplier
3262+  190E C2 F0 18            JP      NZ,MUL8LP       ; More - Do it
3263+  1911 E1          POPHRT: POP     HL              ; Restore address of number
3264+  1912 C9                  RET
3265+  1913             
3266+  1913 43          BYTSFT: LD      B,E             ; Shift partial product left
3267+  1914 5A                  LD      E,D
3268+  1915 51                  LD      D,C
3269+  1916 4F                  LD      C,A
3270+  1917 C9                  RET
3271+  1918             
3272+  1918 CD 01 1A    DIV10:  CALL    STAKFP          ; Save FPREG on stack
3273+  191B 01 20 84            LD      BC,8420H        ; BCDE = 10.
3274+  191E 11 00 00            LD      DE,0000H
3275+  1921 CD 11 1A            CALL    FPBCDE          ; Move 10 to FPREG
3276+  1924             
3277+  1924 C1          DIV:    POP     BC              ; Get number from stack
3278+  1925 D1                  POP     DE
3279+  1926 CD D0 19    DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
3280+  1929 CA 2C 07            JP      Z,DZERR         ; Error if division by zero
3281+  192C 2E FF               LD      L,-1            ; Flag subtract exponents
3282+  192E CD 8E 19            CALL    ADDEXP          ; Subtract exponents
3283+  1931 34                  INC     (HL)            ; Add 2 to exponent to adjust
3284+  1932 34                  INC     (HL)
3285+  1933 2B                  DEC     HL              ; Point to MSB
3286+  1934 7E                  LD      A,(HL)          ; Get MSB of dividend
3287+  1935 32 C2 30            LD      (DIV3),A        ; Save for subtraction
3288+  1938 2B                  DEC     HL
3289+  1939 7E                  LD      A,(HL)          ; Get NMSB of dividend
3290+  193A 32 BE 30            LD      (DIV2),A        ; Save for subtraction
3291+  193D 2B                  DEC     HL
3292+  193E 7E                  LD      A,(HL)          ; Get MSB of dividend
3293+  193F 32 BA 30            LD      (DIV1),A        ; Save for subtraction
3294+  1942 41                  LD      B,C             ; Get MSB
3295+  1943 EB                  EX      DE,HL           ; NMSB,LSB to HL
3296+  1944 AF                  XOR     A
3297+  1945 4F                  LD      C,A             ; Clear MSB of quotient
3298+  1946 57                  LD      D,A             ; Clear NMSB of quotient
3299+  1947 5F                  LD      E,A             ; Clear LSB of quotient
3300+  1948 32 C5 30            LD      (DIV4),A        ; Clear overflow count
3301+  194B E5          DIVLP:  PUSH    HL              ; Save divisor
3302+  194C C5                  PUSH    BC
3303+  194D 7D                  LD      A,L             ; Get LSB of number
3304+  194E CD B9 30            CALL    DIVSUP          ; Subt' divisor from dividend
3305+  1951 DE 00               SBC     A,0             ; Count for overflows
3306+  1953 3F                  CCF
3307+  1954 D2 5E 19            JP      NC,RESDIV       ; Restore divisor if borrow
3308+  1957 32 C5 30            LD      (DIV4),A        ; Re-save overflow count
3309+  195A F1                  POP     AF              ; Scrap divisor
3310+  195B F1                  POP     AF
3311+  195C 37                  SCF                     ; Set carry to
3312+  195D D2                  .BYTE      0D2H            ; Skip "POP BC" and "POP HL"
3313+  195E             
3314+  195E C1          RESDIV: POP     BC              ; Restore divisor
3315+  195F E1                  POP     HL
3316+  1960 79                  LD      A,C             ; Get MSB of quotient
3317+  1961 3C                  INC     A
3318+  1962 3D                  DEC     A
3319+  1963 1F                  RRA                     ; Bit 0 to bit 7
3320+  1964 FA 11 18            JP      M,RONDB         ; Done - Normalise result
3321+  1967 17                  RLA                     ; Restore carry
3322+  1968 7B                  LD      A,E             ; Get LSB of quotient
3323+  1969 17                  RLA                     ; Double it
3324+  196A 5F                  LD      E,A             ; Put it back
3325+  196B 7A                  LD      A,D             ; Get NMSB of quotient
3326+  196C 17                  RLA                     ; Double it
3327+  196D 57                  LD      D,A             ; Put it back
3328+  196E 79                  LD      A,C             ; Get MSB of quotient
3329+  196F 17                  RLA                     ; Double it
3330+  1970 4F                  LD      C,A             ; Put it back
3331+  1971 29                  ADD     HL,HL           ; Double NMSB,LSB of divisor
3332+  1972 78                  LD      A,B             ; Get MSB of divisor
3333+  1973 17                  RLA                     ; Double it
3334+  1974 47                  LD      B,A             ; Put it back
3335+  1975 3A C5 30            LD      A,(DIV4)        ; Get VLSB of quotient
3336+  1978 17                  RLA                     ; Double it
3337+  1979 32 C5 30            LD      (DIV4),A        ; Put it back
3338+  197C 79                  LD      A,C             ; Get MSB of quotient
3339+  197D B2                  OR      D               ; Merge NMSB
3340+  197E B3                  OR      E               ; Merge LSB
3341+  197F C2 4B 19            JP      NZ,DIVLP        ; Not done - Keep dividing
3342+  1982 E5                  PUSH    HL              ; Save divisor
3343+  1983 21 97 31            LD      HL,FPEXP        ; Point to exponent
3344+  1986 35                  DEC     (HL)            ; Divide by 2
3345+  1987 E1                  POP     HL              ; Restore divisor
3346+  1988 C2 4B 19            JP      NZ,DIVLP        ; Ok - Keep going
3347+  198B C3 38 07            JP      OVERR           ; Overflow error
3348+  198E             
3349+  198E 78          ADDEXP: LD      A,B             ; Get exponent of dividend
3350+  198F B7                  OR      A               ; Test it
3351+  1990 CA B2 19            JP      Z,OVTST3        ; Zero - Result zero
3352+  1993 7D                  LD      A,L             ; Get add/subtract flag
3353+  1994 21 97 31            LD      HL,FPEXP        ; Point to exponent
3354+  1997 AE                  XOR     (HL)            ; Add or subtract it
3355+  1998 80                  ADD     A,B             ; Add the other exponent
3356+  1999 47                  LD      B,A             ; Save new exponent
3357+  199A 1F                  RRA                     ; Test exponent for overflow
3358+  199B A8                  XOR     B
3359+  199C 78                  LD      A,B             ; Get exponent
3360+  199D F2 B1 19            JP      P,OVTST2        ; Positive - Test for overflow
3361+  19A0 C6 80               ADD     A,80H           ; Add excess 128
3362+  19A2 77                  LD      (HL),A          ; Save new exponent
3363+  19A3 CA 11 19            JP      Z,POPHRT        ; Zero - Result zero
3364+  19A6 CD 36 1A            CALL    SIGNS           ; Set MSBs and sign of result
3365+  19A9 77                  LD      (HL),A          ; Save new exponent
3366+  19AA 2B                  DEC     HL              ; Point to MSB
3367+  19AB C9                  RET
3368+  19AC             
3369+  19AC CD D0 19    OVTST1: CALL    TSTSGN          ; Test sign of FPREG
3370+  19AF 2F                  CPL                     ; Invert sign
3371+  19B0 E1                  POP     HL              ; Clean up stack
3372+  19B1 B7          OVTST2: OR      A               ; Test if new exponent zero
3373+  19B2 E1          OVTST3: POP     HL              ; Clear off return address
3374+  19B3 F2 F0 17            JP      P,RESZER        ; Result zero
3375+  19B6 C3 38 07            JP      OVERR           ; Overflow error
3376+  19B9             
3377+  19B9 CD 1C 1A    MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
3378+  19BC 78                  LD      A,B             ; Get exponent
3379+  19BD B7                  OR      A               ; Is it zero?
3380+  19BE C8                  RET     Z               ; Yes - Result is zero
3381+  19BF C6 02               ADD     A,2             ; Multiply by 4
3382+  19C1 DA 38 07            JP      C,OVERR         ; Overflow - ?OV Error
3383+  19C4 47                  LD      B,A             ; Re-save exponent
3384+  19C5 CD 8A 17            CALL    FPADD           ; Add BCDE to FPREG (Times 5)
3385+  19C8 21 97 31            LD      HL,FPEXP        ; Point to exponent
3386+  19CB 34                  INC     (HL)            ; Double number (Times 10)
3387+  19CC C0                  RET     NZ              ; Ok - Return
3388+  19CD C3 38 07            JP      OVERR           ; Overflow error
3389+  19D0             
3390+  19D0 3A 97 31    TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
3391+  19D3 B7                  OR      A
3392+  19D4 C8                  RET     Z               ; RETurn if number is zero
3393+  19D5 3A 96 31            LD      A,(FPREG+2)     ; Get MSB of FPREG
3394+  19D8 FE                  .BYTE      0FEH            ; Test sign
3395+  19D9 2F          RETREL: CPL                     ; Invert sign
3396+  19DA 17                  RLA                     ; Sign bit to carry
3397+  19DB 9F          FLGDIF: SBC     A,A             ; Carry to all bits of A
3398+  19DC C0                  RET     NZ              ; Return -1 if negative
3399+  19DD 3C                  INC     A               ; Bump to +1
3400+  19DE C9                  RET                     ; Positive - Return +1
3401+  19DF             
3402+  19DF CD D0 19    SGN:    CALL    TSTSGN          ; Test sign of FPREG
3403+  19E2 06 88       FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
3404+  19E4 11 00 00            LD      DE,0            ; Zero NMSB and LSB
3405+  19E7 21 97 31    RETINT: LD      HL,FPEXP        ; Point to exponent
3406+  19EA 4F                  LD      C,A             ; CDE = MSB,NMSB and LSB
3407+  19EB 70                  LD      (HL),B          ; Save exponent
3408+  19EC 06 00               LD      B,0             ; CDE = integer to normalise
3409+  19EE 23                  INC     HL              ; Point to sign of result
3410+  19EF 36 80               LD      (HL),80H        ; Set sign of result
3411+  19F1 17                  RLA                     ; Carry = sign of integer
3412+  19F2 C3 D8 17            JP      CONPOS          ; Set sign of result
3413+  19F5             
3414+  19F5 CD D0 19    ABS:    CALL    TSTSGN          ; Test sign of FPREG
3415+  19F8 F0                  RET     P               ; Return if positive
3416+  19F9 21 96 31    INVSGN: LD      HL,FPREG+2      ; Point to MSB
3417+  19FC 7E                  LD      A,(HL)          ; Get sign of mantissa
3418+  19FD EE 80               XOR     80H             ; Invert sign of mantissa
3419+  19FF 77                  LD      (HL),A          ; Re-save sign of mantissa
3420+  1A00 C9                  RET
3421+  1A01             
3422+  1A01 EB          STAKFP: EX      DE,HL           ; Save code string address
3423+  1A02 2A 94 31            LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3424+  1A05 E3                  EX      (SP),HL         ; Stack them,get return
3425+  1A06 E5                  PUSH    HL              ; Re-save return
3426+  1A07 2A 96 31            LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3427+  1A0A E3                  EX      (SP),HL         ; Stack them,get return
3428+  1A0B E5                  PUSH    HL              ; Re-save return
3429+  1A0C EB                  EX      DE,HL           ; Restore code string address
3430+  1A0D C9                  RET
3431+  1A0E             
3432+  1A0E CD 1F 1A    PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
3433+  1A11 EB          FPBCDE: EX      DE,HL           ; Save code string address
3434+  1A12 22 94 31            LD      (FPREG),HL      ; Save LSB,NLSB of number
3435+  1A15 60                  LD      H,B             ; Exponent of number
3436+  1A16 69                  LD      L,C             ; MSB of number
3437+  1A17 22 96 31            LD      (FPREG+2),HL    ; Save MSB and exponent
3438+  1A1A EB                  EX      DE,HL           ; Restore code string address
3439+  1A1B C9                  RET
3440+  1A1C             
3441+  1A1C 21 94 31    BCDEFP: LD      HL,FPREG        ; Point to FPREG
3442+  1A1F 5E          LOADFP: LD      E,(HL)          ; Get LSB of number
3443+  1A20 23                  INC     HL
3444+  1A21 56                  LD      D,(HL)          ; Get NMSB of number
3445+  1A22 23                  INC     HL
3446+  1A23 4E                  LD      C,(HL)          ; Get MSB of number
3447+  1A24 23                  INC     HL
3448+  1A25 46                  LD      B,(HL)          ; Get exponent of number
3449+  1A26 23          INCHL:  INC     HL              ; Used for conditional "INC HL"
3450+  1A27 C9                  RET
3451+  1A28             
3452+  1A28 11 94 31    FPTHL:  LD      DE,FPREG        ; Point to FPREG
3453+  1A2B 06 04       DETHL4: LD      B,4             ; 4 bytes to move
3454+  1A2D 1A          DETHLB: LD      A,(DE)          ; Get source
3455+  1A2E 77                  LD      (HL),A          ; Save destination
3456+  1A2F 13                  INC     DE              ; Next source
3457+  1A30 23                  INC     HL              ; Next destination
3458+  1A31 05                  DEC     B               ; Count bytes
3459+  1A32 C2 2D 1A            JP      NZ,DETHLB       ; Loop if more
3460+  1A35 C9                  RET
3461+  1A36             
3462+  1A36 21 96 31    SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
3463+  1A39 7E                  LD      A,(HL)          ; Get MSB
3464+  1A3A 07                  RLCA                    ; Old sign to carry
3465+  1A3B 37                  SCF                     ; Set MSBit
3466+  1A3C 1F                  RRA                     ; Set MSBit of MSB
3467+  1A3D 77                  LD      (HL),A          ; Save new MSB
3468+  1A3E 3F                  CCF                     ; Complement sign
3469+  1A3F 1F                  RRA                     ; Old sign to carry
3470+  1A40 23                  INC     HL
3471+  1A41 23                  INC     HL
3472+  1A42 77                  LD      (HL),A          ; Set sign of result
3473+  1A43 79                  LD      A,C             ; Get MSB
3474+  1A44 07                  RLCA                    ; Old sign to carry
3475+  1A45 37                  SCF                     ; Set MSBit
3476+  1A46 1F                  RRA                     ; Set MSBit of MSB
3477+  1A47 4F                  LD      C,A             ; Save MSB
3478+  1A48 1F                  RRA
3479+  1A49 AE                  XOR     (HL)            ; New sign of result
3480+  1A4A C9                  RET
3481+  1A4B             
3482+  1A4B 78          CMPNUM: LD      A,B             ; Get exponent of number
3483+  1A4C B7                  OR      A
3484+  1A4D CA D0 19            JP      Z,TSTSGN        ; Zero - Test sign of FPREG
3485+  1A50 21 D9 19            LD      HL,RETREL       ; Return relation routine
3486+  1A53 E5                  PUSH    HL              ; Save for return
3487+  1A54 CD D0 19            CALL    TSTSGN          ; Test sign of FPREG
3488+  1A57 79                  LD      A,C             ; Get MSB of number
3489+  1A58 C8                  RET     Z               ; FPREG zero - Number's MSB
3490+  1A59 21 96 31            LD      HL,FPREG+2      ; MSB of FPREG
3491+  1A5C AE                  XOR     (HL)            ; Combine signs
3492+  1A5D 79                  LD      A,C             ; Get MSB of number
3493+  1A5E F8                  RET     M               ; Exit if signs different
3494+  1A5F CD 65 1A            CALL    CMPFP           ; Compare FP numbers
3495+  1A62 1F                  RRA                     ; Get carry to sign
3496+  1A63 A9                  XOR     C               ; Combine with MSB of number
3497+  1A64 C9                  RET
3498+  1A65             
3499+  1A65 23          CMPFP:  INC     HL              ; Point to exponent
3500+  1A66 78                  LD      A,B             ; Get exponent
3501+  1A67 BE                  CP      (HL)            ; Compare exponents
3502+  1A68 C0                  RET     NZ              ; Different
3503+  1A69 2B                  DEC     HL              ; Point to MBS
3504+  1A6A 79                  LD      A,C             ; Get MSB
3505+  1A6B BE                  CP      (HL)            ; Compare MSBs
3506+  1A6C C0                  RET     NZ              ; Different
3507+  1A6D 2B                  DEC     HL              ; Point to NMSB
3508+  1A6E 7A                  LD      A,D             ; Get NMSB
3509+  1A6F BE                  CP      (HL)            ; Compare NMSBs
3510+  1A70 C0                  RET     NZ              ; Different
3511+  1A71 2B                  DEC     HL              ; Point to LSB
3512+  1A72 7B                  LD      A,E             ; Get LSB
3513+  1A73 96                  SUB     (HL)            ; Compare LSBs
3514+  1A74 C0                  RET     NZ              ; Different
3515+  1A75 E1                  POP     HL              ; Drop RETurn
3516+  1A76 E1                  POP     HL              ; Drop another RETurn
3517+  1A77 C9                  RET
3518+  1A78             
3519+  1A78 47          FPINT:  LD      B,A             ; <- Move
3520+  1A79 4F                  LD      C,A             ; <- exponent
3521+  1A7A 57                  LD      D,A             ; <- to all
3522+  1A7B 5F                  LD      E,A             ; <- bits
3523+  1A7C B7                  OR      A               ; Test exponent
3524+  1A7D C8                  RET     Z               ; Zero - Return zero
3525+  1A7E E5                  PUSH    HL              ; Save pointer to number
3526+  1A7F CD 1C 1A            CALL    BCDEFP          ; Move FPREG to BCDE
3527+  1A82 CD 36 1A            CALL    SIGNS           ; Set MSBs & sign of result
3528+  1A85 AE                  XOR     (HL)            ; Combine with sign of FPREG
3529+  1A86 67                  LD      H,A             ; Save combined signs
3530+  1A87 FC 9C 1A            CALL    M,DCBCDE        ; Negative - Decrement BCDE
3531+  1A8A 3E 98               LD      A,80H+24        ; 24 bits
3532+  1A8C 90                  SUB     B               ; Bits to shift
3533+  1A8D CD 4F 18            CALL    SCALE           ; Shift BCDE
3534+  1A90 7C                  LD      A,H             ; Get combined sign
3535+  1A91 17                  RLA                     ; Sign to carry
3536+  1A92 DC 22 18            CALL    C,FPROND        ; Negative - Round number up
3537+  1A95 06 00               LD      B,0             ; Zero exponent
3538+  1A97 DC 3B 18            CALL    C,COMPL         ; If negative make positive
3539+  1A9A E1                  POP     HL              ; Restore pointer to number
3540+  1A9B C9                  RET
3541+  1A9C             
3542+  1A9C 1B          DCBCDE: DEC     DE              ; Decrement BCDE
3543+  1A9D 7A                  LD      A,D             ; Test LSBs
3544+  1A9E A3                  AND     E
3545+  1A9F 3C                  INC     A
3546+  1AA0 C0                  RET     NZ              ; Exit if LSBs not FFFF
3547+  1AA1 0B                  DEC     BC              ; Decrement MSBs
3548+  1AA2 C9                  RET
3549+  1AA3             
3550+  1AA3 21 97 31    INT:    LD      HL,FPEXP        ; Point to exponent
3551+  1AA6 7E                  LD      A,(HL)          ; Get exponent
3552+  1AA7 FE 98               CP      80H+24          ; Integer accuracy only?
3553+  1AA9 3A 94 31            LD      A,(FPREG)       ; Get LSB
3554+  1AAC D0                  RET     NC              ; Yes - Already integer
3555+  1AAD 7E                  LD      A,(HL)          ; Get exponent
3556+  1AAE CD 78 1A            CALL    FPINT           ; F.P to integer
3557+  1AB1 36 98               LD      (HL),80H+24     ; Save 24 bit integer
3558+  1AB3 7B                  LD      A,E             ; Get LSB of number
3559+  1AB4 F5                  PUSH    AF              ; Save LSB
3560+  1AB5 79                  LD      A,C             ; Get MSB of number
3561+  1AB6 17                  RLA                     ; Sign to carry
3562+  1AB7 CD D8 17            CALL    CONPOS          ; Set sign of result
3563+  1ABA F1                  POP     AF              ; Restore LSB of number
3564+  1ABB C9                  RET
3565+  1ABC             
3566+  1ABC 21 00 00    MLDEBC: LD      HL,0            ; Clear partial product
3567+  1ABF 78                  LD      A,B             ; Test multiplier
3568+  1AC0 B1                  OR      C
3569+  1AC1 C8                  RET     Z               ; Return zero if zero
3570+  1AC2 3E 10               LD      A,16            ; 16 bits
3571+  1AC4 29          MLDBLP: ADD     HL,HL           ; Shift P.P left
3572+  1AC5 DA FC 12            JP      C,BSERR         ; ?BS Error if overflow
3573+  1AC8 EB                  EX      DE,HL
3574+  1AC9 29                  ADD     HL,HL           ; Shift multiplier left
3575+  1ACA EB                  EX      DE,HL
3576+  1ACB D2 D2 1A            JP      NC,NOMLAD       ; Bit was zero - No add
3577+  1ACE 09                  ADD     HL,BC           ; Add multiplicand
3578+  1ACF DA FC 12            JP      C,BSERR         ; ?BS Error if overflow
3579+  1AD2 3D          NOMLAD: DEC     A               ; Count bits
3580+  1AD3 C2 C4 1A            JP      NZ,MLDBLP       ; More
3581+  1AD6 C9                  RET
3582+  1AD7             
3583+  1AD7 FE 2D       ASCTFP: CP      '-'             ; Negative?
3584+  1AD9 F5                  PUSH    AF              ; Save it and flags
3585+  1ADA CA E3 1A            JP      Z,CNVNUM        ; Yes - Convert number
3586+  1ADD FE 2B               CP      '+'             ; Positive?
3587+  1ADF CA E3 1A            JP      Z,CNVNUM        ; Yes - Convert number
3588+  1AE2 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
3589+  1AE3 CD F0 17    CNVNUM: CALL    RESZER          ; Set result to zero
3590+  1AE6 47                  LD      B,A             ; Digits after point counter
3591+  1AE7 57                  LD      D,A             ; Sign of exponent
3592+  1AE8 5F                  LD      E,A             ; Exponent of ten
3593+  1AE9 2F                  CPL
3594+  1AEA 4F                  LD      C,A             ; Before or after point flag
3595+  1AEB CD 81 0B    MANLP:  CALL    GETCHR          ; Get next character
3596+  1AEE DA 34 1B            JP      C,ADDIG         ; Digit - Add to number
3597+  1AF1 FE 2E               CP      '.'
3598+  1AF3 CA 0F 1B            JP      Z,DPOINT        ; '.' - Flag point
3599+  1AF6 FE 45               CP      'E'
3600+  1AF8 C2 13 1B            JP      NZ,CONEXP       ; Not 'E' - Scale number
3601+  1AFB CD 81 0B            CALL    GETCHR          ; Get next character
3602+  1AFE CD 27 11            CALL    SGNEXP          ; Get sign of exponent
3603+  1B01 CD 81 0B    EXPLP:  CALL    GETCHR          ; Get next character
3604+  1B04 DA 56 1B            JP      C,EDIGIT        ; Digit - Add to exponent
3605+  1B07 14                  INC     D               ; Is sign negative?
3606+  1B08 C2 13 1B            JP      NZ,CONEXP       ; No - Scale number
3607+  1B0B AF                  XOR     A
3608+  1B0C 93                  SUB     E               ; Negate exponent
3609+  1B0D 5F                  LD      E,A             ; And re-save it
3610+  1B0E 0C                  INC     C               ; Flag end of number
3611+  1B0F 0C          DPOINT: INC     C               ; Flag point passed
3612+  1B10 CA EB 1A            JP      Z,MANLP         ; Zero - Get another digit
3613+  1B13 E5          CONEXP: PUSH    HL              ; Save code string address
3614+  1B14 7B                  LD      A,E             ; Get exponent
3615+  1B15 90                  SUB     B               ; Subtract digits after point
3616+  1B16 F4 2C 1B    SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
3617+  1B19 F2 22 1B            JP      P,ENDCON        ; Positive - All done
3618+  1B1C F5                  PUSH    AF              ; Save number of times to /10
3619+  1B1D CD 18 19            CALL    DIV10           ; Divide by 10
3620+  1B20 F1                  POP     AF              ; Restore count
3621+  1B21 3C                  INC     A               ; Count divides
3622+  1B22             
3623+  1B22 C2 16 1B    ENDCON: JP      NZ,SCALMI       ; More to do
3624+  1B25 D1                  POP     DE              ; Restore code string address
3625+  1B26 F1                  POP     AF              ; Restore sign of number
3626+  1B27 CC F9 19            CALL    Z,INVSGN        ; Negative - Negate number
3627+  1B2A EB                  EX      DE,HL           ; Code string address to HL
3628+  1B2B C9                  RET
3629+  1B2C             
3630+  1B2C C8          SCALPL: RET     Z               ; Exit if no scaling needed
3631+  1B2D F5          MULTEN: PUSH    AF              ; Save count
3632+  1B2E CD B9 19            CALL    MLSP10          ; Multiply number by 10
3633+  1B31 F1                  POP     AF              ; Restore count
3634+  1B32 3D                  DEC     A               ; Count multiplies
3635+  1B33 C9                  RET
3636+  1B34             
3637+  1B34 D5          ADDIG:  PUSH    DE              ; Save sign of exponent
3638+  1B35 57                  LD      D,A             ; Save digit
3639+  1B36 78                  LD      A,B             ; Get digits after point
3640+  1B37 89                  ADC     A,C             ; Add one if after point
3641+  1B38 47                  LD      B,A             ; Re-save counter
3642+  1B39 C5                  PUSH    BC              ; Save point flags
3643+  1B3A E5                  PUSH    HL              ; Save code string address
3644+  1B3B D5                  PUSH    DE              ; Save digit
3645+  1B3C CD B9 19            CALL    MLSP10          ; Multiply number by 10
3646+  1B3F F1                  POP     AF              ; Restore digit
3647+  1B40 D6 30               SUB     '0'             ; Make it absolute
3648+  1B42 CD 4B 1B            CALL    RSCALE          ; Re-scale number
3649+  1B45 E1                  POP     HL              ; Restore code string address
3650+  1B46 C1                  POP     BC              ; Restore point flags
3651+  1B47 D1                  POP     DE              ; Restore sign of exponent
3652+  1B48 C3 EB 1A            JP      MANLP           ; Get another digit
3653+  1B4B             
3654+  1B4B CD 01 1A    RSCALE: CALL    STAKFP          ; Put number on stack
3655+  1B4E CD E2 19            CALL    FLGREL          ; Digit to add to FPREG
3656+  1B51 C1          PADD:   POP     BC              ; Restore number
3657+  1B52 D1                  POP     DE
3658+  1B53 C3 8A 17            JP      FPADD           ; Add BCDE to FPREG and return
3659+  1B56             
3660+  1B56 7B          EDIGIT: LD      A,E             ; Get digit
3661+  1B57 07                  RLCA                    ; Times 2
3662+  1B58 07                  RLCA                    ; Times 4
3663+  1B59 83                  ADD     A,E             ; Times 5
3664+  1B5A 07                  RLCA                    ; Times 10
3665+  1B5B 86                  ADD     A,(HL)          ; Add next digit
3666+  1B5C D6 30               SUB     '0'             ; Make it absolute
3667+  1B5E 5F                  LD      E,A             ; Save new digit
3668+  1B5F C3 01 1B            JP      EXPLP           ; Look for another digit
3669+  1B62             
3670+  1B62 E5          LINEIN: PUSH    HL              ; Save code string address
3671+  1B63 21 C1 06            LD      HL,INMSG        ; Output " in "
3672+  1B66 CD C7 14            CALL    PRS             ; Output string at HL
3673+  1B69 E1                  POP     HL              ; Restore code string address
3674+  1B6A EB          PRNTHL: EX      DE,HL           ; Code string address to DE
3675+  1B6B AF                  XOR     A
3676+  1B6C 06 98               LD      B,80H+24        ; 24 bits
3677+  1B6E CD E7 19            CALL    RETINT          ; Return the integer
3678+  1B71 21 C6 14            LD      HL,PRNUMS       ; Print number string
3679+  1B74 E5                  PUSH    HL              ; Save for return
3680+  1B75 21 99 31    NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
3681+  1B78 E5                  PUSH    HL              ; Save for return
3682+  1B79 CD D0 19            CALL    TSTSGN          ; Test sign of FPREG
3683+  1B7C 36 20               LD      (HL),' '        ; Space at start
3684+  1B7E F2 83 1B            JP      P,SPCFST        ; Positive - Space to start
3685+  1B81 36 2D               LD      (HL),'-'        ; '-' sign at start
3686+  1B83 23          SPCFST: INC     HL              ; First byte of number
3687+  1B84 36 30               LD      (HL),'0'        ; '0' if zero
3688+  1B86 CA 39 1C            JP      Z,JSTZER        ; Return '0' if zero
3689+  1B89 E5                  PUSH    HL              ; Save buffer address
3690+  1B8A FC F9 19            CALL    M,INVSGN        ; Negate FPREG if negative
3691+  1B8D AF                  XOR     A               ; Zero A
3692+  1B8E F5                  PUSH    AF              ; Save it
3693+  1B8F CD 3F 1C            CALL    RNGTST          ; Test number is in range
3694+  1B92 01 43 91    SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
3695+  1B95 11 F8 4F            LD      DE,4FF8H
3696+  1B98 CD 4B 1A            CALL    CMPNUM          ; Compare numbers
3697+  1B9B B7                  OR      A
3698+  1B9C E2 B0 1B            JP      PO,INRNG        ; > 99999.9 - Sort it out
3699+  1B9F F1                  POP     AF              ; Restore count
3700+  1BA0 CD 2D 1B            CALL    MULTEN          ; Multiply by ten
3701+  1BA3 F5                  PUSH    AF              ; Re-save count
3702+  1BA4 C3 92 1B            JP      SIXDIG          ; Test it again
3703+  1BA7             
3704+  1BA7 CD 18 19    GTSIXD: CALL    DIV10           ; Divide by 10
3705+  1BAA F1                  POP     AF              ; Get count
3706+  1BAB 3C                  INC     A               ; Count divides
3707+  1BAC F5                  PUSH    AF              ; Re-save count
3708+  1BAD CD 3F 1C            CALL    RNGTST          ; Test number is in range
3709+  1BB0 CD 78 17    INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
3710+  1BB3 3C                  INC     A
3711+  1BB4 CD 78 1A            CALL    FPINT           ; F.P to integer
3712+  1BB7 CD 11 1A            CALL    FPBCDE          ; Move BCDE to FPREG
3713+  1BBA 01 06 03            LD      BC,0306H        ; 1E+06 to 1E-03 range
3714+  1BBD F1                  POP     AF              ; Restore count
3715+  1BBE 81                  ADD     A,C             ; 6 digits before point
3716+  1BBF 3C                  INC     A               ; Add one
3717+  1BC0 FA CC 1B            JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
3718+  1BC3 FE 08               CP      6+1+1           ; More than 999999 ?
3719+  1BC5 D2 CC 1B            JP      NC,MAKNUM       ; Yes - Do it in 'E' form
3720+  1BC8 3C                  INC     A               ; Adjust for exponent
3721+  1BC9 47                  LD      B,A             ; Exponent of number
3722+  1BCA 3E 02               LD      A,2             ; Make it zero after
3723+  1BCC             
3724+  1BCC 3D          MAKNUM: DEC     A               ; Adjust for digits to do
3725+  1BCD 3D                  DEC     A
3726+  1BCE E1                  POP     HL              ; Restore buffer address
3727+  1BCF F5                  PUSH    AF              ; Save count
3728+  1BD0 11 52 1C            LD      DE,POWERS       ; Powers of ten
3729+  1BD3 05                  DEC     B               ; Count digits before point
3730+  1BD4 C2 DD 1B            JP      NZ,DIGTXT       ; Not zero - Do number
3731+  1BD7 36 2E               LD      (HL),'.'        ; Save point
3732+  1BD9 23                  INC     HL              ; Move on
3733+  1BDA 36 30               LD      (HL),'0'        ; Save zero
3734+  1BDC 23                  INC     HL              ; Move on
3735+  1BDD 05          DIGTXT: DEC     B               ; Count digits before point
3736+  1BDE 36 2E               LD      (HL),'.'        ; Save point in case
3737+  1BE0 CC 26 1A            CALL    Z,INCHL         ; Last digit - move on
3738+  1BE3 C5                  PUSH    BC              ; Save digits before point
3739+  1BE4 E5                  PUSH    HL              ; Save buffer address
3740+  1BE5 D5                  PUSH    DE              ; Save powers of ten
3741+  1BE6 CD 1C 1A            CALL    BCDEFP          ; Move FPREG to BCDE
3742+  1BE9 E1                  POP     HL              ; Powers of ten table
3743+  1BEA 06 2F               LD      B, '0'-1        ; ASCII '0' - 1
3744+  1BEC 04          TRYAGN: INC     B               ; Count subtractions
3745+  1BED 7B                  LD      A,E             ; Get LSB
3746+  1BEE 96                  SUB     (HL)            ; Subtract LSB
3747+  1BEF 5F                  LD      E,A             ; Save LSB
3748+  1BF0 23                  INC     HL
3749+  1BF1 7A                  LD      A,D             ; Get NMSB
3750+  1BF2 9E                  SBC     A,(HL)          ; Subtract NMSB
3751+  1BF3 57                  LD      D,A             ; Save NMSB
3752+  1BF4 23                  INC     HL
3753+  1BF5 79                  LD      A,C             ; Get MSB
3754+  1BF6 9E                  SBC     A,(HL)          ; Subtract MSB
3755+  1BF7 4F                  LD      C,A             ; Save MSB
3756+  1BF8 2B                  DEC     HL              ; Point back to start
3757+  1BF9 2B                  DEC     HL
3758+  1BFA D2 EC 1B            JP      NC,TRYAGN       ; No overflow - Try again
3759+  1BFD CD 2F 18            CALL    PLUCDE          ; Restore number
3760+  1C00 23                  INC     HL              ; Start of next number
3761+  1C01 CD 11 1A            CALL    FPBCDE          ; Move BCDE to FPREG
3762+  1C04 EB                  EX      DE,HL           ; Save point in table
3763+  1C05 E1                  POP     HL              ; Restore buffer address
3764+  1C06 70                  LD      (HL),B          ; Save digit in buffer
3765+  1C07 23                  INC     HL              ; And move on
3766+  1C08 C1                  POP     BC              ; Restore digit count
3767+  1C09 0D                  DEC     C               ; Count digits
3768+  1C0A C2 DD 1B            JP      NZ,DIGTXT       ; More - Do them
3769+  1C0D 05                  DEC     B               ; Any decimal part?
3770+  1C0E CA 1D 1C            JP      Z,DOEBIT        ; No - Do 'E' bit
3771+  1C11 2B          SUPTLZ: DEC     HL              ; Move back through buffer
3772+  1C12 7E                  LD      A,(HL)          ; Get character
3773+  1C13 FE 30               CP      '0'             ; '0' character?
3774+  1C15 CA 11 1C            JP      Z,SUPTLZ        ; Yes - Look back for more
3775+  1C18 FE 2E               CP      '.'             ; A decimal point?
3776+  1C1A C4 26 1A            CALL    NZ,INCHL        ; Move back over digit
3777+  1C1D             
3778+  1C1D F1          DOEBIT: POP     AF              ; Get 'E' flag
3779+  1C1E CA 3C 1C            JP      Z,NOENED        ; No 'E' needed - End buffer
3780+  1C21 36 45               LD      (HL),'E'        ; Put 'E' in buffer
3781+  1C23 23                  INC     HL              ; And move on
3782+  1C24 36 2B               LD      (HL),'+'        ; Put '+' in buffer
3783+  1C26 F2 2D 1C            JP      P,OUTEXP        ; Positive - Output exponent
3784+  1C29 36 2D               LD      (HL),'-'        ; Put '-' in buffer
3785+  1C2B 2F                  CPL                     ; Negate exponent
3786+  1C2C 3C                  INC     A
3787+  1C2D 06 2F       OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
3788+  1C2F 04          EXPTEN: INC     B               ; Count subtractions
3789+  1C30 D6 0A               SUB     10              ; Tens digit
3790+  1C32 D2 2F 1C            JP      NC,EXPTEN       ; More to do
3791+  1C35 C6 3A               ADD     A,'0'+10        ; Restore and make ASCII
3792+  1C37 23                  INC     HL              ; Move on
3793+  1C38 70                  LD      (HL),B          ; Save MSB of exponent
3794+  1C39 23          JSTZER: INC     HL              ;
3795+  1C3A 77                  LD      (HL),A          ; Save LSB of exponent
3796+  1C3B 23                  INC     HL
3797+  1C3C 71          NOENED: LD      (HL),C          ; Mark end of buffer
3798+  1C3D E1                  POP     HL              ; Restore code string address
3799+  1C3E C9                  RET
3800+  1C3F             
3801+  1C3F 01 74 94    RNGTST: LD      BC,9474H        ; BCDE = 999999.
3802+  1C42 11 F7 23            LD      DE,23F7H
3803+  1C45 CD 4B 1A            CALL    CMPNUM          ; Compare numbers
3804+  1C48 B7                  OR      A
3805+  1C49 E1                  POP     HL              ; Return address to HL
3806+  1C4A E2 A7 1B            JP      PO,GTSIXD       ; Too big - Divide by ten
3807+  1C4D E9                  JP      (HL)            ; Otherwise return to caller
3808+  1C4E             
3809+  1C4E 00 00 00 80 HALF:   .BYTE      00H,00H,00H,80H ; 0.5
3810+  1C52             
3811+  1C52 A0 86 01    POWERS: .BYTE      0A0H,086H,001H  ; 100000
3812+  1C55 10 27 00            .BYTE      010H,027H,000H  ;  10000
3813+  1C58 E8 03 00            .BYTE      0E8H,003H,000H  ;   1000
3814+  1C5B 64 00 00            .BYTE      064H,000H,000H  ;    100
3815+  1C5E 0A 00 00            .BYTE      00AH,000H,000H  ;     10
3816+  1C61 01 00 00            .BYTE      001H,000H,000H  ;      1
3817+  1C64             
3818+  1C64 21 F9 19    NEGAFT: LD  HL,INVSGN           ; Negate result
3819+  1C67 E3                  EX      (SP),HL         ; To be done after caller
3820+  1C68 E9                  JP      (HL)            ; Return to caller
3821+  1C69             
3822+  1C69 CD 01 1A    SQR:    CALL    STAKFP          ; Put value on stack
3823+  1C6C 21 4E 1C            LD      HL,HALF         ; Set power to 1/2
3824+  1C6F CD 0E 1A            CALL    PHLTFP          ; Move 1/2 to FPREG
3825+  1C72             
3826+  1C72 C1          POWER:  POP     BC              ; Get base
3827+  1C73 D1                  POP     DE
3828+  1C74 CD D0 19            CALL    TSTSGN          ; Test sign of power
3829+  1C77 78                  LD      A,B             ; Get exponent of base
3830+  1C78 CA B7 1C            JP      Z,EXP           ; Make result 1 if zero
3831+  1C7B F2 82 1C            JP      P,POWER1        ; Positive base - Ok
3832+  1C7E B7                  OR      A               ; Zero to negative power?
3833+  1C7F CA 2C 07            JP      Z,DZERR         ; Yes - ?/0 Error
3834+  1C82 B7          POWER1: OR      A               ; Base zero?
3835+  1C83 CA F1 17            JP      Z,SAVEXP        ; Yes - Return zero
3836+  1C86 D5                  PUSH    DE              ; Save base
3837+  1C87 C5                  PUSH    BC
3838+  1C88 79                  LD      A,C             ; Get MSB of base
3839+  1C89 F6 7F               OR      01111111B       ; Get sign status
3840+  1C8B CD 1C 1A            CALL    BCDEFP          ; Move power to BCDE
3841+  1C8E F2 9F 1C            JP      P,POWER2        ; Positive base - Ok
3842+  1C91 D5                  PUSH    DE              ; Save power
3843+  1C92 C5                  PUSH    BC
3844+  1C93 CD A3 1A            CALL    INT             ; Get integer of power
3845+  1C96 C1                  POP     BC              ; Restore power
3846+  1C97 D1                  POP     DE
3847+  1C98 F5                  PUSH    AF              ; MSB of base
3848+  1C99 CD 4B 1A            CALL    CMPNUM          ; Power an integer?
3849+  1C9C E1                  POP     HL              ; Restore MSB of base
3850+  1C9D 7C                  LD      A,H             ; but don't affect flags
3851+  1C9E 1F                  RRA                     ; Exponent odd or even?
3852+  1C9F E1          POWER2: POP     HL              ; Restore MSB and exponent
3853+  1CA0 22 96 31            LD      (FPREG+2),HL    ; Save base in FPREG
3854+  1CA3 E1                  POP     HL              ; LSBs of base
3855+  1CA4 22 94 31            LD      (FPREG),HL      ; Save in FPREG
3856+  1CA7 DC 64 1C            CALL    C,NEGAFT        ; Odd power - Negate result
3857+  1CAA CC F9 19            CALL    Z,INVSGN        ; Negative base - Negate it
3858+  1CAD D5                  PUSH    DE              ; Save power
3859+  1CAE C5                  PUSH    BC
3860+  1CAF CD 84 18            CALL    LOG             ; Get LOG of base
3861+  1CB2 C1                  POP     BC              ; Restore power
3862+  1CB3 D1                  POP     DE
3863+  1CB4 CD C5 18            CALL    FPMULT          ; Multiply LOG by power
3864+  1CB7             
3865+  1CB7 CD 01 1A    EXP:    CALL    STAKFP          ; Put value on stack
3866+  1CBA 01 38 81            LD      BC,08138H       ; BCDE = 1/Ln(2)
3867+  1CBD 11 3B AA            LD      DE,0AA3BH
3868+  1CC0 CD C5 18            CALL    FPMULT          ; Multiply value by 1/LN(2)
3869+  1CC3 3A 97 31            LD      A,(FPEXP)       ; Get exponent
3870+  1CC6 FE 88               CP      80H+8           ; Is it in range?
3871+  1CC8 D2 AC 19            JP      NC,OVTST1       ; No - Test for overflow
3872+  1CCB CD A3 1A            CALL    INT             ; Get INT of FPREG
3873+  1CCE C6 80               ADD     A,80H           ; For excess 128
3874+  1CD0 C6 02               ADD     A,2             ; Exponent > 126?
3875+  1CD2 DA AC 19            JP      C,OVTST1        ; Yes - Test for overflow
3876+  1CD5 F5                  PUSH    AF              ; Save scaling factor
3877+  1CD6 21 73 18            LD      HL,UNITY        ; Point to 1.
3878+  1CD9 CD 7B 17            CALL    ADDPHL          ; Add 1 to FPREG
3879+  1CDC CD BC 18            CALL    MULLN2          ; Multiply by LN(2)
3880+  1CDF F1                  POP     AF              ; Restore scaling factor
3881+  1CE0 C1                  POP     BC              ; Restore exponent
3882+  1CE1 D1                  POP     DE
3883+  1CE2 F5                  PUSH    AF              ; Save scaling factor
3884+  1CE3 CD 87 17            CALL    SUBCDE          ; Subtract exponent from FPREG
3885+  1CE6 CD F9 19            CALL    INVSGN          ; Negate result
3886+  1CE9 21 F7 1C            LD      HL,EXPTAB       ; Coefficient table
3887+  1CEC CD 27 1D            CALL    SMSER1          ; Sum the series
3888+  1CEF 11 00 00            LD      DE,0            ; Zero LSBs
3889+  1CF2 C1                  POP     BC              ; Scaling factor
3890+  1CF3 4A                  LD      C,D             ; Zero MSB
3891+  1CF4 C3 C5 18            JP      FPMULT          ; Scale result to correct value
3892+  1CF7             
3893+  1CF7 08          EXPTAB: .BYTE      8                       ; Table used by EXP
3894+  1CF8 40 2E 94 74         .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
3895+  1CFC 70 4F 2E 77         .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
3896+  1D00 6E 02 88 7A         .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
3897+  1D04 E6 A0 2A 7C         .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
3898+  1D08 50 AA AA 7E         .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
3899+  1D0C FF FF 7F 7F         .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
3900+  1D10 00 00 80 81         .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
3901+  1D14 00 00 00 81         .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
3902+  1D18             
3903+  1D18 CD 01 1A    SUMSER: CALL    STAKFP          ; Put FPREG on stack
3904+  1D1B 11 C3 18            LD      DE,MULT         ; Multiply by "X"
3905+  1D1E D5                  PUSH    DE              ; To be done after
3906+  1D1F E5                  PUSH    HL              ; Save address of table
3907+  1D20 CD 1C 1A            CALL    BCDEFP          ; Move FPREG to BCDE
3908+  1D23 CD C5 18            CALL    FPMULT          ; Square the value
3909+  1D26 E1                  POP     HL              ; Restore address of table
3910+  1D27 CD 01 1A    SMSER1: CALL    STAKFP          ; Put value on stack
3911+  1D2A 7E                  LD      A,(HL)          ; Get number of coefficients
3912+  1D2B 23                  INC     HL              ; Point to start of table
3913+  1D2C CD 0E 1A            CALL    PHLTFP          ; Move coefficient to FPREG
3914+  1D2F 06                  .BYTE      06H             ; Skip "POP AF"
3915+  1D30 F1          SUMLP:  POP     AF              ; Restore count
3916+  1D31 C1                  POP     BC              ; Restore number
3917+  1D32 D1                  POP     DE
3918+  1D33 3D                  DEC     A               ; Cont coefficients
3919+  1D34 C8                  RET     Z               ; All done
3920+  1D35 D5                  PUSH    DE              ; Save number
3921+  1D36 C5                  PUSH    BC
3922+  1D37 F5                  PUSH    AF              ; Save count
3923+  1D38 E5                  PUSH    HL              ; Save address in table
3924+  1D39 CD C5 18            CALL    FPMULT          ; Multiply FPREG by BCDE
3925+  1D3C E1                  POP     HL              ; Restore address in table
3926+  1D3D CD 1F 1A            CALL    LOADFP          ; Number at HL to BCDE
3927+  1D40 E5                  PUSH    HL              ; Save address in table
3928+  1D41 CD 8A 17            CALL    FPADD           ; Add coefficient to FPREG
3929+  1D44 E1                  POP     HL              ; Restore address in table
3930+  1D45 C3 30 1D            JP      SUMLP           ; More coefficients
3931+  1D48             
3932+  1D48 CD D0 19    RND:    CALL    TSTSGN          ; Test sign of FPREG
3933+  1D4B 21 C9 30            LD      HL,SEED+2       ; Random number seed
3934+  1D4E FA A9 1D            JP      M,RESEED        ; Negative - Re-seed
3935+  1D51 21 EA 30            LD      HL,LSTRND       ; Last random number
3936+  1D54 CD 0E 1A            CALL    PHLTFP          ; Move last RND to FPREG
3937+  1D57 21 C9 30            LD      HL,SEED+2       ; Random number seed
3938+  1D5A C8                  RET     Z               ; Return if RND(0)
3939+  1D5B 86                  ADD     A,(HL)          ; Add (SEED)+2)
3940+  1D5C E6 07               AND     00000111B       ; 0 to 7
3941+  1D5E 06 00               LD      B,0
3942+  1D60 77                  LD      (HL),A          ; Re-save seed
3943+  1D61 23                  INC     HL              ; Move to coefficient table
3944+  1D62 87                  ADD     A,A             ; 4 bytes
3945+  1D63 87                  ADD     A,A             ; per entry
3946+  1D64 4F                  LD      C,A             ; BC = Offset into table
3947+  1D65 09                  ADD     HL,BC           ; Point to coefficient
3948+  1D66 CD 1F 1A            CALL    LOADFP          ; Coefficient to BCDE
3949+  1D69 CD C5 18            CALL    FPMULT  ;       ; Multiply FPREG by coefficient
3950+  1D6C 3A C8 30            LD      A,(SEED+1)      ; Get (SEED+1)
3951+  1D6F 3C                  INC     A               ; Add 1
3952+  1D70 E6 03               AND     00000011B       ; 0 to 3
3953+  1D72 06 00               LD      B,0
3954+  1D74 FE 01               CP      1               ; Is it zero?
3955+  1D76 88                  ADC     A,B             ; Yes - Make it 1
3956+  1D77 32 C8 30            LD      (SEED+1),A      ; Re-save seed
3957+  1D7A 21 AD 1D            LD      HL,RNDTAB-4     ; Addition table
3958+  1D7D 87                  ADD     A,A             ; 4 bytes
3959+  1D7E 87                  ADD     A,A             ; per entry
3960+  1D7F 4F                  LD      C,A             ; BC = Offset into table
3961+  1D80 09                  ADD     HL,BC           ; Point to value
3962+  1D81 CD 7B 17            CALL    ADDPHL          ; Add value to FPREG
3963+  1D84 CD 1C 1A    RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
3964+  1D87 7B                  LD      A,E             ; Get LSB
3965+  1D88 59                  LD      E,C             ; LSB = MSB
3966+  1D89 EE 4F               XOR     01001111B       ; Fiddle around
3967+  1D8B 4F                  LD      C,A             ; New MSB
3968+  1D8C 36 80               LD      (HL),80H        ; Set exponent
3969+  1D8E 2B                  DEC     HL              ; Point to MSB
3970+  1D8F 46                  LD      B,(HL)          ; Get MSB
3971+  1D90 36 80               LD      (HL),80H        ; Make value -0.5
3972+  1D92 21 C7 30            LD      HL,SEED         ; Random number seed
3973+  1D95 34                  INC     (HL)            ; Count seed
3974+  1D96 7E                  LD      A,(HL)          ; Get seed
3975+  1D97 D6 AB               SUB     171             ; Do it modulo 171
3976+  1D99 C2 A0 1D            JP      NZ,RND2         ; Non-zero - Ok
3977+  1D9C 77                  LD      (HL),A          ; Zero seed
3978+  1D9D 0C                  INC     C               ; Fillde about
3979+  1D9E 15                  DEC     D               ; with the
3980+  1D9F 1C                  INC     E               ; number
3981+  1DA0 CD DB 17    RND2:   CALL    BNORM           ; Normalise number
3982+  1DA3 21 EA 30            LD      HL,LSTRND       ; Save random number
3983+  1DA6 C3 28 1A            JP      FPTHL           ; Move FPREG to last and return
3984+  1DA9             
3985+  1DA9 77          RESEED: LD      (HL),A          ; Re-seed random numbers
3986+  1DAA 2B                  DEC     HL
3987+  1DAB 77                  LD      (HL),A
3988+  1DAC 2B                  DEC     HL
3989+  1DAD 77                  LD      (HL),A
3990+  1DAE C3 84 1D            JP      RND1            ; Return RND seed
3991+  1DB1             
3992+  1DB1 68 B1 46 68 RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
3993+  1DB5 99 E9 92 69         .BYTE   099H,0E9H,092H,069H
3994+  1DB9 10 D1 75 68         .BYTE   010H,0D1H,075H,068H
3995+  1DBD             
3996+  1DBD 21 07 1E    COS:    LD      HL,HALFPI       ; Point to PI/2
3997+  1DC0 CD 7B 17            CALL    ADDPHL          ; Add it to PPREG
3998+  1DC3 CD 01 1A    SIN:    CALL    STAKFP          ; Put angle on stack
3999+  1DC6 01 49 83            LD      BC,8349H        ; BCDE = 2 PI
4000+  1DC9 11 DB 0F            LD      DE,0FDBH
4001+  1DCC CD 11 1A            CALL    FPBCDE          ; Move 2 PI to FPREG
4002+  1DCF C1                  POP     BC              ; Restore angle
4003+  1DD0 D1                  POP     DE
4004+  1DD1 CD 26 19            CALL    DVBCDE          ; Divide angle by 2 PI
4005+  1DD4 CD 01 1A            CALL    STAKFP          ; Put it on stack
4006+  1DD7 CD A3 1A            CALL    INT             ; Get INT of result
4007+  1DDA C1                  POP     BC              ; Restore number
4008+  1DDB D1                  POP     DE
4009+  1DDC CD 87 17            CALL    SUBCDE          ; Make it 0 <= value < 1
4010+  1DDF 21 0B 1E            LD      HL,QUARTR       ; Point to 0.25
4011+  1DE2 CD 81 17            CALL    SUBPHL          ; Subtract value from 0.25
4012+  1DE5 CD D0 19            CALL    TSTSGN          ; Test sign of value
4013+  1DE8 37                  SCF                     ; Flag positive
4014+  1DE9 F2 F3 1D            JP      P,SIN1          ; Positive - Ok
4015+  1DEC CD 78 17            CALL    ROUND           ; Add 0.5 to value
4016+  1DEF CD D0 19            CALL    TSTSGN          ; Test sign of value
4017+  1DF2 B7                  OR      A               ; Flag negative
4018+  1DF3 F5          SIN1:   PUSH    AF              ; Save sign
4019+  1DF4 F4 F9 19            CALL    P,INVSGN        ; Negate value if positive
4020+  1DF7 21 0B 1E            LD      HL,QUARTR       ; Point to 0.25
4021+  1DFA CD 7B 17            CALL    ADDPHL          ; Add 0.25 to value
4022+  1DFD F1                  POP     AF              ; Restore sign
4023+  1DFE D4 F9 19            CALL    NC,INVSGN       ; Negative - Make positive
4024+  1E01 21 0F 1E            LD      HL,SINTAB       ; Coefficient table
4025+  1E04 C3 18 1D            JP      SUMSER          ; Evaluate sum of series
4026+  1E07             
4027+  1E07 DB 0F 49 81 HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
4028+  1E0B             
4029+  1E0B 00 00 00 7F QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
4030+  1E0F             
4031+  1E0F 05          SINTAB: .BYTE   5                       ; Table used by SIN
4032+  1E10 BA D7 1E 86         .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
4033+  1E14 64 26 99 87         .BYTE   064H,026H,099H,087H     ;-76.575
4034+  1E18 58 34 23 87         .BYTE   058H,034H,023H,087H     ; 81.602
4035+  1E1C E0 5D A5 86         .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
4036+  1E20 DA 0F 49 83         .BYTE   0DAH,00FH,049H,083H     ;  6.2832
4037+  1E24             
4038+  1E24 CD 01 1A    TAN:    CALL    STAKFP          ; Put angle on stack
4039+  1E27 CD C3 1D            CALL    SIN             ; Get SIN of angle
4040+  1E2A C1                  POP     BC              ; Restore angle
4041+  1E2B E1                  POP     HL
4042+  1E2C CD 01 1A            CALL    STAKFP          ; Save SIN of angle
4043+  1E2F EB                  EX      DE,HL           ; BCDE = Angle
4044+  1E30 CD 11 1A            CALL    FPBCDE          ; Angle to FPREG
4045+  1E33 CD BD 1D            CALL    COS             ; Get COS of angle
4046+  1E36 C3 24 19            JP      DIV             ; TAN = SIN / COS
4047+  1E39             
4048+  1E39 CD D0 19    ATN:    CALL    TSTSGN          ; Test sign of value
4049+  1E3C FC 64 1C            CALL    M,NEGAFT        ; Negate result after if -ve
4050+  1E3F FC F9 19            CALL    M,INVSGN        ; Negate value if -ve
4051+  1E42 3A 97 31            LD      A,(FPEXP)       ; Get exponent
4052+  1E45 FE 81               CP      81H             ; Number less than 1?
4053+  1E47 DA 56 1E            JP      C,ATN1          ; Yes - Get arc tangnt
4054+  1E4A 01 00 81            LD      BC,8100H        ; BCDE = 1
4055+  1E4D 51                  LD      D,C
4056+  1E4E 59                  LD      E,C
4057+  1E4F CD 26 19            CALL    DVBCDE          ; Get reciprocal of number
4058+  1E52 21 81 17            LD      HL,SUBPHL       ; Sub angle from PI/2
4059+  1E55 E5                  PUSH    HL              ; Save for angle > 1
4060+  1E56 21 60 1E    ATN1:   LD      HL,ATNTAB       ; Coefficient table
4061+  1E59 CD 18 1D            CALL    SUMSER          ; Evaluate sum of series
4062+  1E5C 21 07 1E            LD      HL,HALFPI       ; PI/2 - angle in case > 1
4063+  1E5F C9                  RET                     ; Number > 1 - Sub from PI/2
4064+  1E60             
4065+  1E60 09          ATNTAB: .BYTE   9                       ; Table used by ATN
4066+  1E61 4A D7 3B 78         .BYTE   04AH,0D7H,03BH,078H     ; 1/17
4067+  1E65 02 6E 84 7B         .BYTE   002H,06EH,084H,07BH     ;-1/15
4068+  1E69 FE C1 2F 7C         .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
4069+  1E6D 74 31 9A 7D         .BYTE   074H,031H,09AH,07DH     ;-1/11
4070+  1E71 84 3D 5A 7D         .BYTE   084H,03DH,05AH,07DH     ; 1/9
4071+  1E75 C8 7F 91 7E         .BYTE   0C8H,07FH,091H,07EH     ;-1/7
4072+  1E79 E4 BB 4C 7E         .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
4073+  1E7D 6C AA AA 7F         .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
4074+  1E81 00 00 00 81         .BYTE   000H,000H,000H,081H     ; 1/1
4075+  1E85             
4076+  1E85             
4077+  1E85 C9          ARET:   RET                     ; A RETurn instruction
4078+  1E86             
4079+  1E86 D7          GETINP: RST	    10H             ;input a character
4080+  1E87 C9                  RET
4081+  1E88             
4082+  1E88             CLS: 
4083+  1E88 3E 0C               LD      A,CS            ; ASCII Clear screen
4084+  1E8A C3 C2 1F            JP      MONOUT          ; Output character
4085+  1E8D             
4086+  1E8D CD 4F 17    WIDTH:  CALL    GETINT          ; Get integer 0-255
4087+  1E90 7B                  LD      A,E             ; Width to A
4088+  1E91 32 F2 30            LD      (LWIDTH),A      ; Set width
4089+  1E94 C9                  RET
4090+  1E95             
4091+  1E95 CD EE 0F    LINES:  CALL    GETNUM          ; Get a number
4092+  1E98 CD 33 0C            CALL    DEINT           ; Get integer -32768 to 32767
4093+  1E9B ED 53 F6 30         LD      (LINESC),DE     ; Set lines counter
4094+  1E9F ED 53 F8 30         LD      (LINESN),DE     ; Set lines number
4095+  1EA3 C9                  RET
4096+  1EA4             
4097+  1EA4 CD 33 0C    DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
4098+  1EA7 D5                  PUSH    DE              ; Save number
4099+  1EA8 E1                  POP     HL              ; Number to HL
4100+  1EA9 46                  LD      B,(HL)          ; Get LSB of contents
4101+  1EAA 23                  INC     HL
4102+  1EAB 7E                  LD      A,(HL)          ; Get MSB of contents
4103+  1EAC C3 A9 13            JP      ABPASS          ; Return integer AB
4104+  1EAF             
4105+  1EAF CD EE 0F    DOKE:   CALL    GETNUM          ; Get a number
4106+  1EB2 CD 33 0C            CALL    DEINT           ; Get integer -32768 to 32767
4107+  1EB5 D5                  PUSH    DE              ; Save address
4108+  1EB6 CD F7 09            CALL    CHKSYN          ; Make sure ',' follows
4109+  1EB9 2C                  .BYTE      ','
4110+  1EBA CD EE 0F            CALL    GETNUM          ; Get a number
4111+  1EBD CD 33 0C            CALL    DEINT           ; Get integer -32768 to 32767
4112+  1EC0 E3                  EX      (SP),HL         ; Save value,get address
4113+  1EC1 73                  LD      (HL),E          ; Save LSB of value
4114+  1EC2 23                  INC     HL
4115+  1EC3 72                  LD      (HL),D          ; Save MSB of value
4116+  1EC4 E1                  POP     HL              ; Restore code string address
4117+  1EC5 C9                  RET
4118+  1EC6             
4119+  1EC6             
4120+  1EC6             ; HEX$(nn) Convert 16 bit number to Hexadecimal string
4121+  1EC6             
4122+  1EC6 CD F1 0F    HEX: 	CALL	TSTNUM          ; Verify it's a number
4123+  1EC9 CD 33 0C            CALL	DEINT           ; Get integer -32768 to 32767
4124+  1ECC C5                  PUSH	BC              ; Save contents of BC
4125+  1ECD 21 99 31            LD	    HL,PBUFF
4126+  1ED0 7A                  LD	    A,D             ; Get high order into A
4127+  1ED1 FE 00               CP      $0
4128+  1ED3 28 0C       		JR      Z,HEX2          ; Skip output if both high digits are zero
4129+  1ED5 CD FE 1E            CALL    BYT2ASC         ; Convert D to ASCII
4130+  1ED8 78          		LD      A,B
4131+  1ED9 FE 30       		CP      '0'
4132+  1EDB 28 02       		JR      Z,HEX1          ; Don't store high digit if zero
4133+  1EDD 70                  LD	    (HL),B          ; Store it to PBUFF
4134+  1EDE 23                  INC	    HL              ; Next location
4135+  1EDF 71          HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
4136+  1EE0 23                  INC     HL              ; Next location
4137+  1EE1 7B          HEX2:   LD	    A,E             ; Get lower byte
4138+  1EE2 CD FE 1E            CALL    BYT2ASC         ; Convert E to ASCII
4139+  1EE5 7A          		LD      A,D
4140+  1EE6 FE 00               CP      $0
4141+  1EE8 20 05       		JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
4142+  1EEA 78          		LD      A,B
4143+  1EEB FE 30       		CP      '0'             ; If high digit of lower byte is zero then don't print
4144+  1EED 28 02       		JR      Z,HEX4
4145+  1EEF 70          HEX3:   LD      (HL),B          ; to PBUFF+2
4146+  1EF0 23                  INC     HL              ; Next location
4147+  1EF1 71          HEX4:   LD      (HL),C          ; to PBUFF+3
4148+  1EF2 23                  INC     HL              ; PBUFF+4 to zero
4149+  1EF3 AF                  XOR     A               ; Terminating character
4150+  1EF4 77                  LD      (HL),A          ; Store zero to terminate
4151+  1EF5 23                  INC     HL              ; Make sure PBUFF is terminated
4152+  1EF6 77                  LD      (HL),A          ; Store the double zero there
4153+  1EF7 C1                  POP     BC              ; Get BC back
4154+  1EF8 21 99 31            LD      HL,PBUFF        ; Reset to start of PBUFF
4155+  1EFB C3 57 14            JP      STR1            ; Convert the PBUFF to a string and return it
4156+  1EFE             
4157+  1EFE 47          BYT2ASC	LD      B,A             ; Save original value
4158+  1EFF E6 0F               AND     $0F             ; Strip off upper nybble
4159+  1F01 FE 0A               CP      $0A             ; 0-9?
4160+  1F03 38 02               JR      C,ADD30         ; If A-F, add 7 more
4161+  1F05 C6 07               ADD     A,$07           ; Bring value up to ASCII A-F
4162+  1F07 C6 30       ADD30	ADD     A,$30           ; And make ASCII
4163+  1F09 4F                  LD      C,A             ; Save converted char to C
4164+  1F0A 78                  LD      A,B             ; Retrieve original value
4165+  1F0B 0F                  RRCA                    ; and Rotate it right
4166+  1F0C 0F                  RRCA
4167+  1F0D 0F                  RRCA
4168+  1F0E 0F                  RRCA
4169+  1F0F E6 0F               AND     $0F             ; Mask off upper nybble
4170+  1F11 FE 0A               CP      $0A             ; 0-9? < A hex?
4171+  1F13 38 02               JR      C,ADD301        ; Skip Add 7
4172+  1F15 C6 07               ADD     A,$07           ; Bring it up to ASCII A-F
4173+  1F17 C6 30       ADD301	ADD     A,$30           ; And make it full ASCII
4174+  1F19 47                  LD      B,A             ; Store high order byte
4175+  1F1A C9                  RET	
4176+  1F1B             
4177+  1F1B             ; Convert "&Hnnnn" to FPREG
4178+  1F1B             ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
4179+  1F1B             ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
4180+  1F1B EB          HEXTFP  EX      DE,HL           ; Move code string pointer to DE
4181+  1F1C 21 00 00            LD      HL,$0000        ; Zero out the value
4182+  1F1F CD 34 1F            CALL    GETHEX          ; Check the number for valid hex
4183+  1F22 DA 54 1F            JP      C,HXERR         ; First value wasn't hex, HX error
4184+  1F25 18 05               JR      HEXLP1          ; Convert first character
4185+  1F27 CD 34 1F    HEXLP   CALL    GETHEX          ; Get second and addtional characters
4186+  1F2A 38 1F               JR      C,HEXIT         ; Exit if not a hex character
4187+  1F2C 29          HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
4188+  1F2D 29                  ADD     HL,HL
4189+  1F2E 29                  ADD     HL,HL
4190+  1F2F 29                  ADD     HL,HL
4191+  1F30 B5                  OR      L               ; Add in D0-D3 into L
4192+  1F31 6F                  LD      L,A             ; Save new value
4193+  1F32 18 F3               JR      HEXLP           ; And continue until all hex characters are in
4194+  1F34             
4195+  1F34 13          GETHEX  INC     DE              ; Next location
4196+  1F35 1A                  LD      A,(DE)          ; Load character at pointer
4197+  1F36 FE 20               CP      ' '
4198+  1F38 CA 34 1F            JP      Z,GETHEX        ; Skip spaces
4199+  1F3B D6 30               SUB     $30             ; Get absolute value
4200+  1F3D D8                  RET     C               ; < "0", error
4201+  1F3E FE 0A               CP      $0A
4202+  1F40 38 05               JR      C,NOSUB7        ; Is already in the range 0-9
4203+  1F42 D6 07               SUB     $07             ; Reduce to A-F
4204+  1F44 FE 0A               CP      $0A             ; Value should be $0A-$0F at this point
4205+  1F46 D8                  RET     C               ; CY set if was :            ; < = > ? @
4206+  1F47 FE 10       NOSUB7  CP      $10             ; > Greater than "F"?
4207+  1F49 3F                  CCF
4208+  1F4A C9                  RET                     ; CY set if it wasn't valid hex
4209+  1F4B                 
4210+  1F4B EB          HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
4211+  1F4C 7A                  LD      A,D             ; Load DE into AC
4212+  1F4D 4B                  LD      C,E             ; For prep to 
4213+  1F4E E5                  PUSH    HL
4214+  1F4F CD A8 13            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4215+  1F52 E1                  POP     HL
4216+  1F53 C9                  RET
4217+  1F54             
4218+  1F54 1E 26       HXERR:  LD      E,HX            ; ?HEX Error
4219+  1F56 C3 3D 07            JP      ERROR
4220+  1F59             
4221+  1F59             ; BIN$(NN) Convert integer to a 1-16 char binary string
4222+  1F59 CD F1 0F    BIN:    CALL    TSTNUM          ; Verify it's a number
4223+  1F5C CD 33 0C            CALL    DEINT           ; Get integer -32768 to 32767
4224+  1F5F C5          BIN2:   PUSH    BC              ; Save contents of BC
4225+  1F60 21 99 31            LD      HL,PBUFF
4226+  1F63 06 11               LD      B,17            ; One higher than max char count
4227+  1F65             ZEROSUP:                        ; Suppress leading zeros
4228+  1F65 05                  DEC     B               ; Max 16 chars
4229+  1F66 78                  LD      A,B
4230+  1F67 FE 01               CP      $01
4231+  1F69 28 08               JR      Z,BITOUT        ; Always output at least one character
4232+  1F6B CB 13               RL      E
4233+  1F6D CB 12               RL      D
4234+  1F6F 30 F4               JR      NC,ZEROSUP
4235+  1F71 18 04               JR      BITOUT2
4236+  1F73             BITOUT:      
4237+  1F73 CB 13               RL      E
4238+  1F75 CB 12               RL      D               ; Top bit now in carry
4239+  1F77             BITOUT2:
4240+  1F77 3E 30               LD      A,'0'           ; Char for '0'
4241+  1F79 CE 00               ADC     A,0             ; If carry set then '0' --> '1'
4242+  1F7B 77                  LD      (HL),A
4243+  1F7C 23                  INC     HL
4244+  1F7D 05                  DEC     B
4245+  1F7E 20 F3               JR      NZ,BITOUT
4246+  1F80 AF                  XOR     A               ; Terminating character
4247+  1F81 77                  LD      (HL),A          ; Store zero to terminate
4248+  1F82 23                  INC     HL              ; Make sure PBUFF is terminated
4249+  1F83 77                  LD      (HL),A          ; Store the double zero there
4250+  1F84 C1                  POP     BC
4251+  1F85 21 99 31            LD      HL,PBUFF
4252+  1F88 C3 57 14            JP      STR1
4253+  1F8B             
4254+  1F8B             ; Convert "&Bnnnn" to FPREG
4255+  1F8B             ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
4256+  1F8B EB          BINTFP: EX      DE,HL           ; Move code string pointer to DE
4257+  1F8C 21 00 00            LD      HL,$0000        ; Zero out the value
4258+  1F8F CD A8 1F            CALL    CHKBIN          ; Check the number for valid bin
4259+  1F92 DA B6 1F            JP      C,BINERR        ; First value wasn't bin, HX error
4260+  1F95 D6 30       BINIT:  SUB     '0'
4261+  1F97 29                  ADD     HL,HL           ; Rotate HL left
4262+  1F98 B5                  OR      L
4263+  1F99 6F                  LD      L,A
4264+  1F9A CD A8 1F            CALL    CHKBIN          ; Get second and addtional characters
4265+  1F9D 30 F6               JR      NC,BINIT        ; Process if a bin character
4266+  1F9F EB                  EX      DE,HL           ; Value into DE, Code string into HL
4267+  1FA0 7A                  LD      A,D             ; Load DE into AC
4268+  1FA1 4B                  LD      C,E             ; For prep to 
4269+  1FA2 E5                  PUSH    HL
4270+  1FA3 CD A8 13            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4271+  1FA6 E1                  POP     HL
4272+  1FA7 C9                  RET
4273+  1FA8             
4274+  1FA8             ; Char is in A, NC if char is 0 or 1
4275+  1FA8 13          CHKBIN: INC     DE
4276+  1FA9 1A                  LD      A,(DE)
4277+  1FAA FE 20               CP      ' '
4278+  1FAC CA A8 1F            JP      Z,CHKBIN        ; Skip spaces
4279+  1FAF FE 30               CP      '0'             ; Set C if < '0'
4280+  1FB1 D8                  RET     C
4281+  1FB2 FE 32               CP      '2'
4282+  1FB4 3F                  CCF                     ; Set C if > '1'
4283+  1FB5 C9                  RET
4284+  1FB6             
4285+  1FB6 1E 28       BINERR: LD      E,BN            ; ?BIN Error
4286+  1FB8 C3 3D 07            JP      ERROR
4287+  1FBB             
4288+  1FBB             
4289+  1FBB             JJUMP1: 
4290+  1FBB DD 21 FF FF         LD      IX,-1           ; Flag cold start
4291+  1FBF C3 8D 03            JP      CSTART          ; Go and initialise
4292+  1FC2             
4293+  1FC2             MONOUT: 
4294+  1FC2 C3 08 00            JP      $0008           ; output a char
4295+  1FC5             
4296+  1FC5             
4297+  1FC5             MONITR: 
4298+  1FC5 C3 00 00            JP      $0000           ; Restart (Normally Monitor Start)
4299+  1FC8             
4300+  1FC8             
4301+  1FC8 3E 00       INITST: LD      A,0             ; Clear break flag
4302+  1FCA 32 FD 30            LD      (BRKFLG),A
4303+  1FCD C3 94 03            JP      INIT
4304+  1FD0             
4305+  1FD0 ED 45       ARETN:  RETN                    ; Return from NMI
4306+  1FD2             
4307+  1FD2             
4308+  1FD2 F5          TSTBIT: PUSH    AF              ; Save bit mask
4309+  1FD3 A0                  AND     B               ; Get common bits
4310+  1FD4 C1                  POP     BC              ; Restore bit mask
4311+  1FD5 B8                  CP      B               ; Same bit set?
4312+  1FD6 3E 00               LD      A,0             ; Return 0 in A
4313+  1FD8 C9                  RET
4314+  1FD9             
4315+  1FD9 CD 02 0A    OUTNCR: CALL    OUTC            ; Output character in A
4316+  1FDC C3 29 0E            JP      PRNTCRLF        ; Output CRLF
4317+  1FDF             
0723   1FDF             .end
tasm: Number of errors = 0
