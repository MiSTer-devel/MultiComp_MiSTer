0001   0000             ;==================================================================================
0002   0000             ; Contents of this file are copyright Grant Searle
0003   0000             ; HEX routines from Joel Owens.
0004   0000             ;
0005   0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0006   0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0007   0000             ;
0008   0000             ; http://searle.hostei.com/grant/index.html
0009   0000             ;
0010   0000             ; eMail: home.micros01@btinternet.com
0011   0000             ;
0012   0000             ; If the above don't work, please perform an Internet search to see if I have
0013   0000             ; updated the web page hosting service.
0014   0000             ;
0015   0000             ;==================================================================================
0016   0000             
0017   0000             ;------------------------------------------------------------------------------
0018   0000             ;
0019   0000             ; Z80 Monitor Rom
0020   0000             ;
0021   0000             ;------------------------------------------------------------------------------
0022   0000             ; General Equates
0023   0000             ;------------------------------------------------------------------------------
0024   0000             
0025   0000             ;CR		.EQU	0DH
0026   0000             ;LF		.EQU	0AH
0027   0000             ;ESC		.EQU	1BH
0028   0000             ;CTRLC	.EQU	03H
0029   0000             M_CLS		.EQU	0CH
0030   0000             
0031   0000             
0032   0000             loadAddr	.EQU	0D000h	; CP/M load address
0033   0000             numSecs		.EQU	24	; Number of 512 sectors to be loaded
0034   0000             
0035   0000             
0036   0000             RTS_HIGH	.EQU	0D5H
0037   0000             RTS_LOW		.EQU	095H
0038   0000             
0039   0000             ACIA0_D		.EQU	$81
0040   0000             ACIA0_C		.EQU	$80
0041   0000             ACIA1_D		.EQU	$83
0042   0000             ACIA1_C		.EQU	$82
0043   0000             
0044   0000             SD_DATA		.EQU	088H
0045   0000             SD_CONTROL	.EQU	089H
0046   0000             SD_STATUS	.EQU	089H
0047   0000             SD_LBA0		.EQU	08AH
0048   0000             SD_LBA1		.EQU	08BH
0049   0000             SD_LBA2		.EQU	08CH
0050   0000             
0051   3000             	.ORG	$3000
0052   3000             
0053   3000             primaryIO	.ds	1
0054   3001             secNo		.ds	1
0055   3002             dmaAddr		.ds	2
0056   3004             InitTxtB        .ds     2
0057   3006             	
0058   3006 00          lba0		.DB	00h
0059   3007 00          lba1		.DB	00h
0060   3008 00          lba2		.DB	00h
0061   3009 00          lba3		.DB	00h
0062   300A             
0063   300A             stackSpace	.ds	32
0064   302A             M_STACK   	.EQU    $	; Stack top
0065   302A             
0066   302A             
0067   302A             ;------------------------------------------------------------------------------
0068   302A             ;                         START OF MONITOR ROM
0069   302A             ;------------------------------------------------------------------------------
0070   302A             
0071   0000             MON		.ORG	$0000		; MONITOR ROM RESET VECTOR
0072   0000             ;------------------------------------------------------------------------------
0073   0000             ; Reset
0074   0000             ;------------------------------------------------------------------------------
0075   0000 F3          RST00		DI			;Disable INTerrupts
0076   0001 C3 A4 00    		JP	M_INIT		;Initialize Hardware and go
0077   0004 00          		NOP
0078   0005 00          		NOP
0079   0006 00          		NOP
0080   0007 00          		NOP
0081   0008             ;------------------------------------------------------------------------------
0082   0008             ; TX a character over RS232 wait for TXDONE first.
0083   0008             ;------------------------------------------------------------------------------
0084   0008 C3 32 00    RST08		JP	conout
0085   000B 00          		NOP
0086   000C 00          		NOP
0087   000D 00          		NOP
0088   000E 00          		NOP
0089   000F 00          		NOP
0090   0010             ;------------------------------------------------------------------------------
0091   0010             ; RX a character from buffer wait until char ready.
0092   0010             ;------------------------------------------------------------------------------
0093   0010 C3 1B 00    RST10		JP	conin
0094   0013 00          		NOP
0095   0014 00          		NOP
0096   0015 00          		NOP
0097   0016 00          		NOP
0098   0017 00          		NOP
0099   0018             ;------------------------------------------------------------------------------
0100   0018             ; Check input buffer status
0101   0018             ;------------------------------------------------------------------------------
0102   0018 C3 6C 00    RST18		JP	CKINCHAR
0103   001B             
0104   001B             
0105   001B             ;------------------------------------------------------------------------------
0106   001B             ; Console input routine
0107   001B             ; Use the "primaryIO" flag to determine which input port to monitor.
0108   001B             ;------------------------------------------------------------------------------
0109   001B             conin:
0110   001B 3A 00 30    		LD	A,(primaryIO)
0111   001E FE 00       		CP	0
0112   0020 20 08       		JR	NZ,coninB
0113   0022             coninA:
0114   0022             
0115   0022             waitForCharA:
0116   0022 CD 73 00    		call ckincharA
0117   0025 28 FB       		JR	Z, waitForCharA
0118   0027 DB 81       		IN   	A,(ACIA0_D)
0119   0029 C9          		RET	; Char ready in A
0120   002A             
0121   002A             coninB:
0122   002A             
0123   002A             waitForCharB:
0124   002A CD 7A 00    		call ckincharB
0125   002D 28 FB       		JR	Z, waitForCharB
0126   002F DB 83       		IN   	A,(ACIA1_D)
0127   0031 C9          		RET	; Char ready in A
0128   0032             
0129   0032             ;------------------------------------------------------------------------------
0130   0032             ; Console output routine
0131   0032             ; Use the "primaryIO" flag to determine which output port to send a character.
0132   0032             ;------------------------------------------------------------------------------
0133   0032 F5          conout:		PUSH	AF		; Store character
0134   0033 3A 00 30    		LD	A,(primaryIO)
0135   0036 FE 00       		CP	0
0136   0038 20 0D       		JR	NZ,conoutB1
0137   003A 18 01       		JR	conoutA1
0138   003C             conoutA:
0139   003C F5          		PUSH	AF
0140   003D             
0141   003D CD 60 00    conoutA1:	CALL	CKACIA0		; See if ACIA channel A is finished transmitting
0142   0040 28 FB       		JR	Z,conoutA1	; Loop until ACIA flag signals ready
0143   0042 F1          		POP	AF		; RETrieve character
0144   0043 D3 81       		OUT	(ACIA0_D),A	; OUTput the character
0145   0045 C9          		RET
0146   0046             
0147   0046             conoutB:
0148   0046 F5          		PUSH	AF
0149   0047             
0150   0047 CD 66 00    conoutB1:	CALL	CKACIA1		; See if ACIA channel B is finished transmitting
0151   004A 28 FB       		JR	Z,conoutB1	; Loop until ACIA flag signals ready
0152   004C F1          		POP	AF		; RETrieve character
0153   004D D3 83       		OUT	(ACIA1_D),A	; OUTput the character
0154   004F C9          		RET
0155   0050             
0156   0050             ;------------------------------------------------------------------------------
0157   0050             ; Non blocking console output routine
0158   0050             ; On return Z flag is 0, if the character could be written, else 1
0159   0050             ; Use the "primaryIO" flag to determine which output port to send a character.
0160   0050             ;------------------------------------------------------------------------------
0161   0050             nbconoutB:
0162   0050 F5                   	PUSH	AF
0163   0051             
0164   0051 CD 66 00    nbconoutB1:	CALL	CKACIA1		; See if ACIA channel B has finished transmitting
0165   0054 20 04       		JR      NZ, nbconoutB2  ; Ready to write
0166   0056 F1          		POP	AF	        ; Remove the parameter we don't need 
0167   0057 E6 00       	        AND     $00             ; Indicate failure
0168   0059 C9          		RET	        	; Return if ACIA flag signals not ready
0169   005A             nbconoutB2:	
0170   005A F1          	        POP	AF		; RETrieve character
0171   005B D3 83       		OUT	(ACIA1_D),A	; OUTput the character
0172   005D F6 FF       	        OR      $ff             ; Indicate success
0173   005F C9          		RET
0174   0060             
0175   0060             ;------------------------------------------------------------------------------
0176   0060             ; I/O status check routine
0177   0060             ; Use the "primaryIO" flag to determine which port to check.
0178   0060             ;------------------------------------------------------------------------------
0179   0060             CKACIA0
0180   0060 DB 80       		IN   	A,(ACIA0_C)	; Status byte D1=TX Buff Empty, D0=RX char ready	
0181   0062 0F          		RRCA			; Rotates RX status into Carry Flag,	
0182   0063 CB 47       		BIT  	0,A		; Set Zero flag if still transmitting character	
0183   0065 C9                  RET
0184   0066             
0185   0066             CKACIA1
0186   0066 DB 82       		IN   	A,(ACIA1_C)	; Status byte D1=TX Buff Empty, D0=RX char ready	
0187   0068 0F          		RRCA			; Rotates RX status into Carry Flag,	
0188   0069 CB 47       		BIT  	0,A		; Set Zero flag if still transmitting character	
0189   006B C9                  RET
0190   006C             
0191   006C             ;------------------------------------------------------------------------------
0192   006C             ; Check if there is a character in the input buffer
0193   006C             ; Use the "primaryIO" flag to determine which port to check.
0194   006C             ;------------------------------------------------------------------------------
0195   006C             CKINCHAR
0196   006C 3A 00 30    		LD	A,(primaryIO)
0197   006F FE 00       		CP	0
0198   0071 20 07       		JR	NZ,ckincharB
0199   0073             
0200   0073             ckincharA:
0201   0073             
0202   0073 DB 80       		IN   A,(ACIA0_C)		; Status byte
0203   0075 E6 01       		AND  $01
0204   0077 FE 00       		CP   $0			; Z flag set if no char
0205   0079 C9          		RET
0206   007A             
0207   007A             ckincharB:
0208   007A             
0209   007A DB 82       		IN   A,(ACIA1_C)		; Status byte
0210   007C E6 01       		AND  $01
0211   007E FE 00       		CP   $0			; Z flag set if no char
0212   0080 C9          		RET
0213   0081             
0214   0081             ;------------------------------------------------------------------------------
0215   0081             ; Filtered Character I/O
0216   0081             ;------------------------------------------------------------------------------
0217   0081             
0218   0081 D7          RDCHR		RST	10H
0219   0082 FE 0A       		CP	LF
0220   0084 28 FB       		JR	Z,RDCHR		; Ignore LF
0221   0086 FE 1B       		CP	ESC
0222   0088 20 02       		JR	NZ,RDCHR1
0223   008A 3E 03       		LD	A,CTRLC		; Change ESC to CTRL-C
0224   008C C9          RDCHR1		RET
0225   008D             
0226   008D FE 0D       WRCHR		CP	CR
0227   008F 28 0A       		JR	Z,WRCRLF	; When CR, write CRLF
0228   0091 FE 0C       		CP	M_CLS
0229   0093 28 04       		JR	Z,WR		; Allow write of "CLS"
0230   0095 FE 20       		CP	' '		; Don't write out any other control codes
0231   0097 38 01       		JR	C,NOWR		; ie. < space
0232   0099 CF          WR		RST	08H
0233   009A C9          NOWR		RET
0234   009B             
0235   009B 3E 0D       WRCRLF		LD	A,CR
0236   009D CF          		RST	08H
0237   009E 3E 0A       		LD	A,LF
0238   00A0 CF          		RST	08H
0239   00A1 3E 0D       		LD	A,CR
0240   00A3 C9          		RET
0241   00A4             
0242   00A4             
0243   00A4             ;------------------------------------------------------------------------------
0244   00A4             ; Initialise hardware and start main loop
0245   00A4             ;------------------------------------------------------------------------------
0246   00A4 31 2A 30    M_INIT		LD   SP,M_STACK		; Set the Stack Pointer
0247   00A7             
0248   00A7 3E 95       		LD        A,RTS_LOW
0249   00A9 D3 80       		OUT       (ACIA0_C),A         ; Initialise ACIA0
0250   00AB D3 82       		OUT       (ACIA1_C),A         ; Initialise ACIA1
0251   00AD             		; Display the "Press space to start" message on both consoles
0252   00AD 3E 00       		LD	A,$00
0253   00AF 32 00 30    		LD	(primaryIO),A
0254   00B2 21 0E 03        		LD   	HL,INITTXT
0255   00B5 CD 37 01    		CALL 	M_PRINT
0256   00B8             		; On Display B we need to take care that it does not hang. 	
0257   00B8 21 0E 03    		LD   	HL,INITTXT
0258   00BB 22 04 30    		LD      (InitTxtB),HL
0259   00BE             
0260   00BE 2A 04 30    printInitB:	LD   	HL,(InitTxtB)
0261   00C1 7E          		LD   	A,(HL)	; Get character
0262   00C2 B7          		OR   	A	; Is it $00 ?
0263   00C3 28 0C       		JR      Z, waitForSpace
0264   00C5 CD 50 00            	CALL    nbconoutB	; Print it
0265   00C8 28 07       		JR      Z, waitForSpace ; If we can't write, don't increment
0266   00CA 23          		INC	HL
0267   00CB 22 04 30    		LD 	(InitTxtB),HL   ; Store pointer into message for next round 
0268   00CE C3 BE 00                    JP      printInitB
0269   00D1             		; Wait until space is in one of the buffers to determine the active console
0270   00D1             waitForSpace:
0271   00D1 CD 73 00    		CALL    ckincharA
0272   00D4 28 0F       		JR	Z,chkSpaceB
0273   00D6 3E 00       		LD	A,$00
0274   00D8 32 00 30    		LD	(primaryIO),A
0275   00DB CD 1B 00    		CALL	conin
0276   00DE FE 20       		CP	' '
0277   00E0 C2 D1 00    		JP	NZ, waitForSpace
0278   00E3 18 12       		JR	spacePressed
0279   00E5             
0280   00E5             chkSpaceB:	
0281   00E5 CD 7A 00    		CALL 	ckincharB
0282   00E8 28 D4       	        JR	Z,printInitB ; If no key pressed, try to continue writing the init message on B
0283   00EA 3E 01       		LD	A,$01
0284   00EC 32 00 30    		LD	(primaryIO),A
0285   00EF CD 1B 00    		CALL	conin
0286   00F2 FE 20       		CP	' '
0287   00F4 C2 BE 00    		JP	NZ, printInitB ; If space not pressed, try to continue writing the init message on B
0288   00F7             
0289   00F7             spacePressed:
0290   00F7             
0291   00F7             		; Clear message on both consoles
0292   00F7 3E 0C       		LD	A,$0C
0293   00F9 CD 3C 00    		CALL	conoutA
0294   00FC CD 50 00    	        CALL	nbconoutB
0295   00FF             
0296   00FF             		;; We only clear the message on the active console,
0297   00FF             		;; because trying to write on a console not connected could
0298   00FF             		;; make the system freeze.
0299   00FF             
0300   00FF             		; primaryIO is now set to the channel where SPACE was pressed	
0301   00FF CD 3E 01    		CALL TXCRLF	; TXCRLF
0302   0102 21 9C 02    		LD   HL,M_SIGNON	; Print SIGNON message
0303   0105 CD 37 01    		CALL M_PRINT
0304   0108             
0305   0108             ;------------------------------------------------------------------------------
0306   0108             ; Monitor command loop
0307   0108             ;------------------------------------------------------------------------------
0308   0108 21 08 01    MAIN  		LD   HL,MAIN	; Save entry point for Monitor	
0309   010B E5          		PUSH HL		; This is the return address
0310   010C CD 3E 01    MAIN0		CALL TXCRLF	; Entry point for Monitor, Normal	
0311   010F 3E 3E       		LD   A,'>'	; Get a ">"	
0312   0111 CF          		RST 08H		; print it
0313   0112             
0314   0112 CD 81 00    MAIN1		CALL RDCHR	; Get a character from the input port
0315   0115 FE 20       		CP   ' '	; <spc> or less? 	
0316   0117 38 F9       		JR   C,MAIN1	; Go back
0317   0119             	
0318   0119 FE 3A       		CP   ':'	; ":"?
0319   011B CA B5 01    		JP   Z,LOAD	; First character of a HEX load
0320   011E             
0321   011E CD 8D 00    		CALL WRCHR	; Print char on console
0322   0121             
0323   0121 E6 5F       		AND  $5F	; Make character uppercase
0324   0123             
0325   0123 FE 49       		CP   'I'	
0326   0125 CA F6 01    		JP   Z,INTERPRT
0327   0128             
0328   0128 FE 47       		CP   'G'
0329   012A CA AF 01    		JP   Z,M_GOTO
0330   012D             
0331   012D FE 58       		CP   'X'
0332   012F CA FA 01    		JP   Z,CPMLOAD
0333   0132             
0334   0132 3E 3F       		LD   A,'?'	; Get a "?"	
0335   0134 CF          		RST 08H		; Print it
0336   0135 18 D5       		JR   MAIN0
0337   0137             	
0338   0137             ;------------------------------------------------------------------------------
0339   0137             ; Print string of characters to Serial A until byte=$00, WITH CR, LF
0340   0137             ;------------------------------------------------------------------------------
0341   0137 7E          M_PRINT		LD   A,(HL)	; Get character
0342   0138 B7          		OR   A		; Is it $00 ?
0343   0139 C8          		RET  Z		; Then RETurn on terminator
0344   013A CF          		RST  08H	; Print it
0345   013B 23          		INC  HL		; Next Character
0346   013C 18 F9       		JR   M_PRINT	; Continue until $00
0347   013E             
0348   013E             
0349   013E 3E 0D       TXCRLF		LD   A,$0D	; 
0350   0140 CF          		RST  08H	; Print character 
0351   0141 3E 0A       		LD   A,$0A	; 
0352   0143 CF          		RST  08H	; Print character
0353   0144 C9          		RET
0354   0145             
0355   0145             ;------------------------------------------------------------------------------
0356   0145             ; Get a character from the console, must be $20-$7F to be valid (no control characters)
0357   0145             ; <Ctrl-c> and <SPACE> breaks with the Zero Flag set
0358   0145             ;------------------------------------------------------------------------------	
0359   0145 CD 81 00    M_GETCHR		CALL RDCHR	; RX a Character
0360   0148 FE 03       		CP   $03	; <ctrl-c> User break?
0361   014A C8          		RET  Z			
0362   014B FE 20       		CP   $20	; <space> or better?
0363   014D 38 F6       		JR   C,M_GETCHR	; Do it again until we get something usable
0364   014F C9          		RET
0365   0150             ;------------------------------------------------------------------------------
0366   0150             ; Gets two ASCII characters from the console (assuming them to be HEX 0-9 A-F)
0367   0150             ; Moves them into B and C, converts them into a byte value in A and updates a
0368   0150             ; Checksum value in E
0369   0150             ;------------------------------------------------------------------------------
0370   0150 CD 45 01    GET2		CALL M_GETCHR	; Get us a valid character to work with
0371   0153 47          		LD   B,A	; Load it in B
0372   0154 CD 45 01    		CALL M_GETCHR	; Get us another character
0373   0157 4F          		LD   C,A	; load it in C
0374   0158 CD 8F 01    		CALL BCTOA	; Convert ASCII to byte
0375   015B 4F          		LD   C,A	; Build the checksum
0376   015C 7B          		LD   A,E
0377   015D 91          		SUB  C		; The checksum should always equal zero when checked
0378   015E 5F          		LD   E,A	; Save the checksum back where it came from
0379   015F 79          		LD   A,C	; Retrieve the byte and go back
0380   0160 C9          		RET
0381   0161             ;------------------------------------------------------------------------------
0382   0161             ; Gets four Hex characters from the console, converts them to values in HL
0383   0161             ;------------------------------------------------------------------------------
0384   0161 21 00 00    GETHL		LD   HL,$0000	; Gets xxxx but sets Carry Flag on any Terminator
0385   0164 CD A8 01    		CALL ECHO	; RX a Character
0386   0167 FE 0D       		CP   $0D	; <CR>?
0387   0169 20 0E       		JR   NZ,GETX2	; other key		
0388   016B 37          SETCY		SCF		; Set Carry Flag
0389   016C C9          		RET             ; and Return to main program		
0390   016D             ;------------------------------------------------------------------------------
0391   016D             ; This routine converts last four hex characters (0-9 A-F) user types into a value in HL
0392   016D             ; Rotates the old out and replaces with the new until the user hits a terminating character
0393   016D             ;------------------------------------------------------------------------------
0394   016D 21 00 00    GETX		LD   HL,$0000	; CLEAR HL
0395   0170 CD A8 01    GETX1		CALL ECHO	; RX a character from the console
0396   0173 FE 0D       		CP   $0D	; <CR>
0397   0175 C8          		RET  Z		; quit
0398   0176 FE 2C       		CP   $2C	; <,> can be used to safely quit for multiple entries
0399   0178 C8          		RET  Z		; (Like filling both DE and HL from the user)
0400   0179 FE 03       GETX2		CP   $03	; Likewise, a <ctrl-C> will terminate clean, too, but
0401   017B 28 EE       		JR   Z,SETCY	; It also sets the Carry Flag for testing later.
0402   017D 29          		ADD  HL,HL	; Otherwise, rotate the previous low nibble to high
0403   017E 29          		ADD  HL,HL	; rather slowly
0404   017F 29          		ADD  HL,HL	; until we get to the top
0405   0180 29          		ADD  HL,HL	; and then we can continue on.
0406   0181 D6 30       		SUB  $30	; Convert ASCII to byte	value
0407   0183 FE 0A       		CP   $0A	; Are we in the 0-9 range?
0408   0185 38 02       		JR   C,GETX3	; Then we just need to sub $30, but if it is A-F
0409   0187 D6 07       		SUB  $07	; We need to take off 7 more to get the value down to
0410   0189 E6 0F       GETX3		AND  $0F	; to the right hex value
0411   018B 85          		ADD  A,L	; Add the high nibble to the low
0412   018C 6F          		LD   L,A	; Move the byte back to A
0413   018D 18 E1       		JR   GETX1	; and go back for next character until he terminates
0414   018F             ;------------------------------------------------------------------------------
0415   018F             ; Convert ASCII characters in B C registers to a byte value in A
0416   018F             ;------------------------------------------------------------------------------
0417   018F 78          BCTOA		LD   A,B	; Move the hi order byte to A
0418   0190 D6 30       		SUB  $30	; Take it down from Ascii
0419   0192 FE 0A       		CP   $0A	; Are we in the 0-9 range here?
0420   0194 38 02       		JR   C,BCTOA1	; If so, get the next nybble
0421   0196 D6 07       		SUB  $07	; But if A-F, take it down some more
0422   0198 07          BCTOA1		RLCA		; Rotate the nybble from low to high
0423   0199 07          		RLCA		; One bit at a time
0424   019A 07          		RLCA		; Until we
0425   019B 07          		RLCA		; Get there with it
0426   019C 47          		LD   B,A	; Save the converted high nybble
0427   019D 79          		LD   A,C	; Now get the low order byte
0428   019E D6 30       		SUB  $30	; Convert it down from Ascii
0429   01A0 FE 0A       		CP   $0A	; 0-9 at this point?
0430   01A2 38 02       		JR   C,BCTOA2	; Good enough then, but
0431   01A4 D6 07       		SUB  $07	; Take off 7 more if it's A-F
0432   01A6 80          BCTOA2		ADD  A,B	; Add in the high order nybble
0433   01A7 C9          		RET
0434   01A8             
0435   01A8             ;------------------------------------------------------------------------------
0436   01A8             ; Get a character and echo it back to the user
0437   01A8             ;------------------------------------------------------------------------------
0438   01A8 CD 81 00    ECHO		CALL	RDCHR
0439   01AB CD 8D 00    		CALL	WRCHR
0440   01AE C9          		RET
0441   01AF             
0442   01AF             ;------------------------------------------------------------------------------
0443   01AF             ; GOTO command
0444   01AF             ;------------------------------------------------------------------------------
0445   01AF CD 61 01    M_GOTO		CALL GETHL		; ENTRY POINT FOR <G>oto addr. Get XXXX from user.
0446   01B2 D8          		RET  C			; Return if invalid       	
0447   01B3 E5          		PUSH HL
0448   01B4 C9          		RET			; Jump to HL address value
0449   01B5             
0450   01B5             ;------------------------------------------------------------------------------
0451   01B5             ; LOAD Intel Hex format file from the console.
0452   01B5             ; [Intel Hex Format is:
0453   01B5             ; 1) Colon (Frame 0)
0454   01B5             ; 2) Record Length Field (Frames 1 and 2)
0455   01B5             ; 3) Load Address Field (Frames 3,4,5,6)
0456   01B5             ; 4) Record Type Field (Frames 7 and 8)
0457   01B5             ; 5) Data Field (Frames 9 to 9+2*(Record Length)-1
0458   01B5             ; 6) Checksum Field - Sum of all byte values from Record Length to and 
0459   01B5             ;   including Checksum Field = 0 ]
0460   01B5             ;------------------------------------------------------------------------------	
0461   01B5 1E 00       LOAD		LD   E,0	; First two Characters is the Record Length Field
0462   01B7 CD 50 01    		CALL GET2	; Get us two characters into BC, convert it to a byte <A>
0463   01BA 57          		LD   D,A	; Load Record Length count into D
0464   01BB CD 50 01    		CALL GET2	; Get next two characters, Memory Load Address <H>
0465   01BE 67          		LD   H,A	; put value in H register.
0466   01BF CD 50 01    		CALL GET2	; Get next two characters, Memory Load Address <L>
0467   01C2 6F          		LD   L,A	; put value in L register.
0468   01C3 CD 50 01    		CALL GET2	; Get next two characters, Record Field Type
0469   01C6 FE 01       		CP   $01	; Record Field Type 00 is Data, 01 is End of File
0470   01C8 20 09       		JR   NZ,LOAD2	; Must be the end of that file
0471   01CA CD 50 01    		CALL GET2	; Get next two characters, assemble into byte
0472   01CD 7B          		LD   A,E	; Recall the Checksum byte
0473   01CE A7          		AND  A		; Is it Zero?
0474   01CF 28 1E       		JR   Z,LOAD00	; Print footer reached message
0475   01D1 18 15       		JR   LOADERR	; Checksums don't add up, Error out
0476   01D3             		
0477   01D3 7A          LOAD2		LD   A,D	; Retrieve line character counter	
0478   01D4 A7          		AND  A		; Are we done with this line?
0479   01D5 28 0B       		JR   Z,LOAD3	; Get two more ascii characters, build a byte and checksum
0480   01D7 CD 50 01    		CALL GET2	; Get next two chars, convert to byte in A, checksum it
0481   01DA 77          		LD   (HL),A	; Move converted byte in A to memory location
0482   01DB 23          		INC  HL		; Increment pointer to next memory location	
0483   01DC 3E 2E       		LD   A,'.'	; Print out a "." for every byte loaded
0484   01DE CF          		RST  08H	;
0485   01DF 15          		DEC  D		; Decrement line character counter
0486   01E0 18 F1       		JR   LOAD2	; and keep loading into memory until line is complete
0487   01E2             		
0488   01E2 CD 50 01    LOAD3		CALL GET2	; Get two chars, build byte and checksum
0489   01E5 7B          		LD   A,E	; Check the checksum value
0490   01E6 A7          		AND  A		; Is it zero?
0491   01E7 C8          		RET  Z
0492   01E8             
0493   01E8 21 FD 02    LOADERR		LD   HL,CKSUMERR  ; Get "Checksum Error" message
0494   01EB CD 37 01    		CALL M_PRINT	; Print Message from (HL) and terminate the load
0495   01EE C9          		RET
0496   01EF             
0497   01EF 21 34 03    LOAD00  	LD   HL,LDETXT	; Print load complete message
0498   01F2 CD 37 01    		CALL M_PRINT
0499   01F5 C9          		RET
0500   01F6             
0501   01F6             ;------------------------------------------------------------------------------
0502   01F6             ; Start Interpreter
0503   01F6             ;------------------------------------------------------------------------------
0504   01F6             INTERPRT
0505   01F6 C3 3F 03    		JP  STARTINT
0506   01F9 C9          		RET
0507   01FA             
0508   01FA             ;------------------------------------------------------------------------------
0509   01FA             ; CP/M load command
0510   01FA             ;------------------------------------------------------------------------------
0511   01FA             CPMLOAD
0512   01FA             
0513   01FA 21 0C 02        	LD HL,CPMTXT
0514   01FD CD 37 01    		CALL M_PRINT
0515   0200 CD 45 01    		CALL M_GETCHR
0516   0203 C8          		RET Z	; Cancel if CTRL-C
0517   0204 E6 5F       		AND  $5F ; uppercase
0518   0206 FE 59       		CP 'Y'
0519   0208 CA 2A 02    		JP  Z,CPMLOAD2
0520   020B C9          		RET
0521   020C             CPMTXT
0522   020C 0D 0A       		.BYTE	$0D,$0A
0523   020E 42 6F 6F 74 		.TEXT	"Boot CP/M?"
0523   0212 20 43 50 2F 
0523   0216 4D 3F 
0524   0218 00          		.BYTE	$00
0525   0219             
0526   0219             CPMTXT2
0527   0219 0D 0A       		.BYTE	$0D,$0A
0528   021B 4C 6F 61 64 		.TEXT	"Loading CP/M"
0528   021F 69 6E 67 20 
0528   0223 43 50 2F 4D 
0529   0227 0D 0A 00    		.BYTE	$0D,$0A,$00
0530   022A             
0531   022A             CPMLOAD2
0532   022A 21 19 02        	LD HL,CPMTXT2
0533   022D CD 37 01    		CALL M_PRINT
0534   0230             		
0535   0230 06 18       		LD	B,numSecs
0536   0232             
0537   0232 3E 00       		LD	A,0
0538   0234 32 06 30    		LD	(lba0),A
0539   0237 32 07 30    		ld 	(lba1),A
0540   023A 32 08 30    		ld 	(lba2),A
0541   023D 32 09 30    		ld 	(lba3),A
0542   0240             		
0543   0240 21 00 D0    		LD	HL,loadAddr
0544   0243 22 02 30    		LD	(dmaAddr),HL
0545   0246             processSectors:
0546   0246             
0547   0246 CD 74 02    		call	readhst
0548   0249             
0549   0249 11 00 02    		LD	DE,0200H
0550   024C 2A 02 30    		LD	HL,(dmaAddr)
0551   024F 19          		ADD	HL,DE
0552   0250 22 02 30    		LD	(dmaAddr),HL
0553   0253 3A 06 30    		LD	A,(lba0)
0554   0256 3C          		INC	A
0555   0257 32 06 30    		LD	(lba0),A
0556   025A             
0557   025A 10 EA       		djnz	processSectors
0558   025C             
0559   025C             ; Start CP/M using entry at top of BIOS
0560   025C             ; The current active console stream ID is pushed onto the stack
0561   025C             ; to allow the CBIOS to pick it up
0562   025C             ; 0 = ACIA0, 1 = ACIA1
0563   025C             		
0564   025C 3A 00 30    		ld	A,(primaryIO)
0565   025F F5          		PUSH	AF
0566   0260 2A FE FF    		ld	HL,($FFFE)
0567   0263 E9          		jp	(HL)
0568   0264             
0569   0264             
0570   0264             ;------------------------------------------------------------------------------
0571   0264             ; ROUTINES AS USED IN BIOS
0572   0264             ;------------------------------------------------------------------------------
0573   0264             
0574   0264             ;================================================================================================
0575   0264             ; Convert track/head/sector into LBA for physical access to the disk
0576   0264             ;================================================================================================
0577   0264             setLBAaddr:	
0578   0264             		; Transfer LBA to disk (LBA3 not used on SD card)
0579   0264 3A 08 30    		LD	A,(lba2)
0580   0267 D3 8C       		OUT	(SD_LBA2),A
0581   0269 3A 07 30    		LD	A,(lba1)
0582   026C D3 8B       		OUT	(SD_LBA1),A
0583   026E 3A 06 30    		LD	A,(lba0)
0584   0271 D3 8A       		OUT	(SD_LBA0),A
0585   0273 C9          		RET
0586   0274             		
0587   0274             ;================================================================================================
0588   0274             ; Read physical sector from host
0589   0274             ;================================================================================================
0590   0274             
0591   0274             readhst:
0592   0274 F5          		PUSH 	AF
0593   0275 C5          		PUSH 	BC
0594   0276 E5          		PUSH 	HL
0595   0277             
0596   0277 DB 89       rdWait1: IN	A,(SD_STATUS)
0597   0279 FE 80       		CP	128
0598   027B 20 FA       		JR	NZ,rdWait1
0599   027D             		
0600   027D CD 64 02    		CALL 	setLBAaddr
0601   0280             		
0602   0280 3E 00       		LD	A,$00	; 00 = Read block
0603   0282 D3 89       		OUT	(SD_CONTROL),A
0604   0284             
0605   0284 0E 04       		LD 	c,4
0606   0286             ;		LD 	HL,hstbuf
0607   0286             rd4secs:
0608   0286 06 80       		LD 	b,128
0609   0288             rdByte:
0610   0288             
0611   0288 DB 89       rdWait2: IN	A,(SD_STATUS)
0612   028A FE E0       		CP	224	; Read byte waiting
0613   028C 20 FA       		JR	NZ,rdWait2
0614   028E             
0615   028E DB 88       		IN	A,(SD_DATA)
0616   0290             
0617   0290 77          		LD 	(HL),A
0618   0291 23          		INC 	HL
0619   0292 05          		dec 	b
0620   0293 20 F3       		JR 	NZ, rdByte
0621   0295 0D          		dec 	c
0622   0296 20 EE       		JR 	NZ,rd4secs
0623   0298             
0624   0298 E1          		POP 	HL
0625   0299 C1          		POP 	BC
0626   029A F1          		POP 	AF
0627   029B             
0628   029B             ;		XOR 	a
0629   029B             ;		ld	(erflag),a
0630   029B C9          		RET
0631   029C             
0632   029C             ;------------------------------------------------------------------------------
0633   029C             ; END OF ROUTINES AS USED IN BIOS
0634   029C             ;------------------------------------------------------------------------------
0635   029C             
0636   029C             
0637   029C 43 50 2F 4D M_SIGNON	.BYTE	"CP/M Boot ROM 2.0"
0637   02A0 20 42 6F 6F 
0637   02A4 74 20 52 4F 
0637   02A8 4D 20 32 2E 
0637   02AC 30 
0638   02AD             ;		.BYTE	" based on design by G. Searle"
0639   02AD             ;		.BYTE	$0D,$0A
0640   02AD 0D 0A       		.BYTE	$0D,$0A
0641   02AF 49 2D 53 74 		.TEXT	"I-Strt Intrp"
0641   02B3 72 74 20 49 
0641   02B7 6E 74 72 70 
0642   02BB 0D 0A       		.BYTE	$0D,$0A
0643   02BD 58 2D 42 6F 		.TEXT	"X-Boot CP/M"
0643   02C1 6F 74 20 43 
0643   02C5 50 2F 4D 
0644   02C8 0D 0A       		.BYTE	$0D,$0A
0645   02CA 3A 6E 6E 6E 		.TEXT	":nnnn-Load I rcrd"
0645   02CE 6E 2D 4C 6F 
0645   02D2 61 64 20 49 
0645   02D6 20 72 63 72 
0645   02DA 64 
0646   02DB 0D 0A       		.BYTE	$0D,$0A
0647   02DD 47 6E 6E 6E 		.TEXT	"Gnnnn-R loc"
0647   02E1 6E 2D 52 20 
0647   02E5 6C 6F 63 
0648   02E8 0D 0A       		.BYTE	$0D,$0A
0649   02EA 00                 	.BYTE   $00
0650   02EB             
0651   02EB             M_BASTXT
0652   02EB 0D 0A       		.BYTE	$0D,$0A
0653   02ED 43 6F 6C 64 		.TEXT	"Cold or warm?"
0653   02F1 20 6F 72 20 
0653   02F5 77 61 72 6D 
0653   02F9 3F 
0654   02FA 0D 0A 00    		.BYTE	$0D,$0A,$00
0655   02FD             
0656   02FD 43 68 65 63 CKSUMERR	.BYTE	"Checksum error"
0656   0301 6B 73 75 6D 
0656   0305 20 65 72 72 
0656   0309 6F 72 
0657   030B 0D 0A 00    		.BYTE	$0D,$0A,$00
0658   030E             
0659   030E             INITTXT  
0660   030E 0C          		.BYTE	$0C
0661   030F 50 72 65 73 		.TEXT	"Press [space] to activate console."
0661   0313 73 20 5B 73 
0661   0317 70 61 63 65 
0661   031B 5D 20 74 6F 
0661   031F 20 61 63 74 
0661   0323 69 76 61 74 
0661   0327 65 20 63 6F 
0661   032B 6E 73 6F 6C 
0661   032F 65 2E 
0662   0331 0D 0A 00    		.BYTE	$0D,$0A, $00
0663   0334             
0664   0334             LDETXT  
0665   0334 43 6F 6D 70 		.TEXT	"Complete"
0665   0338 6C 65 74 65 
0666   033C 0D 0A 00    		.BYTE	$0D,$0A, $00
0667   033F             
0668   033F             ; ==========================================================================================================================
0669   033F             ; GENERAL EQUATES
0670   033F             
0671   033F             CTRLC   .EQU    03H             ; Control "C"
0672   033F             CTRLG   .EQU    07H             ; Control "G"
0673   033F             BKSP    .EQU    08H             ; Back space
0674   033F             LF      .EQU    0AH             ; Line feed
0675   033F             CS      .EQU    0CH             ; Clear screen
0676   033F             CR      .EQU    0DH             ; Carriage return
0677   033F             CTRLO   .EQU    0FH             ; Control "O"
0678   033F             CTRLQ	.EQU	11H		; Control "Q"
0679   033F             CTRLR   .EQU    12H             ; Control "R"
0680   033F             CTRLS   .EQU    13H             ; Control "S"
0681   033F             CTRLU   .EQU    15H             ; Control "U"
0682   033F             ESC     .EQU    1BH             ; Escape
0683   033F             DEL     .EQU    7FH             ; Delete
0684   033F             
0685   033F             
0686   033F             ;===========================================================================================================================
0687   033F             
0688   033F             ; NASCOM ROM BASIC Ver 4.7, 
0689   033F             ; used to be here, removed to get rid of the '(C) 1978 Microsoft'
0690   033F             
0691   033F             STARTINT:							  
0692   033F             #INCLUDE "SOURCE\\INTPRT.ASM"
0001+  033F             ;------------------------------------------------------------------------------
0002+  033F             ; Start BASIC command
0003+  033F             ;------------------------------------------------------------------------------
0004+  033F             BASIC
0005+  033F 21 EB 02        		LD HL,M_BASTXT
0006+  0342 CD 37 01    		CALL M_PRINT
0007+  0345 CD 45 01    		CALL M_GETCHR
0008+  0348 C8          		RET Z	; Cancel if CTRL-C
0009+  0349 E6 5F       		AND  $5F ; uppercase
0010+  034B FE 43       		CP 'C'
0011+  034D CA 56 03    		JP  Z,COLD
0012+  0350 FE 57       		CP 'W'
0013+  0352 CA 59 03    		JP  Z,WARM
0014+  0355 C9          		RET
0015+  0356             
0016+  0356             ; BASIC WORK SPACE LOCATIONS
0017+  0356             
0018+  0356             WRKSPC  .EQU    30B0H             ; BASIC Work space
0019+  0356             USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
0020+  0356             OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
0021+  0356             OTPORT  .EQU    WRKSPC+7H           ; Port (p)
0022+  0356             DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
0023+  0356             DIV1    .EQU    WRKSPC+0AH           ; <- Values
0024+  0356             DIV2    .EQU    WRKSPC+0EH           ; <-   to
0025+  0356             DIV3    .EQU    WRKSPC+12H           ; <-   be
0026+  0356             DIV4    .EQU    WRKSPC+15H           ; <-inserted
0027+  0356             SEED    .EQU    WRKSPC+17H           ; Random number seed
0028+  0356             LSTRND  .EQU    WRKSPC+3AH           ; Last random number
0029+  0356             INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
0030+  0356             INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
0031+  0356             NULLS   .EQU    WRKSPC+41H           ; Number of nulls
0032+  0356             LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
0033+  0356             COMMAN  .EQU    WRKSPC+43H           ; Width for commas
0034+  0356             NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
0035+  0356             CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
0036+  0356             LINESC  .EQU    WRKSPC+46H           ; Lines counter
0037+  0356             LINESN  .EQU    WRKSPC+48H           ; Lines number
0038+  0356             CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
0039+  0356             NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
0040+  0356             BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
0041+  0356             RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
0042+  0356             POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
0043+  0356             PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
0044+  0356             RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
0045+  0356             STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
0046+  0356             LINEAT  .EQU    WRKSPC+5CH           ; Current line number
0047+  0356             BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
0048+  0356             BUFFER  .EQU    WRKSPC+61H           ; Input buffer
0049+  0356             STACK   .EQU    WRKSPC+66H           ; Initial stack
0050+  0356             CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
0051+  0356             LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
0052+  0356             TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
0053+  0356             DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
0054+  0356             LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
0055+  0356             TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
0056+  0356             TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
0057+  0356             TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
0058+  0356             STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
0059+  0356             CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
0060+  0356             LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
0061+  0356             DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
0062+  0356             FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
0063+  0356             LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
0064+  0356             READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
0065+  0356             BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
0066+  0356             NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
0067+  0356             ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
0068+  0356             CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
0069+  0356             PROGND  .EQU    WRKSPC+0D6H          ; End of program
0070+  0356             VAREND  .EQU    WRKSPC+0D8H          ; End of variables
0071+  0356             ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
0072+  0356             NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
0073+  0356             FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
0074+  0356             FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
0075+  0356             FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
0076+  0356             FPEXP   .EQU    FPREG+3         ; Floating point exponent
0077+  0356             SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
0078+  0356             PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
0079+  0356             MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
0080+  0356             PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area
0081+  0356             STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
0082+  0356             
0083+  0356             ; BASIC ERROR CODE VALUES
0084+  0356             
0085+  0356             NF      .EQU    00H             ; NEXT without FOR
0086+  0356             SN      .EQU    02H             ; Syntax error
0087+  0356             RG      .EQU    04H             ; RETURN without GOSUB
0088+  0356             OD      .EQU    06H             ; Out of DATA
0089+  0356             FC      .EQU    08H             ; Function call error
0090+  0356             OV      .EQU    0AH             ; Overflow
0091+  0356             OM      .EQU    0CH             ; Out of memory
0092+  0356             UL      .EQU    0EH             ; Undefined line number
0093+  0356             BS      .EQU    10H             ; Bad subscript
0094+  0356             DD      .EQU    12H             ; Re-DIMensioned array
0095+  0356             DZ      .EQU    14H             ; Division by zero (/0)
0096+  0356             ID      .EQU    16H             ; Illegal direct
0097+  0356             TM      .EQU    18H             ; Type miss-match
0098+  0356             OS      .EQU    1AH             ; Out of string space
0099+  0356             LS      .EQU    1CH             ; String too long
0100+  0356             ST      .EQU    1EH             ; String formula too complex
0101+  0356             CN      .EQU    20H             ; Can't CONTinue
0102+  0356             UF      .EQU    22H             ; UnDEFined FN function
0103+  0356             MO      .EQU    24H             ; Missing operand
0104+  0356             HX      .EQU    26H             ; HEX error
0105+  0356             BN      .EQU    28H             ; BIN error
0106+  0356             
0107+  0356             ;        .ORG    00396H
0108+  0356             
0109+  0356 C3 5C 03    COLD:   JP      STARTB          ; Jump for cold start
0110+  0359 C3 FA 03    WARM:   JP      WARMST          ; Jump for warm start
0111+  035C             STARTB: 
0112+  035C DD 21 00 00         LD      IX,0            ; Flag cold start
0113+  0360 C3 67 03            JP      CSTART          ; Jump to initialise
0114+  0363             
0115+  0363 0D 0C               .WORD   DEINT           ; Get integer -32768 to 32767
0116+  0365 83 13               .WORD   ABPASS          ; Return integer in AB
0117+  0367             
0118+  0367             
0119+  0367 21 B0 30    CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
0120+  036A F9                  LD      SP,HL           ; Set up a temporary stack
0121+  036B C3 A2 1F            JP      INITST          ; Go to initialise
0122+  036E             
0123+  036E 11 34 06    INIT:   LD      DE,INITAB       ; Initialise workspace
0124+  0371 06 63               LD      B,INITBE-INITAB+3; Bytes to copy
0125+  0373 21 B0 30            LD      HL,WRKSPC       ; Into workspace RAM
0126+  0376 1A          COPY:   LD      A,(DE)          ; Get source
0127+  0377 77                  LD      (HL),A          ; To destination
0128+  0378 23                  INC     HL              ; Next destination
0129+  0379 13                  INC     DE              ; Next source
0130+  037A 05                  DEC     B               ; Count bytes
0131+  037B C2 76 03            JP      NZ,COPY         ; More to move
0132+  037E F9                  LD      SP,HL           ; Temporary stack
0133+  037F CD 35 08            CALL    CLREG           ; Clear registers and stack
0134+  0382 CD 03 0E            CALL    PRNTCRLF        ; Output CRLF
0135+  0385 32 5A 31            LD      (BUFFER+72+1),A ; Mark end of buffer
0136+  0388 32 A9 31            LD      (PROGST),A      ; Initialise program area
0137+  038B 21 49 04    MSIZE:  LD      HL,MEMMSG       ; Point to message
0138+  038E CD A1 14            CALL    PRS             ; Output "Memory size"
0139+  0391 CD 52 08            CALL    PROMPT          ; Get input with '?'
0140+  0394 CD 5B 0B            CALL    GETCHR          ; Get next character
0141+  0397 B7                  OR      A               ; Set flags
0142+  0398 C2 B0 03            JP      NZ,TSTMEM       ; If number - Test if RAM there
0143+  039B 21 0D 32            LD      HL,STLOOK       ; Point to start of RAM
0144+  039E 23          MLOOP:  INC     HL              ; Next byte
0145+  039F 7C                  LD      A,H             ; Above address FFFF ?
0146+  03A0 B5                  OR      L
0147+  03A1 CA C2 03            JP      Z,SETTOP        ; Yes - 64K RAM
0148+  03A4 7E                  LD      A,(HL)          ; Get contents
0149+  03A5 47                  LD      B,A             ; Save it
0150+  03A6 2F                  CPL                     ; Flip all bits
0151+  03A7 77                  LD      (HL),A          ; Put it back
0152+  03A8 BE                  CP      (HL)            ; RAM there if same
0153+  03A9 70                  LD      (HL),B          ; Restore old contents
0154+  03AA CA 9E 03            JP      Z,MLOOP         ; If RAM - test next byte
0155+  03AD C3 C2 03            JP      SETTOP          ; Top of RAM found
0156+  03B0             
0157+  03B0 CD 27 0C    TSTMEM: CALL    ATOH            ; Get high memory into DE
0158+  03B3 B7                  OR      A               ; Set flags on last byte
0159+  03B4 C2 03 07            JP      NZ,SNERR        ; ?SN Error if bad character
0160+  03B7 EB                  EX      DE,HL           ; Address into HL
0161+  03B8 2B                  DEC     HL              ; Back one byte
0162+  03B9 3E D9               LD      A,11011001B     ; Test byte
0163+  03BB 46                  LD      B,(HL)          ; Get old contents
0164+  03BC 77                  LD      (HL),A          ; Load test byte
0165+  03BD BE                  CP      (HL)            ; RAM there if same
0166+  03BE 70                  LD      (HL),B          ; Restore old contents
0167+  03BF C2 8B 03            JP      NZ,MSIZE        ; Ask again if no RAM
0168+  03C2             
0169+  03C2 2B          SETTOP: DEC     HL              ; Back one byte
0170+  03C3 11 0C 32            LD      DE,STLOOK-1     ; See if enough RAM
0171+  03C6 CD CB 09            CALL    CPDEHL          ; Compare DE with HL
0172+  03C9 DA 8B 03            JP      C,MSIZE         ; Ask again if not enough RAM
0173+  03CC 11 CE FF            LD      DE,0-50         ; 50 Bytes string space
0174+  03CF 22 5F 31            LD      (LSTRAM),HL     ; Save last available RAM
0175+  03D2 19                  ADD     HL,DE           ; Allocate string space
0176+  03D3 22 0A 31            LD      (STRSPC),HL     ; Save string space
0177+  03D6 CD 10 08            CALL    CLRPTR          ; Clear program area
0178+  03D9 2A 0A 31            LD      HL,(STRSPC)     ; Get end of memory
0179+  03DC 11 EF FF            LD      DE,0-17         ; Offset for free bytes
0180+  03DF 19                  ADD     HL,DE           ; Adjust HL
0181+  03E0 11 A9 31            LD      DE,PROGST       ; Start of program text
0182+  03E3 7D                  LD      A,L             ; Get LSB
0183+  03E4 93                  SUB     E               ; Adjust it
0184+  03E5 6F                  LD      L,A             ; Re-save
0185+  03E6 7C                  LD      A,H             ; Get MSB
0186+  03E7 9A                  SBC     A,D             ; Adjust it
0187+  03E8 67                  LD      H,A             ; Re-save
0188+  03E9 E5                  PUSH    HL              ; Save bytes free
0189+  03EA 21 12 04            LD      HL,SIGNON       ; Sign-on message
0190+  03ED CD A1 14            CALL    PRS             ; Output string
0191+  03F0 E1                  POP     HL              ; Get bytes free back
0192+  03F1 CD 44 1B            CALL    PRNTHL          ; Output amount of free memory
0193+  03F4 21 03 04            LD      HL,BFREE        ; " Bytes free" message
0194+  03F7 CD A1 14            CALL    PRS             ; Output string
0195+  03FA             
0196+  03FA 31 16 31    WARMST: LD      SP,STACK        ; Temporary stack
0197+  03FD CD 35 08    BRKRET: CALL    CLREG           ; Clear registers and stack
0198+  0400 C3 4E 07            JP      PRNTOK          ; Go to get command line
0199+  0403             
0200+  0403 20 42 79 74 BFREE:  .BYTE   " Bytes free",CR,LF,0,0
0200+  0407 65 73 20 66 
0200+  040B 72 65 65 0D 
0200+  040F 0A 00 00 
0201+  0412             
0202+  0412 5A 38 30 20 SIGNON: .BYTE   "Z80 BASIC Ver 4.7b",CR,LF
0202+  0416 42 41 53 49 
0202+  041A 43 20 56 65 
0202+  041E 72 20 34 2E 
0202+  0422 37 62 0D 0A 
0203+  0426 43 6F 70 79         .BYTE   "Copyright ",40,"C",41
0203+  042A 72 69 67 68 
0203+  042E 74 20 28 43 
0203+  0432 29 
0204+  0433 20 31 39 37         .BYTE   " 1978 by Microsoft",CR,LF,0,0
0204+  0437 38 20 62 79 
0204+  043B 20 4D 69 63 
0204+  043F 72 6F 73 6F 
0204+  0443 66 74 0D 0A 
0204+  0447 00 00 
0205+  0449             
0206+  0449 4D 65 6D 6F MEMMSG: .BYTE   "Memory top",0
0206+  044D 72 79 20 74 
0206+  0451 6F 70 00 
0207+  0454             
0208+  0454             ; FUNCTION ADDRESS TABLE
0209+  0454             
0210+  0454 B9 19       FNCTAB: .WORD   SGN
0211+  0456 7D 1A               .WORD   INT
0212+  0458 CF 19               .WORD   ABS
0213+  045A B3 30               .WORD   USR
0214+  045C 61 13               .WORD   FRE
0215+  045E E6 16               .WORD   INP
0216+  0460 8F 13               .WORD   POS
0217+  0462 43 1C               .WORD   SQR
0218+  0464 22 1D               .WORD   RND
0219+  0466 5E 18               .WORD   LOG
0220+  0468 91 1C               .WORD   EXP
0221+  046A 97 1D               .WORD   COS
0222+  046C 9D 1D               .WORD   SIN
0223+  046E FE 1D               .WORD   TAN
0224+  0470 13 1E               .WORD   ATN
0225+  0472 3A 17               .WORD   PEEK
0226+  0474 7E 1E               .WORD   DEEK
0227+  0476 01 31               .WORD   POINT
0228+  0478 13 16               .WORD   LEN
0229+  047A 2B 14               .WORD   STR
0230+  047C AD 16               .WORD   VAL
0231+  047E 22 16               .WORD   ASC
0232+  0480 33 16               .WORD   CHR
0233+  0482 A0 1E               .WORD   HEX
0234+  0484 33 1F               .WORD   BIN
0235+  0486 43 16               .WORD   LEFT
0236+  0488 73 16               .WORD   RIGHT
0237+  048A 7D 16               .WORD   MID
0238+  048C             
0239+  048C             ; RESERVED WORD LIST
0240+  048C             
0241+  048C C5 4E 44    WORDS:  .BYTE   'E'+80H,"ND"
0242+  048F C6 4F 52            .BYTE   'F'+80H,"OR"
0243+  0492 CE 45 58 54         .BYTE   'N'+80H,"EXT"
0244+  0496 C4 41 54 41         .BYTE   'D'+80H,"ATA"
0245+  049A C9 4E 50 55         .BYTE   'I'+80H,"NPUT"
0245+  049E 54 
0246+  049F C4 49 4D            .BYTE   'D'+80H,"IM"
0247+  04A2 D2 45 41 44         .BYTE   'R'+80H,"EAD"
0248+  04A6 CC 45 54            .BYTE   'L'+80H,"ET"
0249+  04A9 C7 4F 54 4F         .BYTE   'G'+80H,"OTO"
0250+  04AD D2 55 4E            .BYTE   'R'+80H,"UN"
0251+  04B0 C9 46               .BYTE   'I'+80H,"F"
0252+  04B2 D2 45 53 54         .BYTE   'R'+80H,"ESTORE"
0252+  04B6 4F 52 45 
0253+  04B9 C7 4F 53 55         .BYTE   'G'+80H,"OSUB"
0253+  04BD 42 
0254+  04BE D2 45 54 55         .BYTE   'R'+80H,"ETURN"
0254+  04C2 52 4E 
0255+  04C4 D2 45 4D            .BYTE   'R'+80H,"EM"
0256+  04C7 D3 54 4F 50         .BYTE   'S'+80H,"TOP"
0257+  04CB CF 55 54            .BYTE   'O'+80H,"UT"
0258+  04CE CF 4E               .BYTE   'O'+80H,"N"
0259+  04D0 CE 55 4C 4C         .BYTE   'N'+80H,"ULL"
0260+  04D4 D7 41 49 54         .BYTE   'W'+80H,"AIT"
0261+  04D8 C4 45 46            .BYTE   'D'+80H,"EF"
0262+  04DB D0 4F 4B 45         .BYTE   'P'+80H,"OKE"
0263+  04DF C4 4F 4B 45         .BYTE   'D'+80H,"OKE"
0264+  04E3 D3 43 52 45         .BYTE   'S'+80H,"CREEN"
0264+  04E7 45 4E 
0265+  04E9 CC 49 4E 45         .BYTE   'L'+80H,"INES"
0265+  04ED 53 
0266+  04EE C3 4C 53            .BYTE   'C'+80H,"LS"
0267+  04F1 D7 49 44 54         .BYTE   'W'+80H,"IDTH"
0267+  04F5 48 
0268+  04F6 CD 4F 4E 49         .BYTE   'M'+80H,"ONITOR"
0268+  04FA 54 4F 52 
0269+  04FD D3 45 54            .BYTE   'S'+80H,"ET"
0270+  0500 D2 45 53 45         .BYTE   'R'+80H,"ESET"
0270+  0504 54 
0271+  0505 D0 52 49 4E         .BYTE   'P'+80H,"RINT"
0271+  0509 54 
0272+  050A C3 4F 4E 54         .BYTE   'C'+80H,"ONT"
0273+  050E CC 49 53 54         .BYTE   'L'+80H,"IST"
0274+  0512 C3 4C 45 41         .BYTE   'C'+80H,"LEAR"
0274+  0516 52 
0275+  0517 C3 4C 4F 41         .BYTE   'C'+80H,"LOAD"
0275+  051B 44 
0276+  051C C3 53 41 56         .BYTE   'C'+80H,"SAVE"
0276+  0520 45 
0277+  0521 CE 45 57            .BYTE   'N'+80H,"EW"
0278+  0524             
0279+  0524 D4 41 42 28         .BYTE   'T'+80H,"AB("
0280+  0528 D4 4F               .BYTE   'T'+80H,"O"
0281+  052A C6 4E               .BYTE   'F'+80H,"N"
0282+  052C D3 50 43 28         .BYTE   'S'+80H,"PC("
0283+  0530 D4 48 45 4E         .BYTE   'T'+80H,"HEN"
0284+  0534 CE 4F 54            .BYTE   'N'+80H,"OT"
0285+  0537 D3 54 45 50         .BYTE   'S'+80H,"TEP"
0286+  053B             
0287+  053B AB                  .BYTE   '+'+80H
0288+  053C AD                  .BYTE   '-'+80H
0289+  053D AA                  .BYTE   '*'+80H
0290+  053E AF                  .BYTE   '/'+80H
0291+  053F DE                  .BYTE   '^'+80H
0292+  0540 C1 4E 44            .BYTE   'A'+80H,"ND"
0293+  0543 CF 52               .BYTE   'O'+80H,"R"
0294+  0545 BE                  .BYTE   '>'+80H
0295+  0546 BD                  .BYTE   '='+80H
0296+  0547 BC                  .BYTE   '<'+80H
0297+  0548             
0298+  0548 D3 47 4E            .BYTE   'S'+80H,"GN"
0299+  054B C9 4E 54            .BYTE   'I'+80H,"NT"
0300+  054E C1 42 53            .BYTE   'A'+80H,"BS"
0301+  0551 D5 53 52            .BYTE   'U'+80H,"SR"
0302+  0554 C6 52 45            .BYTE   'F'+80H,"RE"
0303+  0557 C9 4E 50            .BYTE   'I'+80H,"NP"
0304+  055A D0 4F 53            .BYTE   'P'+80H,"OS"
0305+  055D D3 51 52            .BYTE   'S'+80H,"QR"
0306+  0560 D2 4E 44            .BYTE   'R'+80H,"ND"
0307+  0563 CC 4F 47            .BYTE   'L'+80H,"OG"
0308+  0566 C5 58 50            .BYTE   'E'+80H,"XP"
0309+  0569 C3 4F 53            .BYTE   'C'+80H,"OS"
0310+  056C D3 49 4E            .BYTE   'S'+80H,"IN"
0311+  056F D4 41 4E            .BYTE   'T'+80H,"AN"
0312+  0572 C1 54 4E            .BYTE   'A'+80H,"TN"
0313+  0575 D0 45 45 4B         .BYTE   'P'+80H,"EEK"
0314+  0579 C4 45 45 4B         .BYTE   'D'+80H,"EEK"
0315+  057D D0 4F 49 4E         .BYTE   'P'+80H,"OINT"
0315+  0581 54 
0316+  0582 CC 45 4E            .BYTE   'L'+80H,"EN"
0317+  0585 D3 54 52 24         .BYTE   'S'+80H,"TR$"
0318+  0589 D6 41 4C            .BYTE   'V'+80H,"AL"
0319+  058C C1 53 43            .BYTE   'A'+80H,"SC"
0320+  058F C3 48 52 24         .BYTE   'C'+80H,"HR$"
0321+  0593 C8 45 58 24         .BYTE   'H'+80H,"EX$"
0322+  0597 C2 49 4E 24         .BYTE   'B'+80H,"IN$"
0323+  059B CC 45 46 54         .BYTE   'L'+80H,"EFT$"
0323+  059F 24 
0324+  05A0 D2 49 47 48         .BYTE   'R'+80H,"IGHT$"
0324+  05A4 54 24 
0325+  05A6 CD 49 44 24         .BYTE   'M'+80H,"ID$"
0326+  05AA 80                  .BYTE   80H             ; End of list marker
0327+  05AB             
0328+  05AB             ; KEYWORD ADDRESS TABLE
0329+  05AB             
0330+  05AB A5 0B       WORDTB: .WORD   PEND
0331+  05AD A2 0A               .WORD   FOR
0332+  05AF 7D 0F               .WORD   NEXT
0333+  05B1 F2 0C               .WORD   DATA
0334+  05B3 84 0E               .WORD   INPUT
0335+  05B5 B9 11               .WORD   DIM
0336+  05B7 B3 0E               .WORD   READ
0337+  05B9 09 0D               .WORD   LET
0338+  05BB AF 0C               .WORD   GOTO
0339+  05BD 92 0C               .WORD   RUN
0340+  05BF 81 0D               .WORD   IF
0341+  05C1 6B 0B               .WORD   RESTOR
0342+  05C3 9E 0C               .WORD   GOSUB
0343+  05C5 CD 0C               .WORD   RETURN
0344+  05C7 F4 0C               .WORD   REM
0345+  05C9 A3 0B               .WORD   STOP
0346+  05CB F2 16               .WORD   POUT
0347+  05CD 63 0D               .WORD   ON
0348+  05CF E4 0B               .WORD   NULL
0349+  05D1 F8 16               .WORD   WAIT
0350+  05D3 97 13               .WORD   DEF
0351+  05D5 41 17               .WORD   POKE
0352+  05D7 89 1E               .WORD   DOKE
0353+  05D9 F4 0C               .WORD   REM
0354+  05DB 6F 1E               .WORD   LINES
0355+  05DD 62 1E               .WORD   CLS
0356+  05DF 67 1E               .WORD   WIDTH
0357+  05E1 9F 1F               .WORD   MONITR
0358+  05E3 04 31               .WORD   PSET
0359+  05E5 07 31               .WORD   RESET
0360+  05E7 A5 0D               .WORD   PRINT
0361+  05E9 D1 0B               .WORD   CONT
0362+  05EB 17 0A               .WORD   LIST
0363+  05ED 4C 0C               .WORD   CLEAR
0364+  05EF F4 0C               .WORD   REM
0365+  05F1 F4 0C               .WORD   REM
0366+  05F3 0F 08               .WORD   NEW
0367+  05F5             
0368+  05F5             ; RESERVED WORD TOKEN VALUES
0369+  05F5             
0370+  05F5             ZEND    .EQU    080H            ; END
0371+  05F5             ZFOR    .EQU    081H            ; FOR
0372+  05F5             ZDATA   .EQU    083H            ; DATA
0373+  05F5             ZGOTO   .EQU    088H            ; GOTO
0374+  05F5             ZGOSUB  .EQU    08CH            ; GOSUB
0375+  05F5             ZREM    .EQU    08EH            ; REM
0376+  05F5             ZPRINT  .EQU    09EH            ; PRINT
0377+  05F5             ZNEW    .EQU    0A4H            ; NEW
0378+  05F5             
0379+  05F5             ZTAB    .EQU    0A5H            ; TAB
0380+  05F5             ZTO     .EQU    0A6H            ; TO
0381+  05F5             ZFN     .EQU    0A7H            ; FN
0382+  05F5             ZSPC    .EQU    0A8H            ; SPC
0383+  05F5             ZTHEN   .EQU    0A9H            ; THEN
0384+  05F5             ZNOT    .EQU    0AAH            ; NOT
0385+  05F5             ZSTEP   .EQU    0ABH            ; STEP
0386+  05F5             
0387+  05F5             ZPLUS   .EQU    0ACH            ; +
0388+  05F5             ZMINUS  .EQU    0ADH            ; -
0389+  05F5             ZTIMES  .EQU    0AEH            ; *
0390+  05F5             ZDIV    .EQU    0AFH            ; /
0391+  05F5             ZOR     .EQU    0B2H            ; OR
0392+  05F5             ZGTR    .EQU    0B3H            ; >
0393+  05F5             ZEQUAL  .EQU    0B4H            ; M
0394+  05F5             ZLTH    .EQU    0B5H            ; <
0395+  05F5             ZSGN    .EQU    0B6H            ; SGN
0396+  05F5             ZPOINT  .EQU    0C7H            ; POINT
0397+  05F5             ZLEFT   .EQU    0CDH +2         ; LEFT$
0398+  05F5             
0399+  05F5             ; ARITHMETIC PRECEDENCE TABLE
0400+  05F5             
0401+  05F5 79          PRITAB: .BYTE   79H             ; Precedence value
0402+  05F6 2B 1B               .WORD   PADD            ; FPREG = <last> + FPREG
0403+  05F8             
0404+  05F8 79                  .BYTE   79H             ; Precedence value
0405+  05F9 5F 17               .WORD   PSUB            ; FPREG = <last> - FPREG
0406+  05FB             
0407+  05FB 7C                  .BYTE   7CH             ; Precedence value
0408+  05FC 9D 18               .WORD   MULT            ; PPREG = <last> * FPREG
0409+  05FE             
0410+  05FE 7C                  .BYTE   7CH             ; Precedence value
0411+  05FF FE 18               .WORD   DIV             ; FPREG = <last> / FPREG
0412+  0601             
0413+  0601 7F                  .BYTE   7FH             ; Precedence value
0414+  0602 4C 1C               .WORD   POWER           ; FPREG = <last> ^ FPREG
0415+  0604             
0416+  0604 50                  .BYTE   50H             ; Precedence value
0417+  0605 12 11               .WORD   PAND            ; FPREG = <last> AND FPREG
0418+  0607             
0419+  0607 46                  .BYTE   46H             ; Precedence value
0420+  0608 11 11               .WORD   POR             ; FPREG = <last> OR FPREG
0421+  060A             
0422+  060A             ; BASIC ERROR CODE LIST
0423+  060A             
0424+  060A 4E 46       ERRORS: .BYTE   "NF"            ; NEXT without FOR
0425+  060C 53 4E               .BYTE   "SN"            ; Syntax error
0426+  060E 52 47               .BYTE   "RG"            ; RETURN without GOSUB
0427+  0610 4F 44               .BYTE   "OD"            ; Out of DATA
0428+  0612 46 43               .BYTE   "FC"            ; Illegal function call
0429+  0614 4F 56               .BYTE   "OV"            ; Overflow error
0430+  0616 4F 4D               .BYTE   "OM"            ; Out of memory
0431+  0618 55 4C               .BYTE   "UL"            ; Undefined line
0432+  061A 42 53               .BYTE   "BS"            ; Bad subscript
0433+  061C 44 44               .BYTE   "DD"            ; Re-DIMensioned array
0434+  061E 2F 30               .BYTE   "/0"            ; Division by zero
0435+  0620 49 44               .BYTE   "ID"            ; Illegal direct
0436+  0622 54 4D               .BYTE   "TM"            ; Type mis-match
0437+  0624 4F 53               .BYTE   "OS"            ; Out of string space
0438+  0626 4C 53               .BYTE   "LS"            ; String too long
0439+  0628 53 54               .BYTE   "ST"            ; String formula too complex
0440+  062A 43 4E               .BYTE   "CN"            ; Can't CONTinue
0441+  062C 55 46               .BYTE   "UF"            ; Undefined FN function
0442+  062E 4D 4F               .BYTE   "MO"            ; Missing operand
0443+  0630 48 58               .BYTE   "HX"            ; HEX error
0444+  0632 42 4E               .BYTE   "BN"            ; BIN error
0445+  0634             
0446+  0634             ; INITIALISATION TABLE -------------------------------------------------------
0447+  0634             
0448+  0634 C3 FA 03    INITAB: JP      WARMST          ; Warm start jump
0449+  0637 C3 22 0C            JP      FCERR           ; "USR (X)" jump (Set to Error)
0450+  063A D3 00               OUT     (0),A           ; "OUT p,n" skeleton
0451+  063C C9                  RET
0452+  063D D6 00               SUB     0               ; Division support routine
0453+  063F 6F                  LD      L,A
0454+  0640 7C                  LD      A,H
0455+  0641 DE 00               SBC     A,0
0456+  0643 67                  LD      H,A
0457+  0644 78                  LD      A,B
0458+  0645 DE 00               SBC     A,0
0459+  0647 47                  LD      B,A
0460+  0648 3E 00               LD      A,0
0461+  064A C9                  RET
0462+  064B 00 00 00            .BYTE   0,0,0                   ; Random number seed table used by RND
0463+  064E 35 4A CA 99         .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
0464+  0652 39 1C 76 98         .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
0465+  0656 22 95 B3 98         .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
0466+  065A 0A DD 47 98         .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
0467+  065E 53 D1 99 99         .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
0468+  0662 0A 1A 9F 98         .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
0469+  0666 65 BC CD 98         .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
0470+  066A D6 77 3E 98         .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
0471+  066E 52 C7 4F 80         .BYTE   052H,0C7H,04FH,080H     ; Last random number
0472+  0672 DB 00               IN      A,(0)           ; INP (x) skeleton
0473+  0674 C9                  RET
0474+  0675 01                  .BYTE   1               ; POS (x) number (1)
0475+  0676 FF                  .BYTE   255             ; Terminal width (255 = no auto CRLF)
0476+  0677 1C                  .BYTE   28              ; Width for commas (3 columns)
0477+  0678 00                  .BYTE   0               ; No nulls after input bytes
0478+  0679 00                  .BYTE   0               ; Output enabled (^O off)
0479+  067A 14 00               .WORD   20              ; Initial lines counter
0480+  067C 14 00               .WORD   20              ; Initial lines number
0481+  067E 00 00               .WORD   0               ; Array load/save check sum
0482+  0680 00                  .BYTE   0               ; Break not by NMI
0483+  0681 00                  .BYTE   0               ; Break flag
0484+  0682 C3 48 09            JP      TTYLIN          ; Input reflection (set to TTY)
0485+  0685 C3 00 00            JP      $0000           ; POINT reflection unused
0486+  0688 C3 00 00            JP      $0000           ; SET reflection
0487+  068B C3 00 00            JP      $0000          	; RESET reflection
0488+  068E 0D 32               .WORD   STLOOK          ; Temp string space
0489+  0690 FE FF               .WORD   -2              ; Current line number (cold)
0490+  0692 AA 31               .WORD   PROGST+1        ; Start of program text
0491+  0694             INITBE:                         
0492+  0694             
0493+  0694             ; END OF INITIALISATION TABLE ---------------------------------------------------
0494+  0694             
0495+  0694 20 45 72 72 ERRMSG: .BYTE   " Error",0
0495+  0698 6F 72 00 
0496+  069B 20 69 6E 20 INMSG:  .BYTE   " in ",0
0496+  069F 00 
0497+  06A0             ZERBYT  .EQU    $-1             ; A zero byte
0498+  06A0 4F 6B 0D 0A OKMSG:  .BYTE   "Ok",CR,LF,0,0
0498+  06A4 00 00 
0499+  06A6 42 72 65 61 BRKMSG: .BYTE   "Break",0
0499+  06AA 6B 00 
0500+  06AC             
0501+  06AC 21 04 00    BAKSTK: LD      HL,4            ; Look for "FOR" block with
0502+  06AF 39                  ADD     HL,SP           ; same index as specified
0503+  06B0 7E          LOKFOR: LD      A,(HL)          ; Get block ID
0504+  06B1 23                  INC     HL              ; Point to index address
0505+  06B2 FE 81               CP      ZFOR            ; Is it a "FOR" token
0506+  06B4 C0                  RET     NZ              ; No - exit
0507+  06B5 4E                  LD      C,(HL)          ; BC = Address of "FOR" index
0508+  06B6 23                  INC     HL
0509+  06B7 46                  LD      B,(HL)
0510+  06B8 23                  INC     HL              ; Point to sign of STEP
0511+  06B9 E5                  PUSH    HL              ; Save pointer to sign
0512+  06BA 69                  LD      L,C             ; HL = address of "FOR" index
0513+  06BB 60                  LD      H,B
0514+  06BC 7A                  LD      A,D             ; See if an index was specified
0515+  06BD B3                  OR      E               ; DE = 0 if no index specified
0516+  06BE EB                  EX      DE,HL           ; Specified index into HL
0517+  06BF CA C6 06            JP      Z,INDFND        ; Skip if no index given
0518+  06C2 EB                  EX      DE,HL           ; Index back into DE
0519+  06C3 CD CB 09            CALL    CPDEHL          ; Compare index with one given
0520+  06C6 01 0D 00    INDFND: LD      BC,16-3         ; Offset to next block
0521+  06C9 E1                  POP     HL              ; Restore pointer to sign
0522+  06CA C8                  RET     Z               ; Return if block found
0523+  06CB 09                  ADD     HL,BC           ; Point to next block
0524+  06CC C3 B0 06            JP      LOKFOR          ; Keep on looking
0525+  06CF             
0526+  06CF CD E9 06    MOVUP:  CALL    ENFMEM          ; See if enough memory
0527+  06D2 C5          MOVSTR: PUSH    BC              ; Save end of source
0528+  06D3 E3                  EX      (SP),HL         ; Swap source and dest" end
0529+  06D4 C1                  POP     BC              ; Get end of destination
0530+  06D5 CD CB 09    MOVLP:  CALL    CPDEHL          ; See if list moved
0531+  06D8 7E                  LD      A,(HL)          ; Get byte
0532+  06D9 02                  LD      (BC),A          ; Move it
0533+  06DA C8                  RET     Z               ; Exit if all done
0534+  06DB 0B                  DEC     BC              ; Next byte to move to
0535+  06DC 2B                  DEC     HL              ; Next byte to move
0536+  06DD C3 D5 06            JP      MOVLP           ; Loop until all bytes moved
0537+  06E0             
0538+  06E0 E5          CHKSTK: PUSH    HL              ; Save code string address
0539+  06E1 2A 8A 31            LD      HL,(ARREND)     ; Lowest free memory
0540+  06E4 06 00               LD      B,0             ; BC = Number of levels to test
0541+  06E6 09                  ADD     HL,BC           ; 2 Bytes for each level
0542+  06E7 09                  ADD     HL,BC
0543+  06E8 3E                  .BYTE   3EH             ; Skip "PUSH HL"
0544+  06E9 E5          ENFMEM: PUSH    HL              ; Save code string address
0545+  06EA 3E D0               LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
0546+  06EC 95                  SUB     L
0547+  06ED 6F                  LD      L,A
0548+  06EE 3E FF               LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
0549+  06F0 9C                  SBC     A,H
0550+  06F1 DA F8 06            JP      C,OMERR         ; Not enough - ?OM Error
0551+  06F4 67                  LD      H,A
0552+  06F5 39                  ADD     HL,SP           ; Test if stack is overflowed
0553+  06F6 E1                  POP     HL              ; Restore code string address
0554+  06F7 D8                  RET     C               ; Return if enough mmory
0555+  06F8 1E 0C       OMERR:  LD      E,OM            ; ?OM Error
0556+  06FA C3 17 07            JP      ERROR
0557+  06FD             
0558+  06FD 2A 79 31    DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
0559+  0700 22 0C 31            LD      (LINEAT),HL     ; Save as current line
0560+  0703 1E 02       SNERR:  LD      E,SN            ; ?SN Error
0561+  0705 01                  .BYTE   01H             ; Skip "LD E,DZ"
0562+  0706 1E 14       DZERR:  LD      E,DZ            ; ?/0 Error
0563+  0708 01                  .BYTE   01H             ; Skip "LD E,NF"
0564+  0709 1E 00       NFERR:  LD      E,NF            ; ?NF Error
0565+  070B 01                  .BYTE   01H             ; Skip "LD E,DD"
0566+  070C 1E 12       DDERR:  LD      E,DD            ; ?DD Error
0567+  070E 01                  .BYTE   01H             ; Skip "LD E,UF"
0568+  070F 1E 22       UFERR:  LD      E,UF            ; ?UF Error
0569+  0711 01                  .BYTE   01H             ; Skip "LD E,OV
0570+  0712 1E 0A       OVERR:  LD      E,OV            ; ?OV Error
0571+  0714 01                  .BYTE   01H             ; Skip "LD E,TM"
0572+  0715 1E 18       TMERR:  LD      E,TM            ; ?TM Error
0573+  0717             
0574+  0717 CD 35 08    ERROR:  CALL    CLREG           ; Clear registers and stack
0575+  071A 32 F5 30            LD      (CTLOFG),A      ; Enable output (A is 0)
0576+  071D CD F6 0D            CALL    STTLIN          ; Start new line
0577+  0720 21 0A 06            LD      HL,ERRORS       ; Point to error codes
0578+  0723 57                  LD      D,A             ; D = 0 (A is 0)
0579+  0724 3E 3F               LD      A,'?'
0580+  0726 CD DC 09            CALL    OUTC            ; Output '?'
0581+  0729 19                  ADD     HL,DE           ; Offset to correct error code
0582+  072A 7E                  LD      A,(HL)          ; First character
0583+  072B CD DC 09            CALL    OUTC            ; Output it
0584+  072E CD 5B 0B            CALL    GETCHR          ; Get next character
0585+  0731 CD DC 09            CALL    OUTC            ; Output it
0586+  0734 21 94 06            LD      HL,ERRMSG       ; "Error" message
0587+  0737 CD A1 14    ERRIN:  CALL    PRS             ; Output message
0588+  073A 2A 0C 31            LD      HL,(LINEAT)     ; Get line of error
0589+  073D 11 FE FF            LD      DE,-2           ; Cold start error if -2
0590+  0740 CD CB 09            CALL    CPDEHL          ; See if cold start error
0591+  0743 CA 67 03            JP      Z,CSTART        ; Cold start error - Restart
0592+  0746 7C                  LD      A,H             ; Was it a direct error?
0593+  0747 A5                  AND     L               ; Line = -1 if direct error
0594+  0748 3C                  INC     A
0595+  0749 C4 3C 1B            CALL    NZ,LINEIN       ; No - output line of error
0596+  074C 3E                  .BYTE   3EH             ; Skip "POP BC"
0597+  074D C1          POPNOK: POP     BC              ; Drop address in input buffer
0598+  074E             
0599+  074E AF          PRNTOK: XOR     A               ; Output "Ok" and get command
0600+  074F 32 F5 30            LD      (CTLOFG),A      ; Enable output
0601+  0752 CD F6 0D            CALL    STTLIN          ; Start new line
0602+  0755 21 A0 06            LD      HL,OKMSG        ; "Ok" message
0603+  0758 CD A1 14            CALL    PRS             ; Output "Ok"
0604+  075B 21 FF FF    GETCMD: LD      HL,-1           ; Flag direct mode
0605+  075E 22 0C 31            LD      (LINEAT),HL     ; Save as current line
0606+  0761 CD 48 09            CALL    GETLIN          ; Get an input line
0607+  0764 DA 5B 07            JP      C,GETCMD        ; Get line again if break
0608+  0767 CD 5B 0B            CALL    GETCHR          ; Get first character
0609+  076A 3C                  INC     A               ; Test if end of line
0610+  076B 3D                  DEC     A               ; Without affecting Carry
0611+  076C CA 5B 07            JP      Z,GETCMD        ; Nothing entered - Get another
0612+  076F F5                  PUSH    AF              ; Save Carry status
0613+  0770 CD 27 0C            CALL    ATOH            ; Get line number into DE
0614+  0773 D5                  PUSH    DE              ; Save line number
0615+  0774 CD 5F 08            CALL    CRUNCH          ; Tokenise rest of line
0616+  0777 47                  LD      B,A             ; Length of tokenised line
0617+  0778 D1                  POP     DE              ; Restore line number
0618+  0779 F1                  POP     AF              ; Restore Carry
0619+  077A D2 3B 0B            JP      NC,EXCUTE       ; No line number - Direct mode
0620+  077D D5                  PUSH    DE              ; Save line number
0621+  077E C5                  PUSH    BC              ; Save length of tokenised line
0622+  077F AF                  XOR     A
0623+  0780 32 7C 31            LD      (LSTBIN),A      ; Clear last byte input
0624+  0783 CD 5B 0B            CALL    GETCHR          ; Get next character
0625+  0786 B7                  OR      A               ; Set flags
0626+  0787 F5                  PUSH    AF              ; And save them
0627+  0788 CD EF 07            CALL    SRCHLN          ; Search for line number in DE
0628+  078B DA 94 07            JP      C,LINFND        ; Jump if line found
0629+  078E F1                  POP     AF              ; Get status
0630+  078F F5                  PUSH    AF              ; And re-save
0631+  0790 CA C8 0C            JP      Z,ULERR         ; Nothing after number - Error
0632+  0793 B7                  OR      A               ; Clear Carry
0633+  0794 C5          LINFND: PUSH    BC              ; Save address of line in prog
0634+  0795 D2 AB 07            JP      NC,INEWLN       ; Line not found - Insert new
0635+  0798 EB                  EX      DE,HL           ; Next line address in DE
0636+  0799 2A 86 31            LD      HL,(PROGND)     ; End of program
0637+  079C 1A          SFTPRG: LD      A,(DE)          ; Shift rest of program down
0638+  079D 02                  LD      (BC),A
0639+  079E 03                  INC     BC              ; Next destination
0640+  079F 13                  INC     DE              ; Next source
0641+  07A0 CD CB 09            CALL    CPDEHL          ; All done?
0642+  07A3 C2 9C 07            JP      NZ,SFTPRG       ; More to do
0643+  07A6 60                  LD      H,B             ; HL - New end of program
0644+  07A7 69                  LD      L,C
0645+  07A8 22 86 31            LD      (PROGND),HL     ; Update end of program
0646+  07AB             
0647+  07AB D1          INEWLN: POP     DE              ; Get address of line,
0648+  07AC F1                  POP     AF              ; Get status
0649+  07AD CA D2 07            JP      Z,SETPTR        ; No text - Set up pointers
0650+  07B0 2A 86 31            LD      HL,(PROGND)     ; Get end of program
0651+  07B3 E3                  EX      (SP),HL         ; Get length of input line
0652+  07B4 C1                  POP     BC              ; End of program to BC
0653+  07B5 09                  ADD     HL,BC           ; Find new end
0654+  07B6 E5                  PUSH    HL              ; Save new end
0655+  07B7 CD CF 06            CALL    MOVUP           ; Make space for line
0656+  07BA E1                  POP     HL              ; Restore new end
0657+  07BB 22 86 31            LD      (PROGND),HL     ; Update end of program pointer
0658+  07BE EB                  EX      DE,HL           ; Get line to move up in HL
0659+  07BF 74                  LD      (HL),H          ; Save MSB
0660+  07C0 D1                  POP     DE              ; Get new line number
0661+  07C1 23                  INC     HL              ; Skip pointer
0662+  07C2 23                  INC     HL
0663+  07C3 73                  LD      (HL),E          ; Save LSB of line number
0664+  07C4 23                  INC     HL
0665+  07C5 72                  LD      (HL),D          ; Save MSB of line number
0666+  07C6 23                  INC     HL              ; To first byte in line
0667+  07C7 11 11 31            LD      DE,BUFFER       ; Copy buffer to program
0668+  07CA 1A          MOVBUF: LD      A,(DE)          ; Get source
0669+  07CB 77                  LD      (HL),A          ; Save destinations
0670+  07CC 23                  INC     HL              ; Next source
0671+  07CD 13                  INC     DE              ; Next destination
0672+  07CE B7                  OR      A               ; Done?
0673+  07CF C2 CA 07            JP      NZ,MOVBUF       ; No - Repeat
0674+  07D2 CD 1B 08    SETPTR: CALL    RUNFST          ; Set line pointers
0675+  07D5 23                  INC     HL              ; To LSB of pointer
0676+  07D6 EB                  EX      DE,HL           ; Address to DE
0677+  07D7 62          PTRLP:  LD      H,D             ; Address to HL
0678+  07D8 6B                  LD      L,E
0679+  07D9 7E                  LD      A,(HL)          ; Get LSB of pointer
0680+  07DA 23                  INC     HL              ; To MSB of pointer
0681+  07DB B6                  OR      (HL)            ; Compare with MSB pointer
0682+  07DC CA 5B 07            JP      Z,GETCMD        ; Get command line if end
0683+  07DF 23                  INC     HL              ; To LSB of line number
0684+  07E0 23                  INC     HL              ; Skip line number
0685+  07E1 23                  INC     HL              ; Point to first byte in line
0686+  07E2 AF                  XOR     A               ; Looking for 00 byte
0687+  07E3 BE          FNDEND: CP      (HL)            ; Found end of line?
0688+  07E4 23                  INC     HL              ; Move to next byte
0689+  07E5 C2 E3 07            JP      NZ,FNDEND       ; No - Keep looking
0690+  07E8 EB                  EX      DE,HL           ; Next line address to HL
0691+  07E9 73                  LD      (HL),E          ; Save LSB of pointer
0692+  07EA 23                  INC     HL
0693+  07EB 72                  LD      (HL),D          ; Save MSB of pointer
0694+  07EC C3 D7 07            JP      PTRLP           ; Do next line
0695+  07EF             
0696+  07EF 2A 0E 31    SRCHLN: LD      HL,(BASTXT)     ; Start of program text
0697+  07F2 44          SRCHLP: LD      B,H             ; BC = Address to look at
0698+  07F3 4D                  LD      C,L
0699+  07F4 7E                  LD      A,(HL)          ; Get address of next line
0700+  07F5 23                  INC     HL
0701+  07F6 B6                  OR      (HL)            ; End of program found?
0702+  07F7 2B                  DEC     HL
0703+  07F8 C8                  RET     Z               ; Yes - Line not found
0704+  07F9 23                  INC     HL
0705+  07FA 23                  INC     HL
0706+  07FB 7E                  LD      A,(HL)          ; Get LSB of line number
0707+  07FC 23                  INC     HL
0708+  07FD 66                  LD      H,(HL)          ; Get MSB of line number
0709+  07FE 6F                  LD      L,A
0710+  07FF CD CB 09            CALL    CPDEHL          ; Compare with line in DE
0711+  0802 60                  LD      H,B             ; HL = Start of this line
0712+  0803 69                  LD      L,C
0713+  0804 7E                  LD      A,(HL)          ; Get LSB of next line address
0714+  0805 23                  INC     HL
0715+  0806 66                  LD      H,(HL)          ; Get MSB of next line address
0716+  0807 6F                  LD      L,A             ; Next line to HL
0717+  0808 3F                  CCF
0718+  0809 C8                  RET     Z               ; Lines found - Exit
0719+  080A 3F                  CCF
0720+  080B D0                  RET     NC              ; Line not found,at line after
0721+  080C C3 F2 07            JP      SRCHLP          ; Keep looking
0722+  080F             
0723+  080F C0          NEW:    RET     NZ              ; Return if any more on line
0724+  0810 2A 0E 31    CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
0725+  0813 AF                  XOR     A               ; Set program area to empty
0726+  0814 77                  LD      (HL),A          ; Save LSB = 00
0727+  0815 23                  INC     HL
0728+  0816 77                  LD      (HL),A          ; Save MSB = 00
0729+  0817 23                  INC     HL
0730+  0818 22 86 31            LD      (PROGND),HL     ; Set program end
0731+  081B             
0732+  081B 2A 0E 31    RUNFST: LD      HL,(BASTXT)     ; Clear all variables
0733+  081E 2B                  DEC     HL
0734+  081F             
0735+  081F 22 7E 31    INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
0736+  0822 2A 5F 31            LD      HL,(LSTRAM)     ; Get end of RAM
0737+  0825 22 73 31            LD      (STRBOT),HL     ; Clear string space
0738+  0828 AF                  XOR     A
0739+  0829 CD 6B 0B            CALL    RESTOR          ; Reset DATA pointers
0740+  082C 2A 86 31            LD      HL,(PROGND)     ; Get end of program
0741+  082F 22 88 31            LD      (VAREND),HL     ; Clear variables
0742+  0832 22 8A 31            LD      (ARREND),HL     ; Clear arrays
0743+  0835             
0744+  0835 C1          CLREG:  POP     BC              ; Save return address
0745+  0836 2A 0A 31            LD      HL,(STRSPC)     ; Get end of working RAN
0746+  0839 F9                  LD      SP,HL           ; Set stack
0747+  083A 21 63 31            LD      HL,TMSTPL       ; Temporary string pool
0748+  083D 22 61 31            LD      (TMSTPT),HL     ; Reset temporary string ptr
0749+  0840 AF                  XOR     A               ; A = 00
0750+  0841 6F                  LD      L,A             ; HL = 0000
0751+  0842 67                  LD      H,A
0752+  0843 22 84 31            LD      (CONTAD),HL     ; No CONTinue
0753+  0846 32 7B 31            LD      (FORFLG),A      ; Clear FOR flag
0754+  0849 22 8E 31            LD      (FNRGNM),HL     ; Clear FN argument
0755+  084C E5                  PUSH    HL              ; HL = 0000
0756+  084D C5                  PUSH    BC              ; Put back return
0757+  084E 2A 7E 31    DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
0758+  0851 C9                  RET                     ; Return to execution driver
0759+  0852             
0760+  0852 3E 3F       PROMPT: LD      A,'?'           ; '?'
0761+  0854 CD DC 09            CALL    OUTC            ; Output character
0762+  0857 3E 20               LD      A,' '           ; Space
0763+  0859 CD DC 09            CALL    OUTC            ; Output character
0764+  085C C3 FE 30            JP      RINPUT          ; Get input line
0765+  085F             
0766+  085F AF          CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
0767+  0860 32 5E 31            LD      (DATFLG),A      ; Reset literal flag
0768+  0863 0E 05               LD      C,2+3           ; 2 byte number and 3 nulls
0769+  0865 11 11 31            LD      DE,BUFFER       ; Start of input buffer
0770+  0868 7E          CRNCLP: LD      A,(HL)          ; Get byte
0771+  0869 FE 20               CP      ' '             ; Is it a space?
0772+  086B CA E7 08            JP      Z,MOVDIR        ; Yes - Copy direct
0773+  086E 47                  LD      B,A             ; Save character
0774+  086F FE 22               CP      '"'             ; Is it a quote?
0775+  0871 CA 07 09            JP      Z,CPYLIT        ; Yes - Copy literal string
0776+  0874 B7                  OR      A               ; Is it end of buffer?
0777+  0875 CA 0E 09            JP      Z,ENDBUF        ; Yes - End buffer
0778+  0878 3A 5E 31            LD      A,(DATFLG)      ; Get data type
0779+  087B B7                  OR      A               ; Literal?
0780+  087C 7E                  LD      A,(HL)          ; Get byte to copy
0781+  087D C2 E7 08            JP      NZ,MOVDIR       ; Literal - Copy direct
0782+  0880 FE 3F               CP      '?'             ; Is it '?' short for PRINT
0783+  0882 3E 9E               LD      A,ZPRINT        ; "PRINT" token
0784+  0884 CA E7 08            JP      Z,MOVDIR        ; Yes - replace it
0785+  0887 7E                  LD      A,(HL)          ; Get byte again
0786+  0888 FE 30               CP      '0'             ; Is it less than '0'
0787+  088A DA 92 08            JP      C,FNDWRD        ; Yes - Look for reserved words
0788+  088D FE 3C               CP      60; ";"+1           ; Is it "0123456789:;" ?
0789+  088F DA E7 08            JP      C,MOVDIR        ; Yes - copy it direct
0790+  0892 D5          FNDWRD: PUSH    DE              ; Look for reserved words
0791+  0893 11 8B 04            LD      DE,WORDS-1      ; Point to table
0792+  0896 C5                  PUSH    BC              ; Save count
0793+  0897 01 E3 08            LD      BC,RETNAD       ; Where to return to
0794+  089A C5                  PUSH    BC              ; Save return address
0795+  089B 06 7F               LD      B,ZEND-1        ; First token value -1
0796+  089D 7E                  LD      A,(HL)          ; Get byte
0797+  089E FE 61               CP      'a'             ; Less than 'a' ?
0798+  08A0 DA AB 08            JP      C,SEARCH        ; Yes - search for words
0799+  08A3 FE 7B               CP      'z'+1           ; Greater than 'z' ?
0800+  08A5 D2 AB 08            JP      NC,SEARCH       ; Yes - search for words
0801+  08A8 E6 5F               AND     01011111B       ; Force upper case
0802+  08AA 77                  LD      (HL),A          ; Replace byte
0803+  08AB 4E          SEARCH: LD      C,(HL)          ; Search for a word
0804+  08AC EB                  EX      DE,HL
0805+  08AD 23          GETNXT: INC     HL              ; Get next reserved word
0806+  08AE B6                  OR      (HL)            ; Start of word?
0807+  08AF F2 AD 08            JP      P,GETNXT        ; No - move on
0808+  08B2 04                  INC     B               ; Increment token value
0809+  08B3 7E                  LD      A, (HL)         ; Get byte from table
0810+  08B4 E6 7F               AND     01111111B       ; Strip bit 7
0811+  08B6 C8                  RET     Z               ; Return if end of list
0812+  08B7 B9                  CP      C               ; Same character as in buffer?
0813+  08B8 C2 AD 08            JP      NZ,GETNXT       ; No - get next word
0814+  08BB EB                  EX      DE,HL
0815+  08BC E5                  PUSH    HL              ; Save start of word
0816+  08BD             
0817+  08BD 13          NXTBYT: INC     DE              ; Look through rest of word
0818+  08BE 1A                  LD      A,(DE)          ; Get byte from table
0819+  08BF B7                  OR      A               ; End of word ?
0820+  08C0 FA DF 08            JP      M,MATCH         ; Yes - Match found
0821+  08C3 4F                  LD      C,A             ; Save it
0822+  08C4 78                  LD      A,B             ; Get token value
0823+  08C5 FE 88               CP      ZGOTO           ; Is it "GOTO" token ?
0824+  08C7 C2 CE 08            JP      NZ,NOSPC        ; No - Don't allow spaces
0825+  08CA CD 5B 0B            CALL    GETCHR          ; Get next character
0826+  08CD 2B                  DEC     HL              ; Cancel increment from GETCHR
0827+  08CE 23          NOSPC:  INC     HL              ; Next byte
0828+  08CF 7E                  LD      A,(HL)          ; Get byte
0829+  08D0 FE 61               CP      'a'             ; Less than 'a' ?
0830+  08D2 DA D7 08            JP      C,NOCHNG        ; Yes - don't change
0831+  08D5 E6 5F               AND     01011111B       ; Make upper case
0832+  08D7 B9          NOCHNG: CP      C               ; Same as in buffer ?
0833+  08D8 CA BD 08            JP      Z,NXTBYT        ; Yes - keep testing
0834+  08DB E1                  POP     HL              ; Get back start of word
0835+  08DC C3 AB 08            JP      SEARCH          ; Look at next word
0836+  08DF             
0837+  08DF 48          MATCH:  LD      C,B             ; Word found - Save token value
0838+  08E0 F1                  POP     AF              ; Throw away return
0839+  08E1 EB                  EX      DE,HL
0840+  08E2 C9                  RET                     ; Return to "RETNAD"
0841+  08E3 EB          RETNAD: EX      DE,HL           ; Get address in string
0842+  08E4 79                  LD      A,C             ; Get token value
0843+  08E5 C1                  POP     BC              ; Restore buffer length
0844+  08E6 D1                  POP     DE              ; Get destination address
0845+  08E7 23          MOVDIR: INC     HL              ; Next source in buffer
0846+  08E8 12                  LD      (DE),A          ; Put byte in buffer
0847+  08E9 13                  INC     DE              ; Move up buffer
0848+  08EA 0C                  INC     C               ; Increment length of buffer
0849+  08EB D6 3A               SUB     ':'             ; End of statement?
0850+  08ED CA F5 08            JP      Z,SETLIT        ; Jump if multi-statement line
0851+  08F0 FE 49               CP      ZDATA-3AH       ; Is it DATA statement ?
0852+  08F2 C2 F8 08            JP      NZ,TSTREM       ; No - see if REM
0853+  08F5 32 5E 31    SETLIT: LD      (DATFLG),A      ; Set literal flag
0854+  08F8 D6 54       TSTREM: SUB     ZREM-3AH        ; Is it REM?
0855+  08FA C2 68 08            JP      NZ,CRNCLP       ; No - Leave flag
0856+  08FD 47                  LD      B,A             ; Copy rest of buffer
0857+  08FE 7E          NXTCHR: LD      A,(HL)          ; Get byte
0858+  08FF B7                  OR      A               ; End of line ?
0859+  0900 CA 0E 09            JP      Z,ENDBUF        ; Yes - Terminate buffer
0860+  0903 B8                  CP      B               ; End of statement ?
0861+  0904 CA E7 08            JP      Z,MOVDIR        ; Yes - Get next one
0862+  0907 23          CPYLIT: INC     HL              ; Move up source string
0863+  0908 12                  LD      (DE),A          ; Save in destination
0864+  0909 0C                  INC     C               ; Increment length
0865+  090A 13                  INC     DE              ; Move up destination
0866+  090B C3 FE 08            JP      NXTCHR          ; Repeat
0867+  090E             
0868+  090E 21 10 31    ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
0869+  0911 12                  LD      (DE),A          ; Mark end of buffer (A = 00)
0870+  0912 13                  INC     DE
0871+  0913 12                  LD      (DE),A          ; A = 00
0872+  0914 13                  INC     DE
0873+  0915 12                  LD      (DE),A          ; A = 00
0874+  0916 C9                  RET
0875+  0917             
0876+  0917 3A F4 30    DODEL:  LD      A,(NULFLG)      ; Get null flag status
0877+  091A B7                  OR      A               ; Is it zero?
0878+  091B 3E 00               LD      A,0             ; Zero A - Leave flags
0879+  091D 32 F4 30            LD      (NULFLG),A      ; Zero null flag
0880+  0920 C2 2B 09            JP      NZ,ECHDEL       ; Set - Echo it
0881+  0923 05                  DEC     B               ; Decrement length
0882+  0924 CA 48 09            JP      Z,GETLIN        ; Get line again if empty
0883+  0927 CD DC 09            CALL    OUTC            ; Output null character
0884+  092A 3E                  .BYTE   3EH             ; Skip "DEC B"
0885+  092B 05          ECHDEL: DEC     B               ; Count bytes in buffer
0886+  092C 2B                  DEC     HL              ; Back space buffer
0887+  092D CA 3F 09            JP      Z,OTKLN         ; No buffer - Try again
0888+  0930 7E                  LD      A,(HL)          ; Get deleted byte
0889+  0931 CD DC 09            CALL    OUTC            ; Echo it
0890+  0934 C3 51 09            JP      MORINP          ; Get more input
0891+  0937             
0892+  0937 05          DELCHR: DEC     B               ; Count bytes in buffer
0893+  0938 2B                  DEC     HL              ; Back space buffer
0894+  0939 CD DC 09            CALL    OUTC            ; Output character in A
0895+  093C C2 51 09            JP      NZ,MORINP       ; Not end - Get more
0896+  093F CD DC 09    OTKLN:  CALL    OUTC            ; Output character in A
0897+  0942 CD 03 0E    KILIN:  CALL    PRNTCRLF        ; Output CRLF
0898+  0945 C3 48 09            JP      TTYLIN          ; Get line again
0899+  0948             
0900+  0948             GETLIN:
0901+  0948 21 11 31    TTYLIN: LD      HL,BUFFER       ; Get a line by character
0902+  094B 06 01               LD      B,1             ; Set buffer as empty
0903+  094D AF                  XOR     A
0904+  094E 32 F4 30            LD      (NULFLG),A      ; Clear null flag
0905+  0951 CD 06 0A    MORINP: CALL    CLOTST          ; Get character and test ^O
0906+  0954 4F                  LD      C,A             ; Save character in C
0907+  0955 FE 7F               CP      DEL             ; Delete character?
0908+  0957 CA 17 09            JP      Z,DODEL         ; Yes - Process it
0909+  095A 3A F4 30            LD      A,(NULFLG)      ; Get null flag
0910+  095D B7                  OR      A               ; Test null flag status
0911+  095E CA 6A 09            JP      Z,PROCES        ; Reset - Process character
0912+  0961 3E 00               LD      A,0             ; Set a null
0913+  0963 CD DC 09            CALL    OUTC            ; Output null
0914+  0966 AF                  XOR     A               ; Clear A
0915+  0967 32 F4 30            LD      (NULFLG),A      ; Reset null flag
0916+  096A 79          PROCES: LD      A,C             ; Get character
0917+  096B FE 07               CP      CTRLG           ; Bell?
0918+  096D CA AE 09            JP      Z,PUTCTL        ; Yes - Save it
0919+  0970 FE 03               CP      CTRLC           ; Is it control "C"?
0920+  0972 CC 03 0E            CALL    Z,PRNTCRLF      ; Yes - Output CRLF
0921+  0975 37                  SCF                     ; Flag break
0922+  0976 C8                  RET     Z               ; Return if control "C"
0923+  0977 FE 0D               CP      CR              ; Is it enter?
0924+  0979 CA FE 0D            JP      Z,ENDINP        ; Yes - Terminate input
0925+  097C FE 15               CP      CTRLU           ; Is it control "U"?
0926+  097E CA 42 09            JP      Z,KILIN         ; Yes - Get another line
0927+  0981 FE 40               CP      '@'             ; Is it "kill line"?
0928+  0983 CA 3F 09            JP      Z,OTKLN         ; Yes - Kill line
0929+  0986 FE 5F               CP      '_'             ; Is it delete?
0930+  0988 CA 37 09            JP      Z,DELCHR        ; Yes - Delete character
0931+  098B FE 08               CP      BKSP            ; Is it backspace?
0932+  098D CA 37 09            JP      Z,DELCHR        ; Yes - Delete character
0933+  0990 FE 12               CP      CTRLR           ; Is it control "R"?
0934+  0992 C2 A9 09            JP      NZ,PUTBUF       ; No - Put in buffer
0935+  0995 C5                  PUSH    BC              ; Save buffer length
0936+  0996 D5                  PUSH    DE              ; Save DE
0937+  0997 E5                  PUSH    HL              ; Save buffer address
0938+  0998 36 00               LD      (HL),0          ; Mark end of buffer
0939+  099A CD B3 1F            CALL    OUTNCR          ; Output and do CRLF
0940+  099D 21 11 31            LD      HL,BUFFER       ; Point to buffer start
0941+  09A0 CD A1 14            CALL    PRS             ; Output buffer
0942+  09A3 E1                  POP     HL              ; Restore buffer address
0943+  09A4 D1                  POP     DE              ; Restore DE
0944+  09A5 C1                  POP     BC              ; Restore buffer length
0945+  09A6 C3 51 09            JP      MORINP          ; Get another character
0946+  09A9             
0947+  09A9 FE 20       PUTBUF: CP      ' '             ; Is it a control code?
0948+  09AB DA 51 09            JP      C,MORINP        ; Yes - Ignore
0949+  09AE 78          PUTCTL: LD      A,B             ; Get number of bytes in buffer
0950+  09AF FE 49               CP      72+1            ; Test for line overflow
0951+  09B1 3E 07               LD      A,CTRLG         ; Set a bell
0952+  09B3 D2 C3 09            JP      NC,OUTNBS       ; Ring bell if buffer full
0953+  09B6 79                  LD      A,C             ; Get character
0954+  09B7 71                  LD      (HL),C          ; Save in buffer
0955+  09B8 32 7C 31            LD      (LSTBIN),A      ; Save last input byte
0956+  09BB 23                  INC     HL              ; Move up buffer
0957+  09BC 04                  INC     B               ; Increment length
0958+  09BD CD DC 09    OUTIT:  CALL    OUTC            ; Output the character entered
0959+  09C0 C3 51 09            JP      MORINP          ; Get another character
0960+  09C3             
0961+  09C3 CD DC 09    OUTNBS: CALL    OUTC            ; Output bell and back over it
0962+  09C6 3E 08               LD      A,BKSP          ; Set back space
0963+  09C8 C3 BD 09            JP      OUTIT           ; Output it and get more
0964+  09CB             
0965+  09CB 7C          CPDEHL: LD      A,H             ; Get H
0966+  09CC 92                  SUB     D               ; Compare with D
0967+  09CD C0                  RET     NZ              ; Different - Exit
0968+  09CE 7D                  LD      A,L             ; Get L
0969+  09CF 93                  SUB     E               ; Compare with E
0970+  09D0 C9                  RET                     ; Return status
0971+  09D1             
0972+  09D1 7E          CHKSYN: LD      A,(HL)          ; Check syntax of character
0973+  09D2 E3                  EX      (SP),HL         ; Address of test byte
0974+  09D3 BE                  CP      (HL)            ; Same as in code string?
0975+  09D4 23                  INC     HL              ; Return address
0976+  09D5 E3                  EX      (SP),HL         ; Put it back
0977+  09D6 CA 5B 0B            JP      Z,GETCHR        ; Yes - Get next character
0978+  09D9 C3 03 07            JP      SNERR           ; Different - ?SN Error
0979+  09DC             
0980+  09DC F5          OUTC:   PUSH    AF              ; Save character
0981+  09DD 3A F5 30            LD      A,(CTLOFG)      ; Get control "O" flag
0982+  09E0 B7                  OR      A               ; Is it set?
0983+  09E1 C2 D6 14            JP      NZ,POPAF        ; Yes - don't output
0984+  09E4 F1                  POP     AF              ; Restore character
0985+  09E5 C5                  PUSH    BC              ; Save buffer length
0986+  09E6 F5                  PUSH    AF              ; Save character
0987+  09E7 FE 20               CP      ' '             ; Is it a control code?
0988+  09E9 DA 00 0A            JP      C,DINPOS        ; Yes - Don't INC POS(X)
0989+  09EC 3A F2 30            LD      A,(LWIDTH)      ; Get line width
0990+  09EF 47                  LD      B,A             ; To B
0991+  09F0 3A 5B 31            LD      A,(CURPOS)      ; Get cursor position
0992+  09F3 04                  INC     B               ; Width 255?
0993+  09F4 CA FC 09            JP      Z,INCLEN        ; Yes - No width limit
0994+  09F7 05                  DEC     B               ; Restore width
0995+  09F8 B8                  CP      B               ; At end of line?
0996+  09F9 CC 03 0E            CALL    Z,PRNTCRLF      ; Yes - output CRLF
0997+  09FC 3C          INCLEN: INC     A               ; Move on one character
0998+  09FD 32 5B 31            LD      (CURPOS),A      ; Save new position
0999+  0A00 F1          DINPOS: POP     AF              ; Restore character
1000+  0A01 C1                  POP     BC              ; Restore buffer length
1001+  0A02 CD 9C 1F            CALL    MONOUT          ; Send it
1002+  0A05 C9                  RET
1003+  0A06             
1004+  0A06 CD 60 1E    CLOTST: CALL    GETINP          ; Get input character
1005+  0A09 E6 7F               AND     01111111B       ; Strip bit 7
1006+  0A0B FE 0F               CP      CTRLO           ; Is it control "O"?
1007+  0A0D C0                  RET     NZ              ; No don't flip flag
1008+  0A0E 3A F5 30            LD      A,(CTLOFG)      ; Get flag
1009+  0A11 2F                  CPL                     ; Flip it
1010+  0A12 32 F5 30            LD      (CTLOFG),A      ; Put it back
1011+  0A15 AF                  XOR     A               ; Null character
1012+  0A16 C9                  RET
1013+  0A17             
1014+  0A17 CD 27 0C    LIST:   CALL    ATOH            ; ASCII number to DE
1015+  0A1A C0                  RET     NZ              ; Return if anything extra
1016+  0A1B C1                  POP     BC              ; Rubbish - Not needed
1017+  0A1C CD EF 07            CALL    SRCHLN          ; Search for line number in DE
1018+  0A1F C5                  PUSH    BC              ; Save address of line
1019+  0A20 CD 6D 0A            CALL    SETLIN          ; Set up lines counter
1020+  0A23 E1          LISTLP: POP     HL              ; Restore address of line
1021+  0A24 4E                  LD      C,(HL)          ; Get LSB of next line
1022+  0A25 23                  INC     HL
1023+  0A26 46                  LD      B,(HL)          ; Get MSB of next line
1024+  0A27 23                  INC     HL
1025+  0A28 78                  LD      A,B             ; BC = 0 (End of program)?
1026+  0A29 B1                  OR      C
1027+  0A2A CA 4E 07            JP      Z,PRNTOK        ; Yes - Go to command mode
1028+  0A2D CD 76 0A            CALL    COUNT           ; Count lines
1029+  0A30 CD 86 0B            CALL    TSTBRK          ; Test for break key
1030+  0A33 C5                  PUSH    BC              ; Save address of next line
1031+  0A34 CD 03 0E            CALL    PRNTCRLF        ; Output CRLF
1032+  0A37 5E                  LD      E,(HL)          ; Get LSB of line number
1033+  0A38 23                  INC     HL
1034+  0A39 56                  LD      D,(HL)          ; Get MSB of line number
1035+  0A3A 23                  INC     HL
1036+  0A3B E5                  PUSH    HL              ; Save address of line start
1037+  0A3C EB                  EX      DE,HL           ; Line number to HL
1038+  0A3D CD 44 1B            CALL    PRNTHL          ; Output line number in decimal
1039+  0A40 3E 20               LD      A,' '           ; Space after line number
1040+  0A42 E1                  POP     HL              ; Restore start of line address
1041+  0A43 CD DC 09    LSTLP2: CALL    OUTC            ; Output character in A
1042+  0A46 7E          LSTLP3: LD      A,(HL)          ; Get next byte in line
1043+  0A47 B7                  OR      A               ; End of line?
1044+  0A48 23                  INC     HL              ; To next byte in line
1045+  0A49 CA 23 0A            JP      Z,LISTLP        ; Yes - get next line
1046+  0A4C F2 43 0A            JP      P,LSTLP2        ; No token - output it
1047+  0A4F D6 7F               SUB     ZEND-1          ; Find and output word
1048+  0A51 4F                  LD      C,A             ; Token offset+1 to C
1049+  0A52 11 8C 04            LD      DE,WORDS        ; Reserved word list
1050+  0A55 1A          FNDTOK: LD      A,(DE)          ; Get character in list
1051+  0A56 13                  INC     DE              ; Move on to next
1052+  0A57 B7                  OR      A               ; Is it start of word?
1053+  0A58 F2 55 0A            JP      P,FNDTOK        ; No - Keep looking for word
1054+  0A5B 0D                  DEC     C               ; Count words
1055+  0A5C C2 55 0A            JP      NZ,FNDTOK       ; Not there - keep looking
1056+  0A5F E6 7F       OUTWRD: AND     01111111B       ; Strip bit 7
1057+  0A61 CD DC 09            CALL    OUTC            ; Output first character
1058+  0A64 1A                  LD      A,(DE)          ; Get next character
1059+  0A65 13                  INC     DE              ; Move on to next
1060+  0A66 B7                  OR      A               ; Is it end of word?
1061+  0A67 F2 5F 0A            JP      P,OUTWRD        ; No - output the rest
1062+  0A6A C3 46 0A            JP      LSTLP3          ; Next byte in line
1063+  0A6D             
1064+  0A6D E5          SETLIN: PUSH    HL              ; Set up LINES counter
1065+  0A6E 2A F8 30            LD      HL,(LINESN)     ; Get LINES number
1066+  0A71 22 F6 30            LD      (LINESC),HL     ; Save in LINES counter
1067+  0A74 E1                  POP     HL
1068+  0A75 C9                  RET
1069+  0A76             
1070+  0A76 E5          COUNT:  PUSH    HL              ; Save code string address
1071+  0A77 D5                  PUSH    DE
1072+  0A78 2A F6 30            LD      HL,(LINESC)     ; Get LINES counter
1073+  0A7B 11 FF FF            LD      DE,-1
1074+  0A7E ED 5A               ADC     HL,DE           ; Decrement
1075+  0A80 22 F6 30            LD      (LINESC),HL     ; Put it back
1076+  0A83 D1                  POP     DE
1077+  0A84 E1                  POP     HL              ; Restore code string address
1078+  0A85 F0                  RET     P               ; Return if more lines to go
1079+  0A86 E5                  PUSH    HL              ; Save code string address
1080+  0A87 2A F8 30            LD      HL,(LINESN)     ; Get LINES number
1081+  0A8A 22 F6 30            LD      (LINESC),HL     ; Reset LINES counter
1082+  0A8D CD 60 1E            CALL    GETINP          ; Get input character
1083+  0A90 FE 03               CP      CTRLC           ; Is it control "C"?
1084+  0A92 CA 99 0A            JP      Z,RSLNBK        ; Yes - Reset LINES and break
1085+  0A95 E1                  POP     HL              ; Restore code string address
1086+  0A96 C3 76 0A            JP      COUNT           ; Keep on counting
1087+  0A99             
1088+  0A99 2A F8 30    RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1089+  0A9C 22 F6 30            LD      (LINESC),HL     ; Reset LINES counter
1090+  0A9F C3 FD 03            JP      BRKRET          ; Go and output "Break"
1091+  0AA2             
1092+  0AA2 3E 64       FOR:    LD      A,64H           ; Flag "FOR" assignment
1093+  0AA4 32 7B 31            LD      (FORFLG),A      ; Save "FOR" flag
1094+  0AA7 CD 09 0D            CALL    LET             ; Set up initial index
1095+  0AAA C1                  POP     BC              ; Drop RETurn address
1096+  0AAB E5                  PUSH    HL              ; Save code string address
1097+  0AAC CD F2 0C            CALL    DATA            ; Get next statement address
1098+  0AAF 22 77 31            LD      (LOOPST),HL     ; Save it for start of loop
1099+  0AB2 21 02 00            LD      HL,2            ; Offset for "FOR" block
1100+  0AB5 39                  ADD     HL,SP           ; Point to it
1101+  0AB6 CD B0 06    FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1102+  0AB9 D1                  POP     DE              ; Get code string address
1103+  0ABA C2 D2 0A            JP      NZ,FORFND       ; No nesting found
1104+  0ABD 09                  ADD     HL,BC           ; Move into "FOR" block
1105+  0ABE D5                  PUSH    DE              ; Save code string address
1106+  0ABF 2B                  DEC     HL
1107+  0AC0 56                  LD      D,(HL)          ; Get MSB of loop statement
1108+  0AC1 2B                  DEC     HL
1109+  0AC2 5E                  LD      E,(HL)          ; Get LSB of loop statement
1110+  0AC3 23                  INC     HL
1111+  0AC4 23                  INC     HL
1112+  0AC5 E5                  PUSH    HL              ; Save block address
1113+  0AC6 2A 77 31            LD      HL,(LOOPST)     ; Get address of loop statement
1114+  0AC9 CD CB 09            CALL    CPDEHL          ; Compare the FOR loops
1115+  0ACC E1                  POP     HL              ; Restore block address
1116+  0ACD C2 B6 0A            JP      NZ,FORSLP       ; Different FORs - Find another
1117+  0AD0 D1                  POP     DE              ; Restore code string address
1118+  0AD1 F9                  LD      SP,HL           ; Remove all nested loops
1119+  0AD2             
1120+  0AD2 EB          FORFND: EX      DE,HL           ; Code string address to HL
1121+  0AD3 0E 08               LD      C,8
1122+  0AD5 CD E0 06            CALL    CHKSTK          ; Check for 8 levels of stack
1123+  0AD8 E5                  PUSH    HL              ; Save code string address
1124+  0AD9 2A 77 31            LD      HL,(LOOPST)     ; Get first statement of loop
1125+  0ADC E3                  EX      (SP),HL         ; Save and restore code string
1126+  0ADD E5                  PUSH    HL              ; Re-save code string address
1127+  0ADE 2A 0C 31            LD      HL,(LINEAT)     ; Get current line number
1128+  0AE1 E3                  EX      (SP),HL         ; Save and restore code string
1129+  0AE2 CD CB 0F            CALL    TSTNUM          ; Make sure it's a number
1130+  0AE5 CD D1 09            CALL    CHKSYN          ; Make sure "TO" is next
1131+  0AE8 A6                  .BYTE   ZTO          ; "TO" token
1132+  0AE9 CD C8 0F            CALL    GETNUM          ; Get "TO" expression value
1133+  0AEC E5                  PUSH    HL              ; Save code string address
1134+  0AED CD F6 19            CALL    BCDEFP          ; Move "TO" value to BCDE
1135+  0AF0 E1                  POP     HL              ; Restore code string address
1136+  0AF1 C5                  PUSH    BC              ; Save "TO" value in block
1137+  0AF2 D5                  PUSH    DE
1138+  0AF3 01 00 81            LD      BC,8100H        ; BCDE - 1 (default STEP)
1139+  0AF6 51                  LD      D,C             ; C=0
1140+  0AF7 5A                  LD      E,D             ; D=0
1141+  0AF8 7E                  LD      A,(HL)          ; Get next byte in code string
1142+  0AF9 FE AB               CP      ZSTEP           ; See if "STEP" is stated
1143+  0AFB 3E 01               LD      A,1             ; Sign of step = 1
1144+  0AFD C2 0E 0B            JP      NZ,SAVSTP       ; No STEP given - Default to 1
1145+  0B00 CD 5B 0B            CALL    GETCHR          ; Jump over "STEP" token
1146+  0B03 CD C8 0F            CALL    GETNUM          ; Get step value
1147+  0B06 E5                  PUSH    HL              ; Save code string address
1148+  0B07 CD F6 19            CALL    BCDEFP          ; Move STEP to BCDE
1149+  0B0A CD AA 19            CALL    TSTSGN          ; Test sign of FPREG
1150+  0B0D E1                  POP     HL              ; Restore code string address
1151+  0B0E C5          SAVSTP: PUSH    BC              ; Save the STEP value in block
1152+  0B0F D5                  PUSH    DE
1153+  0B10 F5                  PUSH    AF              ; Save sign of STEP
1154+  0B11 33                  INC     SP              ; Don't save flags
1155+  0B12 E5                  PUSH    HL              ; Save code string address
1156+  0B13 2A 7E 31            LD      HL,(BRKLIN)     ; Get address of index variable
1157+  0B16 E3                  EX      (SP),HL         ; Save and restore code string
1158+  0B17 06 81       PUTFID: LD      B,ZFOR          ; "FOR" block marker
1159+  0B19 C5                  PUSH    BC              ; Save it
1160+  0B1A 33                  INC     SP              ; Don't save C
1161+  0B1B             
1162+  0B1B CD 86 0B    RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1163+  0B1E 22 7E 31            LD      (BRKLIN),HL     ; Save code address for break
1164+  0B21 7E                  LD      A,(HL)          ; Get next byte in code string
1165+  0B22 FE 3A               CP      ':'             ; Multi statement line?
1166+  0B24 CA 3B 0B            JP      Z,EXCUTE        ; Yes - Execute it
1167+  0B27 B7                  OR      A               ; End of line?
1168+  0B28 C2 03 07            JP      NZ,SNERR        ; No - Syntax error
1169+  0B2B 23                  INC     HL              ; Point to address of next line
1170+  0B2C 7E                  LD      A,(HL)          ; Get LSB of line pointer
1171+  0B2D 23                  INC     HL
1172+  0B2E B6                  OR      (HL)            ; Is it zero (End of prog)?
1173+  0B2F CA AD 0B            JP      Z,ENDPRG        ; Yes - Terminate execution
1174+  0B32 23                  INC     HL              ; Point to line number
1175+  0B33 5E                  LD      E,(HL)          ; Get LSB of line number
1176+  0B34 23                  INC     HL
1177+  0B35 56                  LD      D,(HL)          ; Get MSB of line number
1178+  0B36 EB                  EX      DE,HL           ; Line number to HL
1179+  0B37 22 0C 31            LD      (LINEAT),HL     ; Save as current line number
1180+  0B3A EB                  EX      DE,HL           ; Line number back to DE
1181+  0B3B CD 5B 0B    EXCUTE: CALL    GETCHR          ; Get key word
1182+  0B3E 11 1B 0B            LD      DE,RUNCNT       ; Where to RETurn to
1183+  0B41 D5                  PUSH    DE              ; Save for RETurn
1184+  0B42 C8          IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1185+  0B43 D6 80       ONJMP:  SUB     ZEND            ; Is it a token?
1186+  0B45 DA 09 0D            JP      C,LET           ; No - try to assign it
1187+  0B48 FE 25               CP      ZNEW+1-ZEND     ; END to NEW ?
1188+  0B4A D2 03 07            JP      NC,SNERR        ; Not a key word - ?SN Error
1189+  0B4D 07                  RLCA                    ; Double it
1190+  0B4E 4F                  LD      C,A             ; BC = Offset into table
1191+  0B4F 06 00               LD      B,0
1192+  0B51 EB                  EX      DE,HL           ; Save code string address
1193+  0B52 21 AB 05            LD      HL,WORDTB       ; Keyword address table
1194+  0B55 09                  ADD     HL,BC           ; Point to routine address
1195+  0B56 4E                  LD      C,(HL)          ; Get LSB of routine address
1196+  0B57 23                  INC     HL
1197+  0B58 46                  LD      B,(HL)          ; Get MSB of routine address
1198+  0B59 C5                  PUSH    BC              ; Save routine address
1199+  0B5A EB                  EX      DE,HL           ; Restore code string address
1200+  0B5B             
1201+  0B5B 23          GETCHR: INC     HL              ; Point to next character
1202+  0B5C 7E                  LD      A,(HL)          ; Get next code string byte
1203+  0B5D FE 3A               CP      ':'             ; Z if ':'
1204+  0B5F D0                  RET     NC              ; NC if > "9"
1205+  0B60 FE 20               CP      ' '
1206+  0B62 CA 5B 0B            JP      Z,GETCHR        ; Skip over spaces
1207+  0B65 FE 30               CP      '0'
1208+  0B67 3F                  CCF                     ; NC if < '0'
1209+  0B68 3C                  INC     A               ; Test for zero - Leave carry
1210+  0B69 3D                  DEC     A               ; Z if Null
1211+  0B6A C9                  RET
1212+  0B6B             
1213+  0B6B EB          RESTOR: EX      DE,HL           ; Save code string address
1214+  0B6C 2A 0E 31            LD      HL,(BASTXT)     ; Point to start of program
1215+  0B6F CA 80 0B            JP      Z,RESTNL        ; Just RESTORE - reset pointer
1216+  0B72 EB                  EX      DE,HL           ; Restore code string address
1217+  0B73 CD 27 0C            CALL    ATOH            ; Get line number to DE
1218+  0B76 E5                  PUSH    HL              ; Save code string address
1219+  0B77 CD EF 07            CALL    SRCHLN          ; Search for line number in DE
1220+  0B7A 60                  LD      H,B             ; HL = Address of line
1221+  0B7B 69                  LD      L,C
1222+  0B7C D1                  POP     DE              ; Restore code string address
1223+  0B7D D2 C8 0C            JP      NC,ULERR        ; ?UL Error if not found
1224+  0B80 2B          RESTNL: DEC     HL              ; Byte before DATA statement
1225+  0B81 22 8C 31    UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1226+  0B84 EB                  EX      DE,HL           ; Restore code string address
1227+  0B85 C9                  RET
1228+  0B86             
1229+  0B86             
1230+  0B86 DF          TSTBRK: RST     18H             ; Check input status
1231+  0B87 C8                  RET     Z               ; No key, go back
1232+  0B88 D7                  RST     10H             ; Get the key into A
1233+  0B89 FE 1B               CP      ESC             ; Escape key?
1234+  0B8B 28 11               JR      Z,BRK           ; Yes, break
1235+  0B8D FE 03               CP      CTRLC           ; <Ctrl-C>
1236+  0B8F 28 0D               JR      Z,BRK           ; Yes, break
1237+  0B91 FE 13               CP      CTRLS           ; Stop scrolling?
1238+  0B93 C0                  RET     NZ              ; Other key, ignore
1239+  0B94             
1240+  0B94             
1241+  0B94 D7          STALL:  RST     10H             ; Wait for key
1242+  0B95 FE 11               CP      CTRLQ           ; Resume scrolling?
1243+  0B97 C8                  RET      Z              ; Release the chokehold
1244+  0B98 FE 03               CP      CTRLC           ; Second break?
1245+  0B9A 28 07               JR      Z,STOP          ; Break during hold exits prog
1246+  0B9C 18 F6               JR      STALL           ; Loop until <Ctrl-Q> or <brk>
1247+  0B9E             
1248+  0B9E 3E FF       BRK     LD      A,$FF           ; Set BRKFLG
1249+  0BA0 32 FD 30            LD      (BRKFLG),A      ; Store it
1250+  0BA3             
1251+  0BA3             
1252+  0BA3 C0          STOP:   RET     NZ              ; Exit if anything else
1253+  0BA4 F6                  .BYTE   0F6H            ; Flag "STOP"
1254+  0BA5 C0          PEND:   RET     NZ              ; Exit if anything else
1255+  0BA6 22 7E 31            LD      (BRKLIN),HL     ; Save point of break
1256+  0BA9 21                  .BYTE   21H             ; Skip "OR 11111111B"
1257+  0BAA F6 FF       INPBRK: OR      11111111B       ; Flag "Break" wanted
1258+  0BAC C1                  POP     BC              ; Return not needed and more
1259+  0BAD 2A 0C 31    ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1260+  0BB0 F5                  PUSH    AF              ; Save STOP / END status
1261+  0BB1 7D                  LD      A,L             ; Is it direct break?
1262+  0BB2 A4                  AND     H
1263+  0BB3 3C                  INC     A               ; Line is -1 if direct break
1264+  0BB4 CA C0 0B            JP      Z,NOLIN         ; Yes - No line number
1265+  0BB7 22 82 31            LD      (ERRLIN),HL     ; Save line of break
1266+  0BBA 2A 7E 31            LD      HL,(BRKLIN)     ; Get point of break
1267+  0BBD 22 84 31            LD      (CONTAD),HL     ; Save point to CONTinue
1268+  0BC0 AF          NOLIN:  XOR     A
1269+  0BC1 32 F5 30            LD      (CTLOFG),A      ; Enable output
1270+  0BC4 CD F6 0D            CALL    STTLIN          ; Start a new line
1271+  0BC7 F1                  POP     AF              ; Restore STOP / END status
1272+  0BC8 21 A6 06            LD      HL,BRKMSG       ; "Break" message
1273+  0BCB C2 37 07            JP      NZ,ERRIN        ; "in line" wanted?
1274+  0BCE C3 4E 07            JP      PRNTOK          ; Go to command mode
1275+  0BD1             
1276+  0BD1 2A 84 31    CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1277+  0BD4 7C                  LD      A,H             ; Is it zero?
1278+  0BD5 B5                  OR      L
1279+  0BD6 1E 20               LD      E,CN            ; ?CN Error
1280+  0BD8 CA 17 07            JP      Z,ERROR         ; Yes - output "?CN Error"
1281+  0BDB EB                  EX      DE,HL           ; Save code string address
1282+  0BDC 2A 82 31            LD      HL,(ERRLIN)     ; Get line of last break
1283+  0BDF 22 0C 31            LD      (LINEAT),HL     ; Set up current line number
1284+  0BE2 EB                  EX      DE,HL           ; Restore code string address
1285+  0BE3 C9                  RET                     ; CONTinue where left off
1286+  0BE4             
1287+  0BE4 CD 29 17    NULL:   CALL    GETINT          ; Get integer 0-255
1288+  0BE7 C0                  RET     NZ              ; Return if bad value
1289+  0BE8 32 F1 30            LD      (NULLS),A       ; Set nulls number
1290+  0BEB C9                  RET
1291+  0BEC             
1292+  0BEC             
1293+  0BEC E5          ACCSUM: PUSH    HL              ; Save address in array
1294+  0BED 2A FA 30            LD      HL,(CHKSUM)     ; Get check sum
1295+  0BF0 06 00               LD      B,0             ; BC - Value of byte
1296+  0BF2 4F                  LD      C,A
1297+  0BF3 09                  ADD     HL,BC           ; Add byte to check sum
1298+  0BF4 22 FA 30            LD      (CHKSUM),HL     ; Re-save check sum
1299+  0BF7 E1                  POP     HL              ; Restore address in array
1300+  0BF8 C9                  RET
1301+  0BF9             
1302+  0BF9 7E          CHKLTR: LD      A,(HL)          ; Get byte
1303+  0BFA FE 41               CP      'A'             ; < 'a' ?
1304+  0BFC D8                  RET     C               ; Carry set if not letter
1305+  0BFD FE 5B               CP      'Z'+1           ; > 'z' ?
1306+  0BFF 3F                  CCF
1307+  0C00 C9                  RET                     ; Carry set if not letter
1308+  0C01             
1309+  0C01 CD 5B 0B    FPSINT: CALL    GETCHR          ; Get next character
1310+  0C04 CD C8 0F    POSINT: CALL    GETNUM          ; Get integer 0 to 32767
1311+  0C07 CD AA 19    DEPINT: CALL    TSTSGN          ; Test sign of FPREG
1312+  0C0A FA 22 0C            JP      M,FCERR         ; Negative - ?FC Error
1313+  0C0D 3A 97 31    DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
1314+  0C10 FE 90               CP      80H+16          ; Exponent in range (16 bits)?
1315+  0C12 DA 52 1A            JP      C,FPINT         ; Yes - convert it
1316+  0C15 01 80 90            LD      BC,9080H        ; BCDE = -32768
1317+  0C18 11 00 00            LD      DE,0000
1318+  0C1B E5                  PUSH    HL              ; Save code string address
1319+  0C1C CD 25 1A            CALL    CMPNUM          ; Compare FPREG with BCDE
1320+  0C1F E1                  POP     HL              ; Restore code string address
1321+  0C20 51                  LD      D,C             ; MSB to D
1322+  0C21 C8                  RET     Z               ; Return if in range
1323+  0C22 1E 08       FCERR:  LD      E,FC            ; ?FC Error
1324+  0C24 C3 17 07            JP      ERROR           ; Output error-
1325+  0C27             
1326+  0C27 2B          ATOH:   DEC     HL              ; ASCII number to DE binary
1327+  0C28 11 00 00    GETLN:  LD      DE,0            ; Get number to DE
1328+  0C2B CD 5B 0B    GTLNLP: CALL    GETCHR          ; Get next character
1329+  0C2E D0                  RET     NC              ; Exit if not a digit
1330+  0C2F E5                  PUSH    HL              ; Save code string address
1331+  0C30 F5                  PUSH    AF              ; Save digit
1332+  0C31 21 98 19            LD      HL,65529/10     ; Largest number 65529
1333+  0C34 CD CB 09            CALL    CPDEHL          ; Number in range?
1334+  0C37 DA 03 07            JP      C,SNERR         ; No - ?SN Error
1335+  0C3A 62                  LD      H,D             ; HL = Number
1336+  0C3B 6B                  LD      L,E
1337+  0C3C 19                  ADD     HL,DE           ; Times 2
1338+  0C3D 29                  ADD     HL,HL           ; Times 4
1339+  0C3E 19                  ADD     HL,DE           ; Times 5
1340+  0C3F 29                  ADD     HL,HL           ; Times 10
1341+  0C40 F1                  POP     AF              ; Restore digit
1342+  0C41 D6 30               SUB     '0'             ; Make it 0 to 9
1343+  0C43 5F                  LD      E,A             ; DE = Value of digit
1344+  0C44 16 00               LD      D,0
1345+  0C46 19                  ADD     HL,DE           ; Add to number
1346+  0C47 EB                  EX      DE,HL           ; Number to DE
1347+  0C48 E1                  POP     HL              ; Restore code string address
1348+  0C49 C3 2B 0C            JP      GTLNLP          ; Go to next character
1349+  0C4C             
1350+  0C4C CA 1F 08    CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
1351+  0C4F CD 04 0C            CALL    POSINT          ; Get integer 0 to 32767 to DE
1352+  0C52 2B                  DEC     HL              ; Cancel increment
1353+  0C53 CD 5B 0B            CALL    GETCHR          ; Get next character
1354+  0C56 E5                  PUSH    HL              ; Save code string address
1355+  0C57 2A 5F 31            LD      HL,(LSTRAM)     ; Get end of RAM
1356+  0C5A CA 6F 0C            JP      Z,STORED        ; No value given - Use stored
1357+  0C5D E1                  POP     HL              ; Restore code string address
1358+  0C5E CD D1 09            CALL    CHKSYN          ; Check for comma
1359+  0C61 2C                  .BYTE      ','
1360+  0C62 D5                  PUSH    DE              ; Save number
1361+  0C63 CD 04 0C            CALL    POSINT          ; Get integer 0 to 32767
1362+  0C66 2B                  DEC     HL              ; Cancel increment
1363+  0C67 CD 5B 0B            CALL    GETCHR          ; Get next character
1364+  0C6A C2 03 07            JP      NZ,SNERR        ; ?SN Error if more on line
1365+  0C6D E3                  EX      (SP),HL         ; Save code string address
1366+  0C6E EB                  EX      DE,HL           ; Number to DE
1367+  0C6F 7D          STORED: LD      A,L             ; Get LSB of new RAM top
1368+  0C70 93                  SUB     E               ; Subtract LSB of string space
1369+  0C71 5F                  LD      E,A             ; Save LSB
1370+  0C72 7C                  LD      A,H             ; Get MSB of new RAM top
1371+  0C73 9A                  SBC     A,D             ; Subtract MSB of string space
1372+  0C74 57                  LD      D,A             ; Save MSB
1373+  0C75 DA F8 06            JP      C,OMERR         ; ?OM Error if not enough mem
1374+  0C78 E5                  PUSH    HL              ; Save RAM top
1375+  0C79 2A 86 31            LD      HL,(PROGND)     ; Get program end
1376+  0C7C 01 28 00            LD      BC,40           ; 40 Bytes minimum working RAM
1377+  0C7F 09                  ADD     HL,BC           ; Get lowest address
1378+  0C80 CD CB 09            CALL    CPDEHL          ; Enough memory?
1379+  0C83 D2 F8 06            JP      NC,OMERR        ; No - ?OM Error
1380+  0C86 EB                  EX      DE,HL           ; RAM top to HL
1381+  0C87 22 0A 31            LD      (STRSPC),HL     ; Set new string space
1382+  0C8A E1                  POP     HL              ; End of memory to use
1383+  0C8B 22 5F 31            LD      (LSTRAM),HL     ; Set new top of RAM
1384+  0C8E E1                  POP     HL              ; Restore code string address
1385+  0C8F C3 1F 08            JP      INTVAR          ; Initialise variables
1386+  0C92             
1387+  0C92 CA 1B 08    RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
1388+  0C95 CD 1F 08            CALL    INTVAR          ; Initialise variables
1389+  0C98 01 1B 0B            LD      BC,RUNCNT       ; Execution driver loop
1390+  0C9B C3 AE 0C            JP      RUNLIN          ; RUN from line number
1391+  0C9E             
1392+  0C9E 0E 03       GOSUB:  LD      C,3             ; 3 Levels of stack needed
1393+  0CA0 CD E0 06            CALL    CHKSTK          ; Check for 3 levels of stack
1394+  0CA3 C1                  POP     BC              ; Get return address
1395+  0CA4 E5                  PUSH    HL              ; Save code string for RETURN
1396+  0CA5 E5                  PUSH    HL              ; And for GOSUB routine
1397+  0CA6 2A 0C 31            LD      HL,(LINEAT)     ; Get current line
1398+  0CA9 E3                  EX      (SP),HL         ; Into stack - Code string out
1399+  0CAA 3E 8C               LD      A,ZGOSUB        ; "GOSUB" token
1400+  0CAC F5                  PUSH    AF              ; Save token
1401+  0CAD 33                  INC     SP              ; Don't save flags
1402+  0CAE             
1403+  0CAE C5          RUNLIN: PUSH    BC              ; Save return address
1404+  0CAF CD 27 0C    GOTO:   CALL    ATOH            ; ASCII number to DE binary
1405+  0CB2 CD F4 0C            CALL    REM             ; Get end of line
1406+  0CB5 E5                  PUSH    HL              ; Save end of line
1407+  0CB6 2A 0C 31            LD      HL,(LINEAT)     ; Get current line
1408+  0CB9 CD CB 09            CALL    CPDEHL          ; Line after current?
1409+  0CBC E1                  POP     HL              ; Restore end of line
1410+  0CBD 23                  INC     HL              ; Start of next line
1411+  0CBE DC F2 07            CALL    C,SRCHLP        ; Line is after current line
1412+  0CC1 D4 EF 07            CALL    NC,SRCHLN       ; Line is before current line
1413+  0CC4 60                  LD      H,B             ; Set up code string address
1414+  0CC5 69                  LD      L,C
1415+  0CC6 2B                  DEC     HL              ; Incremented after
1416+  0CC7 D8                  RET     C               ; Line found
1417+  0CC8 1E 0E       ULERR:  LD      E,UL            ; ?UL Error
1418+  0CCA C3 17 07            JP      ERROR           ; Output error message
1419+  0CCD             
1420+  0CCD C0          RETURN: RET     NZ              ; Return if not just RETURN
1421+  0CCE 16 FF               LD      D,-1            ; Flag "GOSUB" search
1422+  0CD0 CD AC 06            CALL    BAKSTK          ; Look "GOSUB" block
1423+  0CD3 F9                  LD      SP,HL           ; Kill all FORs in subroutine
1424+  0CD4 FE 8C               CP      ZGOSUB          ; Test for "GOSUB" token
1425+  0CD6 1E 04               LD      E,RG            ; ?RG Error
1426+  0CD8 C2 17 07            JP      NZ,ERROR        ; Error if no "GOSUB" found
1427+  0CDB E1                  POP     HL              ; Get RETURN line number
1428+  0CDC 22 0C 31            LD      (LINEAT),HL     ; Save as current
1429+  0CDF 23                  INC     HL              ; Was it from direct statement?
1430+  0CE0 7C                  LD      A,H
1431+  0CE1 B5                  OR      L               ; Return to line
1432+  0CE2 C2 EC 0C            JP      NZ,RETLIN       ; No - Return to line
1433+  0CE5 3A 7C 31            LD      A,(LSTBIN)      ; Any INPUT in subroutine?
1434+  0CE8 B7                  OR      A               ; If so buffer is corrupted
1435+  0CE9 C2 4D 07            JP      NZ,POPNOK       ; Yes - Go to command mode
1436+  0CEC 21 1B 0B    RETLIN: LD      HL,RUNCNT       ; Execution driver loop
1437+  0CEF E3                  EX      (SP),HL         ; Into stack - Code string out
1438+  0CF0 3E                  .BYTE      3EH             ; Skip "POP HL"
1439+  0CF1 E1          NXTDTA: POP     HL              ; Restore code string address
1440+  0CF2             
1441+  0CF2 01 3A       DATA:   .BYTE      01H,3AH         ; ':' End of statement
1442+  0CF4 0E 00       REM:    LD      C,0             ; 00  End of statement
1443+  0CF6 06 00               LD      B,0
1444+  0CF8 79          NXTSTL: LD      A,C             ; Statement and byte
1445+  0CF9 48                  LD      C,B
1446+  0CFA 47                  LD      B,A             ; Statement end byte
1447+  0CFB 7E          NXTSTT: LD      A,(HL)          ; Get byte
1448+  0CFC B7                  OR      A               ; End of line?
1449+  0CFD C8                  RET     Z               ; Yes - Exit
1450+  0CFE B8                  CP      B               ; End of statement?
1451+  0CFF C8                  RET     Z               ; Yes - Exit
1452+  0D00 23                  INC     HL              ; Next byte
1453+  0D01 FE 22               CP      '"'             ; Literal string?
1454+  0D03 CA F8 0C            JP      Z,NXTSTL        ; Yes - Look for another '"'
1455+  0D06 C3 FB 0C            JP      NXTSTT          ; Keep looking
1456+  0D09             
1457+  0D09 CD BE 11    LET:    CALL    GETVAR          ; Get variable name
1458+  0D0C CD D1 09            CALL    CHKSYN          ; Make sure "=" follows
1459+  0D0F B4                  .BYTE      ZEQUAL          ; "=" token
1460+  0D10 D5                  PUSH    DE              ; Save address of variable
1461+  0D11 3A 5D 31            LD      A,(TYPE)        ; Get data type
1462+  0D14 F5                  PUSH    AF              ; Save type
1463+  0D15 CD DA 0F            CALL    EVAL            ; Evaluate expression
1464+  0D18 F1                  POP     AF              ; Restore type
1465+  0D19 E3                  EX      (SP),HL         ; Save code - Get var addr
1466+  0D1A 22 7E 31            LD      (BRKLIN),HL     ; Save address of variable
1467+  0D1D 1F                  RRA                     ; Adjust type
1468+  0D1E CD CD 0F            CALL    CHKTYP          ; Check types are the same
1469+  0D21 CA 5C 0D            JP      Z,LETNUM        ; Numeric - Move value
1470+  0D24 E5          LETSTR: PUSH    HL              ; Save address of string var
1471+  0D25 2A 94 31            LD      HL,(FPREG)      ; Pointer to string entry
1472+  0D28 E5                  PUSH    HL              ; Save it on stack
1473+  0D29 23                  INC     HL              ; Skip over length
1474+  0D2A 23                  INC     HL
1475+  0D2B 5E                  LD      E,(HL)          ; LSB of string address
1476+  0D2C 23                  INC     HL
1477+  0D2D 56                  LD      D,(HL)          ; MSB of string address
1478+  0D2E 2A 0E 31            LD      HL,(BASTXT)     ; Point to start of program
1479+  0D31 CD CB 09            CALL    CPDEHL          ; Is string before program?
1480+  0D34 D2 4B 0D            JP      NC,CRESTR       ; Yes - Create string entry
1481+  0D37 2A 0A 31            LD      HL,(STRSPC)     ; Point to string space
1482+  0D3A CD CB 09            CALL    CPDEHL          ; Is string literal in program?
1483+  0D3D D1                  POP     DE              ; Restore address of string
1484+  0D3E D2 53 0D            JP      NC,MVSTPT       ; Yes - Set up pointer
1485+  0D41 21 6F 31            LD      HL,TMPSTR       ; Temporary string pool
1486+  0D44 CD CB 09            CALL    CPDEHL          ; Is string in temporary pool?
1487+  0D47 D2 53 0D            JP      NC,MVSTPT       ; No - Set up pointer
1488+  0D4A 3E                  .BYTE   3EH             ; Skip "POP DE"
1489+  0D4B D1          CRESTR: POP     DE              ; Restore address of string
1490+  0D4C CD 02 16            CALL    BAKTMP          ; Back to last tmp-str entry
1491+  0D4F EB                  EX      DE,HL           ; Address of string entry
1492+  0D50 CD 3B 14            CALL    SAVSTR          ; Save string in string area
1493+  0D53 CD 02 16    MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
1494+  0D56 E1                  POP     HL              ; Get string pointer
1495+  0D57 CD 05 1A            CALL    DETHL4          ; Move string pointer to var
1496+  0D5A E1                  POP     HL              ; Restore code string address
1497+  0D5B C9                  RET
1498+  0D5C             
1499+  0D5C E5          LETNUM: PUSH    HL              ; Save address of variable
1500+  0D5D CD 02 1A            CALL    FPTHL           ; Move value to variable
1501+  0D60 D1                  POP     DE              ; Restore address of variable
1502+  0D61 E1                  POP     HL              ; Restore code string address
1503+  0D62 C9                  RET
1504+  0D63             
1505+  0D63 CD 29 17    ON:     CALL    GETINT          ; Get integer 0-255
1506+  0D66 7E                  LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
1507+  0D67 47                  LD      B,A             ; Save in B
1508+  0D68 FE 8C               CP      ZGOSUB          ; "GOSUB" token?
1509+  0D6A CA 72 0D            JP      Z,ONGO          ; Yes - Find line number
1510+  0D6D CD D1 09            CALL    CHKSYN          ; Make sure it's "GOTO"
1511+  0D70 88                  .BYTE   ZGOTO           ; "GOTO" token
1512+  0D71 2B                  DEC     HL              ; Cancel increment
1513+  0D72 4B          ONGO:   LD      C,E             ; Integer of branch value
1514+  0D73 0D          ONGOLP: DEC     C               ; Count branches
1515+  0D74 78                  LD      A,B             ; Get "GOTO" or "GOSUB" token
1516+  0D75 CA 43 0B            JP      Z,ONJMP         ; Go to that line if right one
1517+  0D78 CD 28 0C            CALL    GETLN           ; Get line number to DE
1518+  0D7B FE 2C               CP      ','             ; Another line number?
1519+  0D7D C0                  RET     NZ              ; No - Drop through
1520+  0D7E C3 73 0D            JP      ONGOLP          ; Yes - loop
1521+  0D81             
1522+  0D81 CD DA 0F    IF:     CALL    EVAL            ; Evaluate expression
1523+  0D84 7E                  LD      A,(HL)          ; Get token
1524+  0D85 FE 88               CP      ZGOTO           ; "GOTO" token?
1525+  0D87 CA 8F 0D            JP      Z,IFGO          ; Yes - Get line
1526+  0D8A CD D1 09            CALL    CHKSYN          ; Make sure it's "THEN"
1527+  0D8D A9                  .BYTE      ZTHEN           ; "THEN" token
1528+  0D8E 2B                  DEC     HL              ; Cancel increment
1529+  0D8F CD CB 0F    IFGO:   CALL    TSTNUM          ; Make sure it's numeric
1530+  0D92 CD AA 19            CALL    TSTSGN          ; Test state of expression
1531+  0D95 CA F4 0C            JP      Z,REM           ; False - Drop through
1532+  0D98 CD 5B 0B            CALL    GETCHR          ; Get next character
1533+  0D9B DA AF 0C            JP      C,GOTO          ; Number - GOTO that line
1534+  0D9E C3 42 0B            JP      IFJMP           ; Otherwise do statement
1535+  0DA1             
1536+  0DA1 2B          MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
1537+  0DA2 CD 5B 0B            CALL    GETCHR          ; Get next character
1538+  0DA5 CA 03 0E    PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
1539+  0DA8 C8          PRNTLP: RET     Z               ; End of list - Exit
1540+  0DA9 FE A5               CP      ZTAB            ; "TAB(" token?
1541+  0DAB CA 36 0E            JP      Z,DOTAB         ; Yes - Do TAB routine
1542+  0DAE FE A8               CP      ZSPC            ; "SPC(" token?
1543+  0DB0 CA 36 0E            JP      Z,DOTAB         ; Yes - Do SPC routine
1544+  0DB3 E5                  PUSH    HL              ; Save code string address
1545+  0DB4 FE 2C               CP      ','             ; Comma?
1546+  0DB6 CA 1F 0E            JP      Z,DOCOM         ; Yes - Move to next zone
1547+  0DB9 FE 3B               CP      59 ;";"         ; Semi-colon?
1548+  0DBB CA 59 0E            JP      Z,NEXITM        ; Do semi-colon routine
1549+  0DBE C1                  POP     BC              ; Code string address to BC
1550+  0DBF CD DA 0F            CALL    EVAL            ; Evaluate expression
1551+  0DC2 E5                  PUSH    HL              ; Save code string address
1552+  0DC3 3A 5D 31            LD      A,(TYPE)        ; Get variable type
1553+  0DC6 B7                  OR      A               ; Is it a string variable?
1554+  0DC7 C2 EF 0D            JP      NZ,PRNTST       ; Yes - Output string contents
1555+  0DCA CD 4F 1B            CALL    NUMASC          ; Convert number to text
1556+  0DCD CD 5F 14            CALL    CRTST           ; Create temporary string
1557+  0DD0 36 20               LD      (HL),' '        ; Followed by a space
1558+  0DD2 2A 94 31            LD      HL,(FPREG)      ; Get length of output
1559+  0DD5 34                  INC     (HL)            ; Plus 1 for the space
1560+  0DD6 2A 94 31            LD      HL,(FPREG)      ; < Not needed >
1561+  0DD9 3A F2 30            LD      A,(LWIDTH)      ; Get width of line
1562+  0DDC 47                  LD      B,A             ; To B
1563+  0DDD 04                  INC     B               ; Width 255 (No limit)?
1564+  0DDE CA EB 0D            JP      Z,PRNTNB        ; Yes - Output number string
1565+  0DE1 04                  INC     B               ; Adjust it
1566+  0DE2 3A 5B 31            LD      A,(CURPOS)      ; Get cursor position
1567+  0DE5 86                  ADD     A,(HL)          ; Add length of string
1568+  0DE6 3D                  DEC     A               ; Adjust it
1569+  0DE7 B8                  CP      B               ; Will output fit on this line?
1570+  0DE8 D4 03 0E            CALL    NC,PRNTCRLF     ; No - CRLF first
1571+  0DEB CD A4 14    PRNTNB: CALL    PRS1            ; Output string at (HL)
1572+  0DEE AF                  XOR     A               ; Skip CALL by setting 'z' flag
1573+  0DEF C4 A4 14    PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
1574+  0DF2 E1                  POP     HL              ; Restore code string address
1575+  0DF3 C3 A1 0D            JP      MRPRNT          ; See if more to PRINT
1576+  0DF6             
1577+  0DF6 3A 5B 31    STTLIN: LD      A,(CURPOS)      ; Make sure on new line
1578+  0DF9 B7                  OR      A               ; Already at start?
1579+  0DFA C8                  RET     Z               ; Yes - Do nothing
1580+  0DFB C3 03 0E            JP      PRNTCRLF        ; Start a new line
1581+  0DFE             
1582+  0DFE 36 00       ENDINP: LD      (HL),0          ; Mark end of buffer
1583+  0E00 21 10 31            LD      HL,BUFFER-1     ; Point to buffer
1584+  0E03 3E 0D       PRNTCRLF: LD    A,CR            ; Load a CR
1585+  0E05 CD DC 09            CALL    OUTC            ; Output character
1586+  0E08 3E 0A               LD      A,LF            ; Load a LF
1587+  0E0A CD DC 09            CALL    OUTC            ; Output character
1588+  0E0D AF          DONULL: XOR     A               ; Set to position 0
1589+  0E0E 32 5B 31            LD      (CURPOS),A      ; Store it
1590+  0E11 3A F1 30            LD      A,(NULLS)       ; Get number of nulls
1591+  0E14 3D          NULLP:  DEC     A               ; Count them
1592+  0E15 C8                  RET     Z               ; Return if done
1593+  0E16 F5                  PUSH    AF              ; Save count
1594+  0E17 AF                  XOR     A               ; Load a null
1595+  0E18 CD DC 09            CALL    OUTC            ; Output it
1596+  0E1B F1                  POP     AF              ; Restore count
1597+  0E1C C3 14 0E            JP      NULLP           ; Keep counting
1598+  0E1F             
1599+  0E1F 3A F3 30    DOCOM:  LD      A,(COMMAN)      ; Get comma width
1600+  0E22 47                  LD      B,A             ; Save in B
1601+  0E23 3A 5B 31            LD      A,(CURPOS)      ; Get current position
1602+  0E26 B8                  CP      B               ; Within the limit?
1603+  0E27 D4 03 0E            CALL    NC,PRNTCRLF     ; No - output CRLF
1604+  0E2A D2 59 0E            JP      NC,NEXITM       ; Get next item
1605+  0E2D D6 0E       ZONELP: SUB     14              ; Next zone of 14 characters
1606+  0E2F D2 2D 0E            JP      NC,ZONELP       ; Repeat if more zones
1607+  0E32 2F                  CPL                     ; Number of spaces to output
1608+  0E33 C3 4E 0E            JP      ASPCS           ; Output them
1609+  0E36             
1610+  0E36 F5          DOTAB:  PUSH    AF              ; Save token
1611+  0E37 CD 26 17            CALL    FNDNUM          ; Evaluate expression
1612+  0E3A CD D1 09            CALL    CHKSYN          ; Make sure ")" follows
1613+  0E3D 29                  .BYTE   ")"
1614+  0E3E 2B                  DEC     HL              ; Back space on to ")"
1615+  0E3F F1                  POP     AF              ; Restore token
1616+  0E40 D6 A8               SUB     ZSPC            ; Was it "SPC(" ?
1617+  0E42 E5                  PUSH    HL              ; Save code string address
1618+  0E43 CA 49 0E            JP      Z,DOSPC         ; Yes - Do 'E' spaces
1619+  0E46 3A 5B 31            LD      A,(CURPOS)      ; Get current position
1620+  0E49 2F          DOSPC:  CPL                     ; Number of spaces to print to
1621+  0E4A 83                  ADD     A,E             ; Total number to print
1622+  0E4B D2 59 0E            JP      NC,NEXITM       ; TAB < Current POS(X)
1623+  0E4E 3C          ASPCS:  INC     A               ; Output A spaces
1624+  0E4F 47                  LD      B,A             ; Save number to print
1625+  0E50 3E 20               LD      A,' '           ; Space
1626+  0E52 CD DC 09    SPCLP:  CALL    OUTC            ; Output character in A
1627+  0E55 05                  DEC     B               ; Count them
1628+  0E56 C2 52 0E            JP      NZ,SPCLP        ; Repeat if more
1629+  0E59 E1          NEXITM: POP     HL              ; Restore code string address
1630+  0E5A CD 5B 0B            CALL    GETCHR          ; Get next character
1631+  0E5D C3 A8 0D            JP      PRNTLP          ; More to print
1632+  0E60             
1633+  0E60 3F 52 65 64 REDO:   .BYTE   "?Redo from start",CR,LF,0
1633+  0E64 6F 20 66 72 
1633+  0E68 6F 6D 20 73 
1633+  0E6C 74 61 72 74 
1633+  0E70 0D 0A 00 
1634+  0E73             
1635+  0E73 3A 7D 31    BADINP: LD      A,(READFG)      ; READ or INPUT?
1636+  0E76 B7                  OR      A
1637+  0E77 C2 FD 06            JP      NZ,DATSNR       ; READ - ?SN Error
1638+  0E7A C1                  POP     BC              ; Throw away code string addr
1639+  0E7B 21 60 0E            LD      HL,REDO         ; "Redo from start" message
1640+  0E7E CD A1 14            CALL    PRS             ; Output string
1641+  0E81 C3 4E 08            JP      DOAGN           ; Do last INPUT again
1642+  0E84             
1643+  0E84 CD 0C 14    INPUT:  CALL    IDTEST          ; Test for illegal direct
1644+  0E87 7E                  LD      A,(HL)          ; Get character after "INPUT"
1645+  0E88 FE 22               CP      '"'             ; Is there a prompt string?
1646+  0E8A 3E 00               LD      A,0             ; Clear A and leave flags
1647+  0E8C 32 F5 30            LD      (CTLOFG),A      ; Enable output
1648+  0E8F C2 9E 0E            JP      NZ,NOPMPT       ; No prompt - get input
1649+  0E92 CD 60 14            CALL    QTSTR           ; Get string terminated by '"'
1650+  0E95 CD D1 09            CALL    CHKSYN          ; Check for ';' after prompt
1651+  0E98 3B                  .BYTE   ';'
1652+  0E99 E5                  PUSH    HL              ; Save code string address
1653+  0E9A CD A4 14            CALL    PRS1            ; Output prompt string
1654+  0E9D 3E                  .BYTE   3EH             ; Skip "PUSH HL"
1655+  0E9E E5          NOPMPT: PUSH    HL              ; Save code string address
1656+  0E9F CD 52 08            CALL    PROMPT          ; Get input with "? " prompt
1657+  0EA2 C1                  POP     BC              ; Restore code string address
1658+  0EA3 DA AA 0B            JP      C,INPBRK        ; Break pressed - Exit
1659+  0EA6 23                  INC     HL              ; Next byte
1660+  0EA7 7E                  LD      A,(HL)          ; Get it
1661+  0EA8 B7                  OR      A               ; End of line?
1662+  0EA9 2B                  DEC     HL              ; Back again
1663+  0EAA C5                  PUSH    BC              ; Re-save code string address
1664+  0EAB CA F1 0C            JP      Z,NXTDTA        ; Yes - Find next DATA stmt
1665+  0EAE 36 2C               LD      (HL),','        ; Store comma as separator
1666+  0EB0 C3 B8 0E            JP      NXTITM          ; Get next item
1667+  0EB3             
1668+  0EB3 E5          READ:   PUSH    HL              ; Save code string address
1669+  0EB4 2A 8C 31            LD      HL,(NXTDAT)     ; Next DATA statement
1670+  0EB7 F6                  .BYTE   0F6H            ; Flag "READ"
1671+  0EB8 AF          NXTITM: XOR     A               ; Flag "INPUT"
1672+  0EB9 32 7D 31            LD      (READFG),A      ; Save "READ"/"INPUT" flag
1673+  0EBC E3                  EX      (SP),HL         ; Get code str' , Save pointer
1674+  0EBD C3 C4 0E            JP      GTVLUS          ; Get values
1675+  0EC0             
1676+  0EC0 CD D1 09    NEDMOR: CALL    CHKSYN          ; Check for comma between items
1677+  0EC3 2C                  .BYTE      ','
1678+  0EC4 CD BE 11    GTVLUS: CALL    GETVAR          ; Get variable name
1679+  0EC7 E3                  EX      (SP),HL         ; Save code str" , Get pointer
1680+  0EC8 D5                  PUSH    DE              ; Save variable address
1681+  0EC9 7E                  LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
1682+  0ECA FE 2C               CP      ','             ; Comma?
1683+  0ECC CA EC 0E            JP      Z,ANTVLU        ; Yes - Get another value
1684+  0ECF 3A 7D 31            LD      A,(READFG)      ; Is it READ?
1685+  0ED2 B7                  OR      A
1686+  0ED3 C2 59 0F            JP      NZ,FDTLP        ; Yes - Find next DATA stmt
1687+  0ED6 3E 3F               LD      A,'?'           ; More INPUT needed
1688+  0ED8 CD DC 09            CALL    OUTC            ; Output character
1689+  0EDB CD 52 08            CALL    PROMPT          ; Get INPUT with prompt
1690+  0EDE D1                  POP     DE              ; Variable address
1691+  0EDF C1                  POP     BC              ; Code string address
1692+  0EE0 DA AA 0B            JP      C,INPBRK        ; Break pressed
1693+  0EE3 23                  INC     HL              ; Point to next DATA byte
1694+  0EE4 7E                  LD      A,(HL)          ; Get byte
1695+  0EE5 B7                  OR      A               ; Is it zero (No input) ?
1696+  0EE6 2B                  DEC     HL              ; Back space INPUT pointer
1697+  0EE7 C5                  PUSH    BC              ; Save code string address
1698+  0EE8 CA F1 0C            JP      Z,NXTDTA        ; Find end of buffer
1699+  0EEB D5                  PUSH    DE              ; Save variable address
1700+  0EEC 3A 5D 31    ANTVLU: LD      A,(TYPE)        ; Check data type
1701+  0EEF B7                  OR      A               ; Is it numeric?
1702+  0EF0 CA 16 0F            JP      Z,INPBIN        ; Yes - Convert to binary
1703+  0EF3 CD 5B 0B            CALL    GETCHR          ; Get next character
1704+  0EF6 57                  LD      D,A             ; Save input character
1705+  0EF7 47                  LD      B,A             ; Again
1706+  0EF8 FE 22               CP      '"'             ; Start of literal sting?
1707+  0EFA CA 0A 0F            JP      Z,STRENT        ; Yes - Create string entry
1708+  0EFD 3A 7D 31            LD      A,(READFG)      ; "READ" or "INPUT" ?
1709+  0F00 B7                  OR      A
1710+  0F01 57                  LD      D,A             ; Save 00 if "INPUT"
1711+  0F02 CA 07 0F            JP      Z,ITMSEP        ; "INPUT" - End with 00
1712+  0F05 16 3A               LD      D,':'           ; "DATA" - End with 00 or ':'
1713+  0F07 06 2C       ITMSEP: LD      B,','           ; Item separator
1714+  0F09 2B                  DEC     HL              ; Back space for DTSTR
1715+  0F0A CD 63 14    STRENT: CALL    DTSTR           ; Get string terminated by D
1716+  0F0D EB                  EX      DE,HL           ; String address to DE
1717+  0F0E 21 21 0F            LD      HL,LTSTND       ; Where to go after LETSTR
1718+  0F11 E3                  EX      (SP),HL         ; Save HL , get input pointer
1719+  0F12 D5                  PUSH    DE              ; Save address of string
1720+  0F13 C3 24 0D            JP      LETSTR          ; Assign string to variable
1721+  0F16             
1722+  0F16 CD 5B 0B    INPBIN: CALL    GETCHR          ; Get next character
1723+  0F19 CD B1 1A            CALL    ASCTFP          ; Convert ASCII to FP number
1724+  0F1C E3                  EX      (SP),HL         ; Save input ptr, Get var addr
1725+  0F1D CD 02 1A            CALL    FPTHL           ; Move FPREG to variable
1726+  0F20 E1                  POP     HL              ; Restore input pointer
1727+  0F21 2B          LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
1728+  0F22 CD 5B 0B            CALL    GETCHR          ; Get next character
1729+  0F25 CA 2D 0F            JP      Z,MORDT         ; End of line - More needed?
1730+  0F28 FE 2C               CP      ','             ; Another value?
1731+  0F2A C2 73 0E            JP      NZ,BADINP       ; No - Bad input
1732+  0F2D E3          MORDT:  EX      (SP),HL         ; Get code string address
1733+  0F2E 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
1734+  0F2F CD 5B 0B            CALL    GETCHR          ; Get next character
1735+  0F32 C2 C0 0E            JP      NZ,NEDMOR       ; More needed - Get it
1736+  0F35 D1                  POP     DE              ; Restore DATA pointer
1737+  0F36 3A 7D 31            LD      A,(READFG)      ; "READ" or "INPUT" ?
1738+  0F39 B7                  OR      A
1739+  0F3A EB                  EX      DE,HL           ; DATA pointer to HL
1740+  0F3B C2 81 0B            JP      NZ,UPDATA       ; Update DATA pointer if "READ"
1741+  0F3E D5                  PUSH    DE              ; Save code string address
1742+  0F3F B6                  OR      (HL)            ; More input given?
1743+  0F40 21 48 0F            LD      HL,EXTIG        ; "?Extra ignored" message
1744+  0F43 C4 A1 14            CALL    NZ,PRS          ; Output string if extra given
1745+  0F46 E1                  POP     HL              ; Restore code string address
1746+  0F47 C9                  RET
1747+  0F48             
1748+  0F48 3F 45 78 74 EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
1748+  0F4C 72 61 20 69 
1748+  0F50 67 6E 6F 72 
1748+  0F54 65 64 0D 0A 
1748+  0F58 00 
1749+  0F59             
1750+  0F59 CD F2 0C    FDTLP:  CALL    DATA            ; Get next statement
1751+  0F5C B7                  OR      A               ; End of line?
1752+  0F5D C2 72 0F            JP      NZ,FANDT        ; No - See if DATA statement
1753+  0F60 23                  INC     HL
1754+  0F61 7E                  LD      A,(HL)          ; End of program?
1755+  0F62 23                  INC     HL
1756+  0F63 B6                  OR      (HL)            ; 00 00 Ends program
1757+  0F64 1E 06               LD      E,OD            ; ?OD Error
1758+  0F66 CA 17 07            JP      Z,ERROR         ; Yes - Out of DATA
1759+  0F69 23                  INC     HL
1760+  0F6A 5E                  LD      E,(HL)          ; LSB of line number
1761+  0F6B 23                  INC     HL
1762+  0F6C 56                  LD      D,(HL)          ; MSB of line number
1763+  0F6D EB                  EX      DE,HL
1764+  0F6E 22 79 31            LD      (DATLIN),HL     ; Set line of current DATA item
1765+  0F71 EB                  EX      DE,HL
1766+  0F72 CD 5B 0B    FANDT:  CALL    GETCHR          ; Get next character
1767+  0F75 FE 83               CP      ZDATA           ; "DATA" token
1768+  0F77 C2 59 0F            JP      NZ,FDTLP        ; No "DATA" - Keep looking
1769+  0F7A C3 EC 0E            JP      ANTVLU          ; Found - Convert input
1770+  0F7D             
1771+  0F7D 11 00 00    NEXT:   LD      DE,0            ; In case no index given
1772+  0F80 C4 BE 11    NEXT1:  CALL    NZ,GETVAR       ; Get index address
1773+  0F83 22 7E 31            LD      (BRKLIN),HL     ; Save code string address
1774+  0F86 CD AC 06            CALL    BAKSTK          ; Look for "FOR" block
1775+  0F89 C2 09 07            JP      NZ,NFERR        ; No "FOR" - ?NF Error
1776+  0F8C F9                  LD      SP,HL           ; Clear nested loops
1777+  0F8D D5                  PUSH    DE              ; Save index address
1778+  0F8E 7E                  LD      A,(HL)          ; Get sign of STEP
1779+  0F8F 23                  INC     HL
1780+  0F90 F5                  PUSH    AF              ; Save sign of STEP
1781+  0F91 D5                  PUSH    DE              ; Save index address
1782+  0F92 CD E8 19            CALL    PHLTFP          ; Move index value to FPREG
1783+  0F95 E3                  EX      (SP),HL         ; Save address of TO value
1784+  0F96 E5                  PUSH    HL              ; Save address of index
1785+  0F97 CD 55 17            CALL    ADDPHL          ; Add STEP to index value
1786+  0F9A E1                  POP     HL              ; Restore address of index
1787+  0F9B CD 02 1A            CALL    FPTHL           ; Move value to index variable
1788+  0F9E E1                  POP     HL              ; Restore address of TO value
1789+  0F9F CD F9 19            CALL    LOADFP          ; Move TO value to BCDE
1790+  0FA2 E5                  PUSH    HL              ; Save address of line of FOR
1791+  0FA3 CD 25 1A            CALL    CMPNUM          ; Compare index with TO value
1792+  0FA6 E1                  POP     HL              ; Restore address of line num
1793+  0FA7 C1                  POP     BC              ; Address of sign of STEP
1794+  0FA8 90                  SUB     B               ; Compare with expected sign
1795+  0FA9 CD F9 19            CALL    LOADFP          ; BC = Loop stmt,DE = Line num
1796+  0FAC CA B8 0F            JP      Z,KILFOR        ; Loop finished - Terminate it
1797+  0FAF EB                  EX      DE,HL           ; Loop statement line number
1798+  0FB0 22 0C 31            LD      (LINEAT),HL     ; Set loop line number
1799+  0FB3 69                  LD      L,C             ; Set code string to loop
1800+  0FB4 60                  LD      H,B
1801+  0FB5 C3 17 0B            JP      PUTFID          ; Put back "FOR" and continue
1802+  0FB8             
1803+  0FB8 F9          KILFOR: LD      SP,HL           ; Remove "FOR" block
1804+  0FB9 2A 7E 31            LD      HL,(BRKLIN)     ; Code string after "NEXT"
1805+  0FBC 7E                  LD      A,(HL)          ; Get next byte in code string
1806+  0FBD FE 2C               CP      ','             ; More NEXTs ?
1807+  0FBF C2 1B 0B            JP      NZ,RUNCNT       ; No - Do next statement
1808+  0FC2 CD 5B 0B            CALL    GETCHR          ; Position to index name
1809+  0FC5 CD 80 0F            CALL    NEXT1           ; Re-enter NEXT routine
1810+  0FC8             ; < will not RETurn to here , Exit to RUNCNT or Loop >
1811+  0FC8             
1812+  0FC8 CD DA 0F    GETNUM: CALL    EVAL            ; Get a numeric expression
1813+  0FCB F6          TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
1814+  0FCC 37          TSTSTR: SCF                     ; Set carry (string)
1815+  0FCD 3A 5D 31    CHKTYP: LD      A,(TYPE)        ; Check types match
1816+  0FD0 8F                  ADC     A,A             ; Expected + actual
1817+  0FD1 B7                  OR      A               ; Clear carry , set parity
1818+  0FD2 E8                  RET     PE              ; Even parity - Types match
1819+  0FD3 C3 15 07            JP      TMERR           ; Different types - Error
1820+  0FD6             
1821+  0FD6 CD D1 09    OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
1822+  0FD9 28                  .BYTE   "("
1823+  0FDA 2B          EVAL:   DEC     HL              ; Evaluate expression & save
1824+  0FDB 16 00               LD      D,0             ; Precedence value
1825+  0FDD D5          EVAL1:  PUSH    DE              ; Save precedence
1826+  0FDE 0E 01               LD      C,1
1827+  0FE0 CD E0 06            CALL    CHKSTK          ; Check for 1 level of stack
1828+  0FE3 CD 51 10            CALL    OPRND           ; Get next expression value
1829+  0FE6 22 80 31    EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
1830+  0FE9 2A 80 31    EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
1831+  0FEC C1                  POP     BC              ; Precedence value and operator
1832+  0FED 78                  LD      A,B             ; Get precedence value
1833+  0FEE FE 78               CP      78H             ; "AND" or "OR" ?
1834+  0FF0 D4 CB 0F            CALL    NC,TSTNUM       ; No - Make sure it's a number
1835+  0FF3 7E                  LD      A,(HL)          ; Get next operator / function
1836+  0FF4 16 00               LD      D,0             ; Clear Last relation
1837+  0FF6 D6 B3       RLTLP:  SUB     ZGTR            ; ">" Token
1838+  0FF8 DA 12 10            JP      C,FOPRND        ; + - * / ^ AND OR - Test it
1839+  0FFB FE 03               CP      ZLTH+1-ZGTR     ; < = >
1840+  0FFD D2 12 10            JP      NC,FOPRND       ; Function - Call it
1841+  1000 FE 01               CP      ZEQUAL-ZGTR     ; "="
1842+  1002 17                  RLA                     ; <- Test for legal
1843+  1003 AA                  XOR     D               ; <- combinations of < = >
1844+  1004 BA                  CP      D               ; <- by combining last token
1845+  1005 57                  LD      D,A             ; <- with current one
1846+  1006 DA 03 07            JP      C,SNERR         ; Error if "<<' '==" or ">>"
1847+  1009 22 75 31            LD      (CUROPR),HL     ; Save address of current token
1848+  100C CD 5B 0B            CALL    GETCHR          ; Get next character
1849+  100F C3 F6 0F            JP      RLTLP           ; Treat the two as one
1850+  1012             
1851+  1012 7A          FOPRND: LD      A,D             ; < = > found ?
1852+  1013 B7                  OR      A
1853+  1014 C2 39 11            JP      NZ,TSTRED       ; Yes - Test for reduction
1854+  1017 7E                  LD      A,(HL)          ; Get operator token
1855+  1018 22 75 31            LD      (CUROPR),HL     ; Save operator address
1856+  101B D6 AC               SUB     ZPLUS           ; Operator or function?
1857+  101D D8                  RET     C               ; Neither - Exit
1858+  101E FE 07               CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
1859+  1020 D0                  RET     NC              ; No - Exit
1860+  1021 5F                  LD      E,A             ; Coded operator
1861+  1022 3A 5D 31            LD      A,(TYPE)        ; Get data type
1862+  1025 3D                  DEC     A               ; FF = numeric , 00 = string
1863+  1026 B3                  OR      E               ; Combine with coded operator
1864+  1027 7B                  LD      A,E             ; Get coded operator
1865+  1028 CA 97 15            JP      Z,CONCAT        ; String concatenation
1866+  102B 07                  RLCA                    ; Times 2
1867+  102C 83                  ADD     A,E             ; Times 3
1868+  102D 5F                  LD      E,A             ; To DE (D is 0)
1869+  102E 21 F5 05            LD      HL,PRITAB       ; Precedence table
1870+  1031 19                  ADD     HL,DE           ; To the operator concerned
1871+  1032 78                  LD      A,B             ; Last operator precedence
1872+  1033 56                  LD      D,(HL)          ; Get evaluation precedence
1873+  1034 BA                  CP      D               ; Compare with eval precedence
1874+  1035 D0                  RET     NC              ; Exit if higher precedence
1875+  1036 23                  INC     HL              ; Point to routine address
1876+  1037 CD CB 0F            CALL    TSTNUM          ; Make sure it's a number
1877+  103A             
1878+  103A C5          STKTHS: PUSH    BC              ; Save last precedence & token
1879+  103B 01 E9 0F            LD      BC,EVAL3        ; Where to go on prec' break
1880+  103E C5                  PUSH    BC              ; Save on stack for return
1881+  103F 43                  LD      B,E             ; Save operator
1882+  1040 4A                  LD      C,D             ; Save precedence
1883+  1041 CD DB 19            CALL    STAKFP          ; Move value to stack
1884+  1044 58                  LD      E,B             ; Restore operator
1885+  1045 51                  LD      D,C             ; Restore precedence
1886+  1046 4E                  LD      C,(HL)          ; Get LSB of routine address
1887+  1047 23                  INC     HL
1888+  1048 46                  LD      B,(HL)          ; Get MSB of routine address
1889+  1049 23                  INC     HL
1890+  104A C5                  PUSH    BC              ; Save routine address
1891+  104B 2A 75 31            LD      HL,(CUROPR)     ; Address of current operator
1892+  104E C3 DD 0F            JP      EVAL1           ; Loop until prec' break
1893+  1051             
1894+  1051 AF          OPRND:  XOR     A               ; Get operand routine
1895+  1052 32 5D 31            LD      (TYPE),A        ; Set numeric expected
1896+  1055 CD 5B 0B            CALL    GETCHR          ; Get next character
1897+  1058 1E 24               LD      E,MO            ; ?MO Error
1898+  105A CA 17 07            JP      Z,ERROR         ; No operand - Error
1899+  105D DA B1 1A            JP      C,ASCTFP        ; Number - Get value
1900+  1060 CD F9 0B            CALL    CHKLTR          ; See if a letter
1901+  1063 D2 B8 10            JP      NC,CONVAR       ; Letter - Find variable
1902+  1066 FE 26               CP		'&'				; &H = HEX, &B = BINARY
1903+  1068 20 12               JR		NZ, NOTAMP
1904+  106A CD 5B 0B            CALL    GETCHR          ; Get next character
1905+  106D FE 48               CP      'H'             ; Hex number indicated? [function added]
1906+  106F CA F5 1E            JP      Z,HEXTFP        ; Convert Hex to FPREG
1907+  1072 FE 42               CP      'B'             ; Binary number indicated? [function added]
1908+  1074 CA 65 1F            JP      Z,BINTFP        ; Convert Bin to FPREG
1909+  1077 1E 02               LD      E,SN            ; If neither then a ?SN Error
1910+  1079 CA 17 07            JP      Z,ERROR         ; 
1911+  107C FE AC       NOTAMP: CP      ZPLUS           ; '+' Token ?
1912+  107E CA 51 10            JP      Z,OPRND         ; Yes - Look for operand
1913+  1081 FE 2E               CP      '.'             ; '.' ?
1914+  1083 CA B1 1A            JP      Z,ASCTFP        ; Yes - Create FP number
1915+  1086 FE AD               CP      ZMINUS          ; '-' Token ?
1916+  1088 CA A7 10            JP      Z,MINUS         ; Yes - Do minus
1917+  108B FE 22               CP      '"'             ; Literal string ?
1918+  108D CA 60 14            JP      Z,QTSTR         ; Get string terminated by '"'
1919+  1090 FE AA               CP      ZNOT            ; "NOT" Token ?
1920+  1092 CA 99 11            JP      Z,EVNOT         ; Yes - Eval NOT expression
1921+  1095 FE A7               CP      ZFN             ; "FN" Token ?
1922+  1097 CA C4 13            JP      Z,DOFN          ; Yes - Do FN routine
1923+  109A D6 B6               SUB     ZSGN            ; Is it a function?
1924+  109C D2 C9 10            JP      NC,FNOFST       ; Yes - Evaluate function
1925+  109F CD D6 0F    EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
1926+  10A2 CD D1 09            CALL    CHKSYN          ; Make sure ")" follows
1927+  10A5 29                  .BYTE   ")"
1928+  10A6 C9                  RET
1929+  10A7             
1930+  10A7 16 7D       MINUS:  LD      D,7DH           ; '-' precedence
1931+  10A9 CD DD 0F            CALL    EVAL1           ; Evaluate until prec' break
1932+  10AC 2A 80 31            LD      HL,(NXTOPR)     ; Get next operator address
1933+  10AF E5                  PUSH    HL              ; Save next operator address
1934+  10B0 CD D3 19            CALL    INVSGN          ; Negate value
1935+  10B3 CD CB 0F    RETNUM: CALL    TSTNUM          ; Make sure it's a number
1936+  10B6 E1                  POP     HL              ; Restore next operator address
1937+  10B7 C9                  RET
1938+  10B8             
1939+  10B8 CD BE 11    CONVAR: CALL    GETVAR          ; Get variable address to DE
1940+  10BB E5          FRMEVL: PUSH    HL              ; Save code string address
1941+  10BC EB                  EX      DE,HL           ; Variable address to HL
1942+  10BD 22 94 31            LD      (FPREG),HL      ; Save address of variable
1943+  10C0 3A 5D 31            LD      A,(TYPE)        ; Get type
1944+  10C3 B7                  OR      A               ; Numeric?
1945+  10C4 CC E8 19            CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
1946+  10C7 E1                  POP     HL              ; Restore code string address
1947+  10C8 C9                  RET
1948+  10C9             
1949+  10C9 06 00       FNOFST: LD      B,0             ; Get address of function
1950+  10CB 07                  RLCA                    ; Double function offset
1951+  10CC 4F                  LD      C,A             ; BC = Offset in function table
1952+  10CD C5                  PUSH    BC              ; Save adjusted token value
1953+  10CE CD 5B 0B            CALL    GETCHR          ; Get next character
1954+  10D1 79                  LD      A,C             ; Get adjusted token value
1955+  10D2 FE 31               CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1956+  10D4 DA F0 10            JP      C,FNVAL         ; No - Do function
1957+  10D7 CD D6 0F            CALL    OPNPAR          ; Evaluate expression  (X,...
1958+  10DA CD D1 09            CALL    CHKSYN          ; Make sure ',' follows
1959+  10DD 2C                  .BYTE      ','
1960+  10DE CD CC 0F            CALL    TSTSTR          ; Make sure it's a string
1961+  10E1 EB                  EX      DE,HL           ; Save code string address
1962+  10E2 2A 94 31            LD      HL,(FPREG)      ; Get address of string
1963+  10E5 E3                  EX      (SP),HL         ; Save address of string
1964+  10E6 E5                  PUSH    HL              ; Save adjusted token value
1965+  10E7 EB                  EX      DE,HL           ; Restore code string address
1966+  10E8 CD 29 17            CALL    GETINT          ; Get integer 0-255
1967+  10EB EB                  EX      DE,HL           ; Save code string address
1968+  10EC E3                  EX      (SP),HL         ; Save integer,HL = adj' token
1969+  10ED C3 F8 10            JP      GOFUNC          ; Jump to string function
1970+  10F0             
1971+  10F0 CD 9F 10    FNVAL:  CALL    EVLPAR          ; Evaluate expression
1972+  10F3 E3                  EX      (SP),HL         ; HL = Adjusted token value
1973+  10F4 11 B3 10            LD      DE,RETNUM       ; Return number from function
1974+  10F7 D5                  PUSH    DE              ; Save on stack
1975+  10F8 01 54 04    GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
1976+  10FB 09                  ADD     HL,BC           ; Point to right address
1977+  10FC 4E                  LD      C,(HL)          ; Get LSB of address
1978+  10FD 23                  INC     HL              ;
1979+  10FE 66                  LD      H,(HL)          ; Get MSB of address
1980+  10FF 69                  LD      L,C             ; Address to HL
1981+  1100 E9                  JP      (HL)            ; Jump to function
1982+  1101             
1983+  1101 15          SGNEXP: DEC     D               ; Dee to flag negative exponent
1984+  1102 FE AD               CP      ZMINUS          ; '-' token ?
1985+  1104 C8                  RET     Z               ; Yes - Return
1986+  1105 FE 2D               CP      '-'             ; '-' ASCII ?
1987+  1107 C8                  RET     Z               ; Yes - Return
1988+  1108 14                  INC     D               ; Inc to flag positive exponent
1989+  1109 FE 2B               CP      '+'             ; '+' ASCII ?
1990+  110B C8                  RET     Z               ; Yes - Return
1991+  110C FE AC               CP      ZPLUS           ; '+' token ?
1992+  110E C8                  RET     Z               ; Yes - Return
1993+  110F 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
1994+  1110 C9                  RET                     ; Return "NZ"
1995+  1111             
1996+  1111 F6          POR:    .BYTE      0F6H            ; Flag "OR"
1997+  1112 AF          PAND:   XOR     A               ; Flag "AND"
1998+  1113 F5                  PUSH    AF              ; Save "AND" / "OR" flag
1999+  1114 CD CB 0F            CALL    TSTNUM          ; Make sure it's a number
2000+  1117 CD 0D 0C            CALL    DEINT           ; Get integer -32768 to 32767
2001+  111A F1                  POP     AF              ; Restore "AND" / "OR" flag
2002+  111B EB                  EX      DE,HL           ; <- Get last
2003+  111C C1                  POP     BC              ; <-  value
2004+  111D E3                  EX      (SP),HL         ; <-  from
2005+  111E EB                  EX      DE,HL           ; <-  stack
2006+  111F CD EB 19            CALL    FPBCDE          ; Move last value to FPREG
2007+  1122 F5                  PUSH    AF              ; Save "AND" / "OR" flag
2008+  1123 CD 0D 0C            CALL    DEINT           ; Get integer -32768 to 32767
2009+  1126 F1                  POP     AF              ; Restore "AND" / "OR" flag
2010+  1127 C1                  POP     BC              ; Get value
2011+  1128 79                  LD      A,C             ; Get LSB
2012+  1129 21 82 13            LD      HL,ACPASS       ; Address of save AC as current
2013+  112C C2 34 11            JP      NZ,POR1         ; Jump if OR
2014+  112F A3                  AND     E               ; "AND" LSBs
2015+  1130 4F                  LD      C,A             ; Save LSB
2016+  1131 78                  LD      A,B             ; Get MBS
2017+  1132 A2                  AND     D               ; "AND" MSBs
2018+  1133 E9                  JP      (HL)            ; Save AC as current (ACPASS)
2019+  1134             
2020+  1134 B3          POR1:   OR      E               ; "OR" LSBs
2021+  1135 4F                  LD      C,A             ; Save LSB
2022+  1136 78                  LD      A,B             ; Get MSB
2023+  1137 B2                  OR      D               ; "OR" MSBs
2024+  1138 E9                  JP      (HL)            ; Save AC as current (ACPASS)
2025+  1139             
2026+  1139 21 4B 11    TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2027+  113C 3A 5D 31            LD      A,(TYPE)        ; Get data type
2028+  113F 1F                  RRA                     ; Carry set = string
2029+  1140 7A                  LD      A,D             ; Get last precedence value
2030+  1141 17                  RLA                     ; Times 2 plus carry
2031+  1142 5F                  LD      E,A             ; To E
2032+  1143 16 64               LD      D,64H           ; Relational precedence
2033+  1145 78                  LD      A,B             ; Get current precedence
2034+  1146 BA                  CP      D               ; Compare with last
2035+  1147 D0                  RET     NC              ; Eval if last was rel' or log'
2036+  1148 C3 3A 10            JP      STKTHS          ; Stack this one and get next
2037+  114B             
2038+  114B 4D 11       CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
2039+  114D 79          CMPLG1: LD      A,C             ; Get data type
2040+  114E B7                  OR      A
2041+  114F 1F                  RRA
2042+  1150 C1                  POP     BC              ; Get last expression to BCDE
2043+  1151 D1                  POP     DE
2044+  1152 F5                  PUSH    AF              ; Save status
2045+  1153 CD CD 0F            CALL    CHKTYP          ; Check that types match
2046+  1156 21 8F 11            LD      HL,CMPRES       ; Result to comparison
2047+  1159 E5                  PUSH    HL              ; Save for RETurn
2048+  115A CA 25 1A            JP      Z,CMPNUM        ; Compare values if numeric
2049+  115D AF                  XOR     A               ; Compare two strings
2050+  115E 32 5D 31            LD      (TYPE),A        ; Set type to numeric
2051+  1161 D5                  PUSH    DE              ; Save string name
2052+  1162 CD E4 15            CALL    GSTRCU          ; Get current string
2053+  1165 7E                  LD      A,(HL)          ; Get length of string
2054+  1166 23                  INC     HL
2055+  1167 23                  INC     HL
2056+  1168 4E                  LD      C,(HL)          ; Get LSB of address
2057+  1169 23                  INC     HL
2058+  116A 46                  LD      B,(HL)          ; Get MSB of address
2059+  116B D1                  POP     DE              ; Restore string name
2060+  116C C5                  PUSH    BC              ; Save address of string
2061+  116D F5                  PUSH    AF              ; Save length of string
2062+  116E CD E8 15            CALL    GSTRDE          ; Get second string
2063+  1171 CD F9 19            CALL    LOADFP          ; Get address of second string
2064+  1174 F1                  POP     AF              ; Restore length of string 1
2065+  1175 57                  LD      D,A             ; Length to D
2066+  1176 E1                  POP     HL              ; Restore address of string 1
2067+  1177 7B          CMPSTR: LD      A,E             ; Bytes of string 2 to do
2068+  1178 B2                  OR      D               ; Bytes of string 1 to do
2069+  1179 C8                  RET     Z               ; Exit if all bytes compared
2070+  117A 7A                  LD      A,D             ; Get bytes of string 1 to do
2071+  117B D6 01               SUB     1
2072+  117D D8                  RET     C               ; Exit if end of string 1
2073+  117E AF                  XOR     A
2074+  117F BB                  CP      E               ; Bytes of string 2 to do
2075+  1180 3C                  INC     A
2076+  1181 D0                  RET     NC              ; Exit if end of string 2
2077+  1182 15                  DEC     D               ; Count bytes in string 1
2078+  1183 1D                  DEC     E               ; Count bytes in string 2
2079+  1184 0A                  LD      A,(BC)          ; Byte in string 2
2080+  1185 BE                  CP      (HL)            ; Compare to byte in string 1
2081+  1186 23                  INC     HL              ; Move up string 1
2082+  1187 03                  INC     BC              ; Move up string 2
2083+  1188 CA 77 11            JP      Z,CMPSTR        ; Same - Try next bytes
2084+  118B 3F                  CCF                     ; Flag difference (">" or "<")
2085+  118C C3 B5 19            JP      FLGDIF          ; "<" gives -1 , ">" gives +1
2086+  118F             
2087+  118F 3C          CMPRES: INC     A               ; Increment current value
2088+  1190 8F                  ADC     A,A             ; Double plus carry
2089+  1191 C1                  POP     BC              ; Get other value
2090+  1192 A0                  AND     B               ; Combine them
2091+  1193 C6 FF               ADD     A,-1            ; Carry set if different
2092+  1195 9F                  SBC     A,A             ; 00 - Equal , FF - Different
2093+  1196 C3 BC 19            JP      FLGREL          ; Set current value & continue
2094+  1199             
2095+  1199 16 5A       EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2096+  119B CD DD 0F            CALL    EVAL1           ; Eval until precedence break
2097+  119E CD CB 0F            CALL    TSTNUM          ; Make sure it's a number
2098+  11A1 CD 0D 0C            CALL    DEINT           ; Get integer -32768 - 32767
2099+  11A4 7B                  LD      A,E             ; Get LSB
2100+  11A5 2F                  CPL                     ; Invert LSB
2101+  11A6 4F                  LD      C,A             ; Save "NOT" of LSB
2102+  11A7 7A                  LD      A,D             ; Get MSB
2103+  11A8 2F                  CPL                     ; Invert MSB
2104+  11A9 CD 82 13            CALL    ACPASS          ; Save AC as current
2105+  11AC C1                  POP     BC              ; Clean up stack
2106+  11AD C3 E9 0F            JP      EVAL3           ; Continue evaluation
2107+  11B0             
2108+  11B0 2B          DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2109+  11B1 CD 5B 0B            CALL    GETCHR          ; Get next character
2110+  11B4 C8                  RET     Z               ; End of DIM statement
2111+  11B5 CD D1 09            CALL    CHKSYN          ; Make sure ',' follows
2112+  11B8 2C                  .BYTE      ','
2113+  11B9 01 B0 11    DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2114+  11BC C5                  PUSH    BC              ; Save on stack
2115+  11BD F6                  .BYTE      0F6H            ; Flag "Create" variable
2116+  11BE AF          GETVAR: XOR     A               ; Find variable address,to DE
2117+  11BF 32 5C 31            LD      (LCRFLG),A      ; Set locate / create flag
2118+  11C2 46                  LD      B,(HL)          ; Get First byte of name
2119+  11C3 CD F9 0B    GTFNAM: CALL    CHKLTR          ; See if a letter
2120+  11C6 DA 03 07            JP      C,SNERR         ; ?SN Error if not a letter
2121+  11C9 AF                  XOR     A
2122+  11CA 4F                  LD      C,A             ; Clear second byte of name
2123+  11CB 32 5D 31            LD      (TYPE),A        ; Set type to numeric
2124+  11CE CD 5B 0B            CALL    GETCHR          ; Get next character
2125+  11D1 DA DA 11            JP      C,SVNAM2        ; Numeric - Save in name
2126+  11D4 CD F9 0B            CALL    CHKLTR          ; See if a letter
2127+  11D7 DA E7 11            JP      C,CHARTY        ; Not a letter - Check type
2128+  11DA 4F          SVNAM2: LD      C,A             ; Save second byte of name
2129+  11DB CD 5B 0B    ENDNAM: CALL    GETCHR          ; Get next character
2130+  11DE DA DB 11            JP      C,ENDNAM        ; Numeric - Get another
2131+  11E1 CD F9 0B            CALL    CHKLTR          ; See if a letter
2132+  11E4 D2 DB 11            JP      NC,ENDNAM       ; Letter - Get another
2133+  11E7 D6 24       CHARTY: SUB     '$'             ; String variable?
2134+  11E9 C2 F6 11            JP      NZ,NOTSTR       ; No - Numeric variable
2135+  11EC 3C                  INC     A               ; A = 1 (string type)
2136+  11ED 32 5D 31            LD      (TYPE),A        ; Set type to string
2137+  11F0 0F                  RRCA                    ; A = 80H , Flag for string
2138+  11F1 81                  ADD     A,C             ; 2nd byte of name has bit 7 on
2139+  11F2 4F                  LD      C,A             ; Resave second byte on name
2140+  11F3 CD 5B 0B            CALL    GETCHR          ; Get next character
2141+  11F6 3A 7B 31    NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2142+  11F9 3D                  DEC     A
2143+  11FA CA A3 12            JP      Z,ARLDSV        ; Yes - Get array name
2144+  11FD F2 06 12            JP      P,NSCFOR        ; No array with "FOR" or "FN"
2145+  1200 7E                  LD      A,(HL)          ; Get byte again
2146+  1201 D6 28               SUB     '('             ; Subscripted variable?
2147+  1203 CA 7B 12            JP      Z,SBSCPT        ; Yes - Sort out subscript
2148+  1206             
2149+  1206 AF          NSCFOR: XOR     A               ; Simple variable
2150+  1207 32 7B 31            LD      (FORFLG),A      ; Clear "FOR" flag
2151+  120A E5                  PUSH    HL              ; Save code string address
2152+  120B 50                  LD      D,B             ; DE = Variable name to find
2153+  120C 59                  LD      E,C
2154+  120D 2A 8E 31            LD      HL,(FNRGNM)     ; FN argument name
2155+  1210 CD CB 09            CALL    CPDEHL          ; Is it the FN argument?
2156+  1213 11 90 31            LD      DE,FNARG        ; Point to argument value
2157+  1216 CA EB 18            JP      Z,POPHRT        ; Yes - Return FN argument value
2158+  1219 2A 88 31            LD      HL,(VAREND)     ; End of variables
2159+  121C EB                  EX      DE,HL           ; Address of end of search
2160+  121D 2A 86 31            LD      HL,(PROGND)     ; Start of variables address
2161+  1220 CD CB 09    FNDVAR: CALL    CPDEHL          ; End of variable list table?
2162+  1223 CA 39 12            JP      Z,CFEVAL        ; Yes - Called from EVAL?
2163+  1226 79                  LD      A,C             ; Get second byte of name
2164+  1227 96                  SUB     (HL)            ; Compare with name in list
2165+  1228 23                  INC     HL              ; Move on to first byte
2166+  1229 C2 2E 12            JP      NZ,FNTHR        ; Different - Find another
2167+  122C 78                  LD      A,B             ; Get first byte of name
2168+  122D 96                  SUB     (HL)            ; Compare with name in list
2169+  122E 23          FNTHR:  INC     HL              ; Move on to LSB of value
2170+  122F CA 6D 12            JP      Z,RETADR        ; Found - Return address
2171+  1232 23                  INC     HL              ; <- Skip
2172+  1233 23                  INC     HL              ; <- over
2173+  1234 23                  INC     HL              ; <- F.P.
2174+  1235 23                  INC     HL              ; <- value
2175+  1236 C3 20 12            JP      FNDVAR          ; Keep looking
2176+  1239             
2177+  1239 E1          CFEVAL: POP     HL              ; Restore code string address
2178+  123A E3                  EX      (SP),HL         ; Get return address
2179+  123B D5                  PUSH    DE              ; Save address of variable
2180+  123C 11 BB 10            LD      DE,FRMEVL       ; Return address in EVAL
2181+  123F CD CB 09            CALL    CPDEHL          ; Called from EVAL ?
2182+  1242 D1                  POP     DE              ; Restore address of variable
2183+  1243 CA 70 12            JP      Z,RETNUL        ; Yes - Return null variable
2184+  1246 E3                  EX      (SP),HL         ; Put back return
2185+  1247 E5                  PUSH    HL              ; Save code string address
2186+  1248 C5                  PUSH    BC              ; Save variable name
2187+  1249 01 06 00            LD      BC,6            ; 2 byte name plus 4 byte data
2188+  124C 2A 8A 31            LD      HL,(ARREND)     ; End of arrays
2189+  124F E5                  PUSH    HL              ; Save end of arrays
2190+  1250 09                  ADD     HL,BC           ; Move up 6 bytes
2191+  1251 C1                  POP     BC              ; Source address in BC
2192+  1252 E5                  PUSH    HL              ; Save new end address
2193+  1253 CD CF 06            CALL    MOVUP           ; Move arrays up
2194+  1256 E1                  POP     HL              ; Restore new end address
2195+  1257 22 8A 31            LD      (ARREND),HL     ; Set new end address
2196+  125A 60                  LD      H,B             ; End of variables to HL
2197+  125B 69                  LD      L,C
2198+  125C 22 88 31            LD      (VAREND),HL     ; Set new end address
2199+  125F             
2200+  125F 2B          ZEROLP: DEC     HL              ; Back through to zero variable
2201+  1260 36 00               LD      (HL),0          ; Zero byte in variable
2202+  1262 CD CB 09            CALL    CPDEHL          ; Done them all?
2203+  1265 C2 5F 12            JP      NZ,ZEROLP       ; No - Keep on going
2204+  1268 D1                  POP     DE              ; Get variable name
2205+  1269 73                  LD      (HL),E          ; Store second character
2206+  126A 23                  INC     HL
2207+  126B 72                  LD      (HL),D          ; Store first character
2208+  126C 23                  INC     HL
2209+  126D EB          RETADR: EX      DE,HL           ; Address of variable in DE
2210+  126E E1                  POP     HL              ; Restore code string address
2211+  126F C9                  RET
2212+  1270             
2213+  1270 32 97 31    RETNUL: LD      (FPEXP),A       ; Set result to zero
2214+  1273 21 9F 06            LD      HL,ZERBYT       ; Also set a null string
2215+  1276 22 94 31            LD      (FPREG),HL      ; Save for EVAL
2216+  1279 E1                  POP     HL              ; Restore code string address
2217+  127A C9                  RET
2218+  127B             
2219+  127B E5          SBSCPT: PUSH    HL              ; Save code string address
2220+  127C 2A 5C 31            LD      HL,(LCRFLG)     ; Locate/Create and Type
2221+  127F E3                  EX      (SP),HL         ; Save and get code string
2222+  1280 57                  LD      D,A             ; Zero number of dimensions
2223+  1281 D5          SCPTLP: PUSH    DE              ; Save number of dimensions
2224+  1282 C5                  PUSH    BC              ; Save array name
2225+  1283 CD 01 0C            CALL    FPSINT          ; Get subscript (0-32767)
2226+  1286 C1                  POP     BC              ; Restore array name
2227+  1287 F1                  POP     AF              ; Get number of dimensions
2228+  1288 EB                  EX      DE,HL
2229+  1289 E3                  EX      (SP),HL         ; Save subscript value
2230+  128A E5                  PUSH    HL              ; Save LCRFLG and TYPE
2231+  128B EB                  EX      DE,HL
2232+  128C 3C                  INC     A               ; Count dimensions
2233+  128D 57                  LD      D,A             ; Save in D
2234+  128E 7E                  LD      A,(HL)          ; Get next byte in code string
2235+  128F FE 2C               CP      ','             ; Comma (more to come)?
2236+  1291 CA 81 12            JP      Z,SCPTLP        ; Yes - More subscripts
2237+  1294 CD D1 09            CALL    CHKSYN          ; Make sure ")" follows
2238+  1297 29                  .BYTE      ")"
2239+  1298 22 80 31            LD      (NXTOPR),HL     ; Save code string address
2240+  129B E1                  POP     HL              ; Get LCRFLG and TYPE
2241+  129C 22 5C 31            LD      (LCRFLG),HL     ; Restore Locate/create & type
2242+  129F 1E 00               LD      E,0             ; Flag not CSAVE* or CLOAD*
2243+  12A1 D5                  PUSH    DE              ; Save number of dimensions (D)
2244+  12A2 11                  .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
2245+  12A3             
2246+  12A3 E5          ARLDSV: PUSH    HL              ; Save code string address
2247+  12A4 F5                  PUSH    AF              ; A = 00 , Flags set = Z,N
2248+  12A5 2A 88 31            LD      HL,(VAREND)     ; Start of arrays
2249+  12A8 3E                  .BYTE      3EH             ; Skip "ADD HL,DE"
2250+  12A9 19          FNDARY: ADD     HL,DE           ; Move to next array start
2251+  12AA EB                  EX      DE,HL
2252+  12AB 2A 8A 31            LD      HL,(ARREND)     ; End of arrays
2253+  12AE EB                  EX      DE,HL           ; Current array pointer
2254+  12AF CD CB 09            CALL    CPDEHL          ; End of arrays found?
2255+  12B2 CA DB 12            JP      Z,CREARY        ; Yes - Create array
2256+  12B5 7E                  LD      A,(HL)          ; Get second byte of name
2257+  12B6 B9                  CP      C               ; Compare with name given
2258+  12B7 23                  INC     HL              ; Move on
2259+  12B8 C2 BD 12            JP      NZ,NXTARY       ; Different - Find next array
2260+  12BB 7E                  LD      A,(HL)          ; Get first byte of name
2261+  12BC B8                  CP      B               ; Compare with name given
2262+  12BD 23          NXTARY: INC     HL              ; Move on
2263+  12BE 5E                  LD      E,(HL)          ; Get LSB of next array address
2264+  12BF 23                  INC     HL
2265+  12C0 56                  LD      D,(HL)          ; Get MSB of next array address
2266+  12C1 23                  INC     HL
2267+  12C2 C2 A9 12            JP      NZ,FNDARY       ; Not found - Keep looking
2268+  12C5 3A 5C 31            LD      A,(LCRFLG)      ; Found Locate or Create it?
2269+  12C8 B7                  OR      A
2270+  12C9 C2 0C 07            JP      NZ,DDERR        ; Create - ?DD Error
2271+  12CC F1                  POP     AF              ; Locate - Get number of dim'ns
2272+  12CD 44                  LD      B,H             ; BC Points to array dim'ns
2273+  12CE 4D                  LD      C,L
2274+  12CF CA EB 18            JP      Z,POPHRT        ; Jump if array load/save
2275+  12D2 96                  SUB     (HL)            ; Same number of dimensions?
2276+  12D3 CA 39 13            JP      Z,FINDEL        ; Yes - Find element
2277+  12D6 1E 10       BSERR:  LD      E,BS            ; ?BS Error
2278+  12D8 C3 17 07            JP      ERROR           ; Output error
2279+  12DB             
2280+  12DB 11 04 00    CREARY: LD      DE,4            ; 4 Bytes per entry
2281+  12DE F1                  POP     AF              ; Array to save or 0 dim'ns?
2282+  12DF CA 22 0C            JP      Z,FCERR         ; Yes - ?FC Error
2283+  12E2 71                  LD      (HL),C          ; Save second byte of name
2284+  12E3 23                  INC     HL
2285+  12E4 70                  LD      (HL),B          ; Save first byte of name
2286+  12E5 23                  INC     HL
2287+  12E6 4F                  LD      C,A             ; Number of dimensions to C
2288+  12E7 CD E0 06            CALL    CHKSTK          ; Check if enough memory
2289+  12EA 23                  INC     HL              ; Point to number of dimensions
2290+  12EB 23                  INC     HL
2291+  12EC 22 75 31            LD      (CUROPR),HL     ; Save address of pointer
2292+  12EF 71                  LD      (HL),C          ; Set number of dimensions
2293+  12F0 23                  INC     HL
2294+  12F1 3A 5C 31            LD      A,(LCRFLG)      ; Locate of Create?
2295+  12F4 17                  RLA                     ; Carry set = Create
2296+  12F5 79                  LD      A,C             ; Get number of dimensions
2297+  12F6 01 0B 00    CRARLP: LD      BC,10+1         ; Default dimension size 10
2298+  12F9 D2 FE 12            JP      NC,DEFSIZ       ; Locate - Set default size
2299+  12FC C1                  POP     BC              ; Get specified dimension size
2300+  12FD 03                  INC     BC              ; Include zero element
2301+  12FE 71          DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2302+  12FF 23                  INC     HL
2303+  1300 70                  LD      (HL),B          ; Save MSB of dimension size
2304+  1301 23                  INC     HL
2305+  1302 F5                  PUSH    AF              ; Save num' of dim'ns an status
2306+  1303 E5                  PUSH    HL              ; Save address of dim'n size
2307+  1304 CD 96 1A            CALL    MLDEBC          ; Multiply DE by BC to find
2308+  1307 EB                  EX      DE,HL           ; amount of mem needed (to DE)
2309+  1308 E1                  POP     HL              ; Restore address of dimension
2310+  1309 F1                  POP     AF              ; Restore number of dimensions
2311+  130A 3D                  DEC     A               ; Count them
2312+  130B C2 F6 12            JP      NZ,CRARLP       ; Do next dimension if more
2313+  130E F5                  PUSH    AF              ; Save locate/create flag
2314+  130F 42                  LD      B,D             ; MSB of memory needed
2315+  1310 4B                  LD      C,E             ; LSB of memory needed
2316+  1311 EB                  EX      DE,HL
2317+  1312 19                  ADD     HL,DE           ; Add bytes to array start
2318+  1313 DA F8 06            JP      C,OMERR         ; Too big - Error
2319+  1316 CD E9 06            CALL    ENFMEM          ; See if enough memory
2320+  1319 22 8A 31            LD      (ARREND),HL     ; Save new end of array
2321+  131C             
2322+  131C 2B          ZERARY: DEC     HL              ; Back through array data
2323+  131D 36 00               LD      (HL),0          ; Set array element to zero
2324+  131F CD CB 09            CALL    CPDEHL          ; All elements zeroed?
2325+  1322 C2 1C 13            JP      NZ,ZERARY       ; No - Keep on going
2326+  1325 03                  INC     BC              ; Number of bytes + 1
2327+  1326 57                  LD      D,A             ; A=0
2328+  1327 2A 75 31            LD      HL,(CUROPR)     ; Get address of array
2329+  132A 5E                  LD      E,(HL)          ; Number of dimensions
2330+  132B EB                  EX      DE,HL           ; To HL
2331+  132C 29                  ADD     HL,HL           ; Two bytes per dimension size
2332+  132D 09                  ADD     HL,BC           ; Add number of bytes
2333+  132E EB                  EX      DE,HL           ; Bytes needed to DE
2334+  132F 2B                  DEC     HL
2335+  1330 2B                  DEC     HL
2336+  1331 73                  LD      (HL),E          ; Save LSB of bytes needed
2337+  1332 23                  INC     HL
2338+  1333 72                  LD      (HL),D          ; Save MSB of bytes needed
2339+  1334 23                  INC     HL
2340+  1335 F1                  POP     AF              ; Locate / Create?
2341+  1336 DA 5D 13            JP      C,ENDDIM        ; A is 0 , End if create
2342+  1339 47          FINDEL: LD      B,A             ; Find array element
2343+  133A 4F                  LD      C,A
2344+  133B 7E                  LD      A,(HL)          ; Number of dimensions
2345+  133C 23                  INC     HL
2346+  133D 16                  .BYTE      16H             ; Skip "POP HL"
2347+  133E E1          FNDELP: POP     HL              ; Address of next dim' size
2348+  133F 5E                  LD      E,(HL)          ; Get LSB of dim'n size
2349+  1340 23                  INC     HL
2350+  1341 56                  LD      D,(HL)          ; Get MSB of dim'n size
2351+  1342 23                  INC     HL
2352+  1343 E3                  EX      (SP),HL         ; Save address - Get index
2353+  1344 F5                  PUSH    AF              ; Save number of dim'ns
2354+  1345 CD CB 09            CALL    CPDEHL          ; Dimension too large?
2355+  1348 D2 D6 12            JP      NC,BSERR        ; Yes - ?BS Error
2356+  134B E5                  PUSH    HL              ; Save index
2357+  134C CD 96 1A            CALL    MLDEBC          ; Multiply previous by size
2358+  134F D1                  POP     DE              ; Index supplied to DE
2359+  1350 19                  ADD     HL,DE           ; Add index to pointer
2360+  1351 F1                  POP     AF              ; Number of dimensions
2361+  1352 3D                  DEC     A               ; Count them
2362+  1353 44                  LD      B,H             ; MSB of pointer
2363+  1354 4D                  LD      C,L             ; LSB of pointer
2364+  1355 C2 3E 13            JP      NZ,FNDELP       ; More - Keep going
2365+  1358 29                  ADD     HL,HL           ; 4 Bytes per element
2366+  1359 29                  ADD     HL,HL
2367+  135A C1                  POP     BC              ; Start of array
2368+  135B 09                  ADD     HL,BC           ; Point to element
2369+  135C EB                  EX      DE,HL           ; Address of element to DE
2370+  135D 2A 80 31    ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
2371+  1360 C9                  RET
2372+  1361             
2373+  1361 2A 8A 31    FRE:    LD      HL,(ARREND)     ; Start of free memory
2374+  1364 EB                  EX      DE,HL           ; To DE
2375+  1365 21 00 00            LD      HL,0            ; End of free memory
2376+  1368 39                  ADD     HL,SP           ; Current stack value
2377+  1369 3A 5D 31            LD      A,(TYPE)        ; Dummy argument type
2378+  136C B7                  OR      A
2379+  136D CA 7D 13            JP      Z,FRENUM        ; Numeric - Free variable space
2380+  1370 CD E4 15            CALL    GSTRCU          ; Current string to pool
2381+  1373 CD E4 14            CALL    GARBGE          ; Garbage collection
2382+  1376 2A 0A 31            LD      HL,(STRSPC)     ; Bottom of string space in use
2383+  1379 EB                  EX      DE,HL           ; To DE
2384+  137A 2A 73 31            LD      HL,(STRBOT)     ; Bottom of string space
2385+  137D 7D          FRENUM: LD      A,L             ; Get LSB of end
2386+  137E 93                  SUB     E               ; Subtract LSB of beginning
2387+  137F 4F                  LD      C,A             ; Save difference if C
2388+  1380 7C                  LD      A,H             ; Get MSB of end
2389+  1381 9A                  SBC     A,D             ; Subtract MSB of beginning
2390+  1382 41          ACPASS: LD      B,C             ; Return integer AC
2391+  1383 50          ABPASS: LD      D,B             ; Return integer AB
2392+  1384 1E 00               LD      E,0
2393+  1386 21 5D 31            LD      HL,TYPE         ; Point to type
2394+  1389 73                  LD      (HL),E          ; Set type to numeric
2395+  138A 06 90               LD      B,80H+16        ; 16 bit integer
2396+  138C C3 C1 19            JP      RETINT          ; Return the integr
2397+  138F             
2398+  138F 3A 5B 31    POS:    LD      A,(CURPOS)      ; Get cursor position
2399+  1392 47          PASSA:  LD      B,A             ; Put A into AB
2400+  1393 AF                  XOR     A               ; Zero A
2401+  1394 C3 83 13            JP      ABPASS          ; Return integer AB
2402+  1397             
2403+  1397 CD 1A 14    DEF:    CALL    CHEKFN          ; Get "FN" and name
2404+  139A CD 0C 14            CALL    IDTEST          ; Test for illegal direct
2405+  139D 01 F2 0C            LD      BC,DATA         ; To get next statement
2406+  13A0 C5                  PUSH    BC              ; Save address for RETurn
2407+  13A1 D5                  PUSH    DE              ; Save address of function ptr
2408+  13A2 CD D1 09            CALL    CHKSYN          ; Make sure "(" follows
2409+  13A5 28                  .BYTE      "("
2410+  13A6 CD BE 11            CALL    GETVAR          ; Get argument variable name
2411+  13A9 E5                  PUSH    HL              ; Save code string address
2412+  13AA EB                  EX      DE,HL           ; Argument address to HL
2413+  13AB 2B                  DEC     HL
2414+  13AC 56                  LD      D,(HL)          ; Get first byte of arg name
2415+  13AD 2B                  DEC     HL
2416+  13AE 5E                  LD      E,(HL)          ; Get second byte of arg name
2417+  13AF E1                  POP     HL              ; Restore code string address
2418+  13B0 CD CB 0F            CALL    TSTNUM          ; Make sure numeric argument
2419+  13B3 CD D1 09            CALL    CHKSYN          ; Make sure ")" follows
2420+  13B6 29                  .BYTE      ")"
2421+  13B7 CD D1 09            CALL    CHKSYN          ; Make sure "=" follows
2422+  13BA B4                  .BYTE      ZEQUAL          ; "=" token
2423+  13BB 44                  LD      B,H             ; Code string address to BC
2424+  13BC 4D                  LD      C,L
2425+  13BD E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2426+  13BE 71                  LD      (HL),C          ; Save LSB of FN code string
2427+  13BF 23                  INC     HL
2428+  13C0 70                  LD      (HL),B          ; Save MSB of FN code string
2429+  13C1 C3 59 14            JP      SVSTAD          ; Save address and do function
2430+  13C4             
2431+  13C4 CD 1A 14    DOFN:   CALL    CHEKFN          ; Make sure FN follows
2432+  13C7 D5                  PUSH    DE              ; Save function pointer address
2433+  13C8 CD 9F 10            CALL    EVLPAR          ; Evaluate expression in "()"
2434+  13CB CD CB 0F            CALL    TSTNUM          ; Make sure numeric result
2435+  13CE E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2436+  13CF 5E                  LD      E,(HL)          ; Get LSB of FN code string
2437+  13D0 23                  INC     HL
2438+  13D1 56                  LD      D,(HL)          ; Get MSB of FN code string
2439+  13D2 23                  INC     HL
2440+  13D3 7A                  LD      A,D             ; And function DEFined?
2441+  13D4 B3                  OR      E
2442+  13D5 CA 0F 07            JP      Z,UFERR         ; No - ?UF Error
2443+  13D8 7E                  LD      A,(HL)          ; Get LSB of argument address
2444+  13D9 23                  INC     HL
2445+  13DA 66                  LD      H,(HL)          ; Get MSB of argument address
2446+  13DB 6F                  LD      L,A             ; HL = Arg variable address
2447+  13DC E5                  PUSH    HL              ; Save it
2448+  13DD 2A 8E 31            LD      HL,(FNRGNM)     ; Get old argument name
2449+  13E0 E3                  EX      (SP),HL ;       ; Save old , Get new
2450+  13E1 22 8E 31            LD      (FNRGNM),HL     ; Set new argument name
2451+  13E4 2A 92 31            LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2452+  13E7 E5                  PUSH    HL              ; Save it
2453+  13E8 2A 90 31            LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
2454+  13EB E5                  PUSH    HL              ; Save it
2455+  13EC 21 90 31            LD      HL,FNARG        ; HL = Value of argument
2456+  13EF D5                  PUSH    DE              ; Save FN code string address
2457+  13F0 CD 02 1A            CALL    FPTHL           ; Move FPREG to argument
2458+  13F3 E1                  POP     HL              ; Get FN code string address
2459+  13F4 CD C8 0F            CALL    GETNUM          ; Get value from function
2460+  13F7 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2461+  13F8 CD 5B 0B            CALL    GETCHR          ; Get next character
2462+  13FB C2 03 07            JP      NZ,SNERR        ; Bad character in FN - Error
2463+  13FE E1                  POP     HL              ; Get MSB,EXP of old arg
2464+  13FF 22 90 31            LD      (FNARG),HL      ; Restore it
2465+  1402 E1                  POP     HL              ; Get LSB,NLSB of old arg
2466+  1403 22 92 31            LD      (FNARG+2),HL    ; Restore it
2467+  1406 E1                  POP     HL              ; Get name of old arg
2468+  1407 22 8E 31            LD      (FNRGNM),HL     ; Restore it
2469+  140A E1                  POP     HL              ; Restore code string address
2470+  140B C9                  RET
2471+  140C             
2472+  140C E5          IDTEST: PUSH    HL              ; Save code string address
2473+  140D 2A 0C 31            LD      HL,(LINEAT)     ; Get current line number
2474+  1410 23                  INC     HL              ; -1 means direct statement
2475+  1411 7C                  LD      A,H
2476+  1412 B5                  OR      L
2477+  1413 E1                  POP     HL              ; Restore code string address
2478+  1414 C0                  RET     NZ              ; Return if in program
2479+  1415 1E 16               LD      E,ID            ; ?ID Error
2480+  1417 C3 17 07            JP      ERROR
2481+  141A             
2482+  141A CD D1 09    CHEKFN: CALL    CHKSYN          ; Make sure FN follows
2483+  141D A7                  .BYTE      ZFN             ; "FN" token
2484+  141E 3E 80               LD      A,80H
2485+  1420 32 7B 31            LD      (FORFLG),A      ; Flag FN name to find
2486+  1423 B6                  OR      (HL)            ; FN name has bit 7 set
2487+  1424 47                  LD      B,A             ; in first byte of name
2488+  1425 CD C3 11            CALL    GTFNAM          ; Get FN name
2489+  1428 C3 CB 0F            JP      TSTNUM          ; Make sure numeric function
2490+  142B             
2491+  142B CD CB 0F    STR:    CALL    TSTNUM          ; Make sure it's a number
2492+  142E CD 4F 1B            CALL    NUMASC          ; Turn number into text
2493+  1431 CD 5F 14    STR1:   CALL    CRTST           ; Create string entry for it
2494+  1434 CD E4 15            CALL    GSTRCU          ; Current string to pool
2495+  1437 01 3F 16            LD      BC,TOPOOL       ; Save in string pool
2496+  143A C5                  PUSH    BC              ; Save address on stack
2497+  143B             
2498+  143B 7E          SAVSTR: LD      A,(HL)          ; Get string length
2499+  143C 23                  INC     HL
2500+  143D 23                  INC     HL
2501+  143E E5                  PUSH    HL              ; Save pointer to string
2502+  143F CD BA 14            CALL    TESTR           ; See if enough string space
2503+  1442 E1                  POP     HL              ; Restore pointer to string
2504+  1443 4E                  LD      C,(HL)          ; Get LSB of address
2505+  1444 23                  INC     HL
2506+  1445 46                  LD      B,(HL)          ; Get MSB of address
2507+  1446 CD 53 14            CALL    CRTMST          ; Create string entry
2508+  1449 E5                  PUSH    HL              ; Save pointer to MSB of addr
2509+  144A 6F                  LD      L,A             ; Length of string
2510+  144B CD D7 15            CALL    TOSTRA          ; Move to string area
2511+  144E D1                  POP     DE              ; Restore pointer to MSB
2512+  144F C9                  RET
2513+  1450             
2514+  1450 CD BA 14    MKTMST: CALL    TESTR           ; See if enough string space
2515+  1453 21 6F 31    CRTMST: LD      HL,TMPSTR       ; Temporary string
2516+  1456 E5                  PUSH    HL              ; Save it
2517+  1457 77                  LD      (HL),A          ; Save length of string
2518+  1458 23                  INC     HL
2519+  1459 23          SVSTAD: INC     HL
2520+  145A 73                  LD      (HL),E          ; Save LSB of address
2521+  145B 23                  INC     HL
2522+  145C 72                  LD      (HL),D          ; Save MSB of address
2523+  145D E1                  POP     HL              ; Restore pointer
2524+  145E C9                  RET
2525+  145F             
2526+  145F 2B          CRTST:  DEC     HL              ; DEC - INCed after
2527+  1460 06 22       QTSTR:  LD      B,'"'           ; Terminating quote
2528+  1462 50                  LD      D,B             ; Quote to D
2529+  1463 E5          DTSTR:  PUSH    HL              ; Save start
2530+  1464 0E FF               LD      C,-1            ; Set counter to -1
2531+  1466 23          QTSTLP: INC     HL              ; Move on
2532+  1467 7E                  LD      A,(HL)          ; Get byte
2533+  1468 0C                  INC     C               ; Count bytes
2534+  1469 B7                  OR      A               ; End of line?
2535+  146A CA 75 14            JP      Z,CRTSTE        ; Yes - Create string entry
2536+  146D BA                  CP      D               ; Terminator D found?
2537+  146E CA 75 14            JP      Z,CRTSTE        ; Yes - Create string entry
2538+  1471 B8                  CP      B               ; Terminator B found?
2539+  1472 C2 66 14            JP      NZ,QTSTLP       ; No - Keep looking
2540+  1475 FE 22       CRTSTE: CP      '"'             ; End with '"'?
2541+  1477 CC 5B 0B            CALL    Z,GETCHR        ; Yes - Get next character
2542+  147A E3                  EX      (SP),HL         ; Starting quote
2543+  147B 23                  INC     HL              ; First byte of string
2544+  147C EB                  EX      DE,HL           ; To DE
2545+  147D 79                  LD      A,C             ; Get length
2546+  147E CD 53 14            CALL    CRTMST          ; Create string entry
2547+  1481 11 6F 31    TSTOPL: LD      DE,TMPSTR       ; Temporary string
2548+  1484 2A 61 31            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2549+  1487 22 94 31            LD      (FPREG),HL      ; Save address of string ptr
2550+  148A 3E 01               LD      A,1
2551+  148C 32 5D 31            LD      (TYPE),A        ; Set type to string
2552+  148F CD 05 1A            CALL    DETHL4          ; Move string to pool
2553+  1492 CD CB 09            CALL    CPDEHL          ; Out of string pool?
2554+  1495 22 61 31            LD      (TMSTPT),HL     ; Save new pointer
2555+  1498 E1                  POP     HL              ; Restore code string address
2556+  1499 7E                  LD      A,(HL)          ; Get next code byte
2557+  149A C0                  RET     NZ              ; Return if pool OK
2558+  149B 1E 1E               LD      E,ST            ; ?ST Error
2559+  149D C3 17 07            JP      ERROR           ; String pool overflow
2560+  14A0             
2561+  14A0 23          PRNUMS: INC     HL              ; Skip leading space
2562+  14A1 CD 5F 14    PRS:    CALL    CRTST           ; Create string entry for it
2563+  14A4 CD E4 15    PRS1:   CALL    GSTRCU          ; Current string to pool
2564+  14A7 CD F9 19            CALL    LOADFP          ; Move string block to BCDE
2565+  14AA 1C                  INC     E               ; Length + 1
2566+  14AB 1D          PRSLP:  DEC     E               ; Count characters
2567+  14AC C8                  RET     Z               ; End of string
2568+  14AD 0A                  LD      A,(BC)          ; Get byte to output
2569+  14AE CD DC 09            CALL    OUTC            ; Output character in A
2570+  14B1 FE 0D               CP      CR              ; Return?
2571+  14B3 CC 0D 0E            CALL    Z,DONULL        ; Yes - Do nulls
2572+  14B6 03                  INC     BC              ; Next byte in string
2573+  14B7 C3 AB 14            JP      PRSLP           ; More characters to output
2574+  14BA             
2575+  14BA B7          TESTR:  OR      A               ; Test if enough room
2576+  14BB 0E                  .BYTE      0EH             ; No garbage collection done
2577+  14BC F1          GRBDON: POP     AF              ; Garbage collection done
2578+  14BD F5                  PUSH    AF              ; Save status
2579+  14BE 2A 0A 31            LD      HL,(STRSPC)     ; Bottom of string space in use
2580+  14C1 EB                  EX      DE,HL           ; To DE
2581+  14C2 2A 73 31            LD      HL,(STRBOT)     ; Bottom of string area
2582+  14C5 2F                  CPL                     ; Negate length (Top down)
2583+  14C6 4F                  LD      C,A             ; -Length to BC
2584+  14C7 06 FF               LD      B,-1            ; BC = -ve length of string
2585+  14C9 09                  ADD     HL,BC           ; Add to bottom of space in use
2586+  14CA 23                  INC     HL              ; Plus one for 2's complement
2587+  14CB CD CB 09            CALL    CPDEHL          ; Below string RAM area?
2588+  14CE DA D8 14            JP      C,TESTOS        ; Tidy up if not done else err
2589+  14D1 22 73 31            LD      (STRBOT),HL     ; Save new bottom of area
2590+  14D4 23                  INC     HL              ; Point to first byte of string
2591+  14D5 EB                  EX      DE,HL           ; Address to DE
2592+  14D6 F1          POPAF:  POP     AF              ; Throw away status push
2593+  14D7 C9                  RET
2594+  14D8             
2595+  14D8 F1          TESTOS: POP     AF              ; Garbage collect been done?
2596+  14D9 1E 1A               LD      E,OS            ; ?OS Error
2597+  14DB CA 17 07            JP      Z,ERROR         ; Yes - Not enough string apace
2598+  14DE BF                  CP      A               ; Flag garbage collect done
2599+  14DF F5                  PUSH    AF              ; Save status
2600+  14E0 01 BC 14            LD      BC,GRBDON       ; Garbage collection done
2601+  14E3 C5                  PUSH    BC              ; Save for RETurn
2602+  14E4 2A 5F 31    GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
2603+  14E7 22 73 31    GARBLP: LD      (STRBOT),HL     ; Reset string pointer
2604+  14EA 21 00 00            LD      HL,0
2605+  14ED E5                  PUSH    HL              ; Flag no string found
2606+  14EE 2A 0A 31            LD      HL,(STRSPC)     ; Get bottom of string space
2607+  14F1 E5                  PUSH    HL              ; Save bottom of string space
2608+  14F2 21 63 31            LD      HL,TMSTPL       ; Temporary string pool
2609+  14F5 EB          GRBLP:  EX      DE,HL
2610+  14F6 2A 61 31            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2611+  14F9 EB                  EX      DE,HL
2612+  14FA CD CB 09            CALL    CPDEHL          ; Temporary string pool done?
2613+  14FD 01 F5 14            LD      BC,GRBLP        ; Loop until string pool done
2614+  1500 C2 49 15            JP      NZ,STPOOL       ; No - See if in string area
2615+  1503 2A 86 31            LD      HL,(PROGND)     ; Start of simple variables
2616+  1506 EB          SMPVAR: EX      DE,HL
2617+  1507 2A 88 31            LD      HL,(VAREND)     ; End of simple variables
2618+  150A EB                  EX      DE,HL
2619+  150B CD CB 09            CALL    CPDEHL          ; All simple strings done?
2620+  150E CA 1C 15            JP      Z,ARRLP         ; Yes - Do string arrays
2621+  1511 7E                  LD      A,(HL)          ; Get type of variable
2622+  1512 23                  INC     HL
2623+  1513 23                  INC     HL
2624+  1514 B7                  OR      A               ; "S" flag set if string
2625+  1515 CD 4C 15            CALL    STRADD          ; See if string in string area
2626+  1518 C3 06 15            JP      SMPVAR          ; Loop until simple ones done
2627+  151B             
2628+  151B C1          GNXARY: POP     BC              ; Scrap address of this array
2629+  151C EB          ARRLP:  EX      DE,HL
2630+  151D 2A 8A 31            LD      HL,(ARREND)     ; End of string arrays
2631+  1520 EB                  EX      DE,HL
2632+  1521 CD CB 09            CALL    CPDEHL          ; All string arrays done?
2633+  1524 CA 72 15            JP      Z,SCNEND        ; Yes - Move string if found
2634+  1527 CD F9 19            CALL    LOADFP          ; Get array name to BCDE
2635+  152A 7B                  LD      A,E             ; Get type of array     
2636+  152B E5                  PUSH    HL              ; Save address of num of dim'ns
2637+  152C 09                  ADD     HL,BC           ; Start of next array
2638+  152D B7                  OR      A               ; Test type of array
2639+  152E F2 1B 15            JP      P,GNXARY        ; Numeric array - Ignore it
2640+  1531 22 75 31            LD      (CUROPR),HL     ; Save address of next array
2641+  1534 E1                  POP     HL              ; Get address of num of dim'ns
2642+  1535 4E                  LD      C,(HL)          ; BC = Number of dimensions
2643+  1536 06 00               LD      B,0
2644+  1538 09                  ADD     HL,BC           ; Two bytes per dimension size
2645+  1539 09                  ADD     HL,BC
2646+  153A 23                  INC     HL              ; Plus one for number of dim'ns
2647+  153B EB          GRBARY: EX      DE,HL
2648+  153C 2A 75 31            LD      HL,(CUROPR)     ; Get address of next array
2649+  153F EB                  EX      DE,HL
2650+  1540 CD CB 09            CALL    CPDEHL          ; Is this array finished?
2651+  1543 CA 1C 15            JP      Z,ARRLP         ; Yes - Get next one
2652+  1546 01 3B 15            LD      BC,GRBARY       ; Loop until array all done
2653+  1549 C5          STPOOL: PUSH    BC              ; Save return address
2654+  154A F6 80               OR      80H             ; Flag string type
2655+  154C 7E          STRADD: LD      A,(HL)          ; Get string length
2656+  154D 23                  INC     HL
2657+  154E 23                  INC     HL
2658+  154F 5E                  LD      E,(HL)          ; Get LSB of string address
2659+  1550 23                  INC     HL
2660+  1551 56                  LD      D,(HL)          ; Get MSB of string address
2661+  1552 23                  INC     HL
2662+  1553 F0                  RET     P               ; Not a string - Return
2663+  1554 B7                  OR      A               ; Set flags on string length
2664+  1555 C8                  RET     Z               ; Null string - Return
2665+  1556 44                  LD      B,H             ; Save variable pointer
2666+  1557 4D                  LD      C,L
2667+  1558 2A 73 31            LD      HL,(STRBOT)     ; Bottom of new area
2668+  155B CD CB 09            CALL    CPDEHL          ; String been done?
2669+  155E 60                  LD      H,B             ; Restore variable pointer
2670+  155F 69                  LD      L,C
2671+  1560 D8                  RET     C               ; String done - Ignore
2672+  1561 E1                  POP     HL              ; Return address
2673+  1562 E3                  EX      (SP),HL         ; Lowest available string area
2674+  1563 CD CB 09            CALL    CPDEHL          ; String within string area?
2675+  1566 E3                  EX      (SP),HL         ; Lowest available string area
2676+  1567 E5                  PUSH    HL              ; Re-save return address
2677+  1568 60                  LD      H,B             ; Restore variable pointer
2678+  1569 69                  LD      L,C
2679+  156A D0                  RET     NC              ; Outside string area - Ignore
2680+  156B C1                  POP     BC              ; Get return , Throw 2 away
2681+  156C F1                  POP     AF              ; 
2682+  156D F1                  POP     AF              ; 
2683+  156E E5                  PUSH    HL              ; Save variable pointer
2684+  156F D5                  PUSH    DE              ; Save address of current
2685+  1570 C5                  PUSH    BC              ; Put back return address
2686+  1571 C9                  RET                     ; Go to it
2687+  1572             
2688+  1572 D1          SCNEND: POP     DE              ; Addresses of strings
2689+  1573 E1                  POP     HL              ; 
2690+  1574 7D                  LD      A,L             ; HL = 0 if no more to do
2691+  1575 B4                  OR      H
2692+  1576 C8                  RET     Z               ; No more to do - Return
2693+  1577 2B                  DEC     HL
2694+  1578 46                  LD      B,(HL)          ; MSB of address of string
2695+  1579 2B                  DEC     HL
2696+  157A 4E                  LD      C,(HL)          ; LSB of address of string
2697+  157B E5                  PUSH    HL              ; Save variable address
2698+  157C 2B                  DEC     HL
2699+  157D 2B                  DEC     HL
2700+  157E 6E                  LD      L,(HL)          ; HL = Length of string
2701+  157F 26 00               LD      H,0
2702+  1581 09                  ADD     HL,BC           ; Address of end of string+1
2703+  1582 50                  LD      D,B             ; String address to DE
2704+  1583 59                  LD      E,C
2705+  1584 2B                  DEC     HL              ; Last byte in string
2706+  1585 44                  LD      B,H             ; Address to BC
2707+  1586 4D                  LD      C,L
2708+  1587 2A 73 31            LD      HL,(STRBOT)     ; Current bottom of string area
2709+  158A CD D2 06            CALL    MOVSTR          ; Move string to new address
2710+  158D E1                  POP     HL              ; Restore variable address
2711+  158E 71                  LD      (HL),C          ; Save new LSB of address
2712+  158F 23                  INC     HL
2713+  1590 70                  LD      (HL),B          ; Save new MSB of address
2714+  1591 69                  LD      L,C             ; Next string area+1 to HL
2715+  1592 60                  LD      H,B
2716+  1593 2B                  DEC     HL              ; Next string area address
2717+  1594 C3 E7 14            JP      GARBLP          ; Look for more strings
2718+  1597             
2719+  1597 C5          CONCAT: PUSH    BC              ; Save prec' opr & code string
2720+  1598 E5                  PUSH    HL              ; 
2721+  1599 2A 94 31            LD      HL,(FPREG)      ; Get first string
2722+  159C E3                  EX      (SP),HL         ; Save first string
2723+  159D CD 51 10            CALL    OPRND           ; Get second string
2724+  15A0 E3                  EX      (SP),HL         ; Restore first string
2725+  15A1 CD CC 0F            CALL    TSTSTR          ; Make sure it's a string
2726+  15A4 7E                  LD      A,(HL)          ; Get length of second string
2727+  15A5 E5                  PUSH    HL              ; Save first string
2728+  15A6 2A 94 31            LD      HL,(FPREG)      ; Get second string
2729+  15A9 E5                  PUSH    HL              ; Save second string
2730+  15AA 86                  ADD     A,(HL)          ; Add length of second string
2731+  15AB 1E 1C               LD      E,LS            ; ?LS Error
2732+  15AD DA 17 07            JP      C,ERROR         ; String too long - Error
2733+  15B0 CD 50 14            CALL    MKTMST          ; Make temporary string
2734+  15B3 D1                  POP     DE              ; Get second string to DE
2735+  15B4 CD E8 15            CALL    GSTRDE          ; Move to string pool if needed
2736+  15B7 E3                  EX      (SP),HL         ; Get first string
2737+  15B8 CD E7 15            CALL    GSTRHL          ; Move to string pool if needed
2738+  15BB E5                  PUSH    HL              ; Save first string
2739+  15BC 2A 71 31            LD      HL,(TMPSTR+2)   ; Temporary string address
2740+  15BF EB                  EX      DE,HL           ; To DE
2741+  15C0 CD CE 15            CALL    SSTSA           ; First string to string area
2742+  15C3 CD CE 15            CALL    SSTSA           ; Second string to string area
2743+  15C6 21 E6 0F            LD      HL,EVAL2        ; Return to evaluation loop
2744+  15C9 E3                  EX      (SP),HL         ; Save return,get code string
2745+  15CA E5                  PUSH    HL              ; Save code string address
2746+  15CB C3 81 14            JP      TSTOPL          ; To temporary string to pool
2747+  15CE             
2748+  15CE E1          SSTSA:  POP     HL              ; Return address
2749+  15CF E3                  EX      (SP),HL         ; Get string block,save return
2750+  15D0 7E                  LD      A,(HL)          ; Get length of string
2751+  15D1 23                  INC     HL
2752+  15D2 23                  INC     HL
2753+  15D3 4E                  LD      C,(HL)          ; Get LSB of string address
2754+  15D4 23                  INC     HL
2755+  15D5 46                  LD      B,(HL)          ; Get MSB of string address
2756+  15D6 6F                  LD      L,A             ; Length to L
2757+  15D7 2C          TOSTRA: INC     L               ; INC - DECed after
2758+  15D8 2D          TSALP:  DEC     L               ; Count bytes moved
2759+  15D9 C8                  RET     Z               ; End of string - Return
2760+  15DA 0A                  LD      A,(BC)          ; Get source
2761+  15DB 12                  LD      (DE),A          ; Save destination
2762+  15DC 03                  INC     BC              ; Next source
2763+  15DD 13                  INC     DE              ; Next destination
2764+  15DE C3 D8 15            JP      TSALP           ; Loop until string moved
2765+  15E1             
2766+  15E1 CD CC 0F    GETSTR: CALL    TSTSTR          ; Make sure it's a string
2767+  15E4 2A 94 31    GSTRCU: LD      HL,(FPREG)      ; Get current string
2768+  15E7 EB          GSTRHL: EX      DE,HL           ; Save DE
2769+  15E8 CD 02 16    GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
2770+  15EB EB                  EX      DE,HL           ; Restore DE
2771+  15EC C0                  RET     NZ              ; No - Return
2772+  15ED D5                  PUSH    DE              ; Save string
2773+  15EE 50                  LD      D,B             ; String block address to DE
2774+  15EF 59                  LD      E,C
2775+  15F0 1B                  DEC     DE              ; Point to length
2776+  15F1 4E                  LD      C,(HL)          ; Get string length
2777+  15F2 2A 73 31            LD      HL,(STRBOT)     ; Current bottom of string area
2778+  15F5 CD CB 09            CALL    CPDEHL          ; Last one in string area?
2779+  15F8 C2 00 16            JP      NZ,POPHL        ; No - Return
2780+  15FB 47                  LD      B,A             ; Clear B (A=0)
2781+  15FC 09                  ADD     HL,BC           ; Remove string from str' area
2782+  15FD 22 73 31            LD      (STRBOT),HL     ; Save new bottom of str' area
2783+  1600 E1          POPHL:  POP     HL              ; Restore string
2784+  1601 C9                  RET
2785+  1602             
2786+  1602 2A 61 31    BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
2787+  1605 2B                  DEC     HL              ; Back
2788+  1606 46                  LD      B,(HL)          ; Get MSB of address
2789+  1607 2B                  DEC     HL              ; Back
2790+  1608 4E                  LD      C,(HL)          ; Get LSB of address
2791+  1609 2B                  DEC     HL              ; Back
2792+  160A 2B                  DEC     HL              ; Back
2793+  160B CD CB 09            CALL    CPDEHL          ; String last in string pool?
2794+  160E C0                  RET     NZ              ; Yes - Leave it
2795+  160F 22 61 31            LD      (TMSTPT),HL     ; Save new string pool top
2796+  1612 C9                  RET
2797+  1613             
2798+  1613 01 92 13    LEN:    LD      BC,PASSA        ; To return integer A
2799+  1616 C5                  PUSH    BC              ; Save address
2800+  1617 CD E1 15    GETLEN: CALL    GETSTR          ; Get string and its length
2801+  161A AF                  XOR     A
2802+  161B 57                  LD      D,A             ; Clear D
2803+  161C 32 5D 31            LD      (TYPE),A        ; Set type to numeric
2804+  161F 7E                  LD      A,(HL)          ; Get length of string
2805+  1620 B7                  OR      A               ; Set status flags
2806+  1621 C9                  RET
2807+  1622             
2808+  1622 01 92 13    ASC:    LD      BC,PASSA        ; To return integer A
2809+  1625 C5                  PUSH    BC              ; Save address
2810+  1626 CD 17 16    GTFLNM: CALL    GETLEN          ; Get length of string
2811+  1629 CA 22 0C            JP      Z,FCERR         ; Null string - Error
2812+  162C 23                  INC     HL
2813+  162D 23                  INC     HL
2814+  162E 5E                  LD      E,(HL)          ; Get LSB of address
2815+  162F 23                  INC     HL
2816+  1630 56                  LD      D,(HL)          ; Get MSB of address
2817+  1631 1A                  LD      A,(DE)          ; Get first byte of string
2818+  1632 C9                  RET
2819+  1633             
2820+  1633 3E 01       CHR:    LD      A,1             ; One character string
2821+  1635 CD 50 14            CALL    MKTMST          ; Make a temporary string
2822+  1638 CD 2C 17            CALL    MAKINT          ; Make it integer A
2823+  163B 2A 71 31            LD      HL,(TMPSTR+2)   ; Get address of string
2824+  163E 73                  LD      (HL),E          ; Save character
2825+  163F C1          TOPOOL: POP     BC              ; Clean up stack
2826+  1640 C3 81 14            JP      TSTOPL          ; Temporary string to pool
2827+  1643             
2828+  1643 CD DC 16    LEFT:   CALL    LFRGNM          ; Get number and ending ")"
2829+  1646 AF                  XOR     A               ; Start at first byte in string
2830+  1647 E3          RIGHT1: EX      (SP),HL         ; Save code string,Get string
2831+  1648 4F                  LD      C,A             ; Starting position in string
2832+  1649 E5          MID1:   PUSH    HL              ; Save string block address
2833+  164A 7E                  LD      A,(HL)          ; Get length of string
2834+  164B B8                  CP      B               ; Compare with number given
2835+  164C DA 51 16            JP      C,ALLFOL        ; All following bytes required
2836+  164F 78                  LD      A,B             ; Get new length
2837+  1650 11                  .BYTE      11H             ; Skip "LD C,0"
2838+  1651 0E 00       ALLFOL: LD      C,0             ; First byte of string
2839+  1653 C5                  PUSH    BC              ; Save position in string
2840+  1654 CD BA 14            CALL    TESTR           ; See if enough string space
2841+  1657 C1                  POP     BC              ; Get position in string
2842+  1658 E1                  POP     HL              ; Restore string block address
2843+  1659 E5                  PUSH    HL              ; And re-save it
2844+  165A 23                  INC     HL
2845+  165B 23                  INC     HL
2846+  165C 46                  LD      B,(HL)          ; Get LSB of address
2847+  165D 23                  INC     HL
2848+  165E 66                  LD      H,(HL)          ; Get MSB of address
2849+  165F 68                  LD      L,B             ; HL = address of string
2850+  1660 06 00               LD      B,0             ; BC = starting address
2851+  1662 09                  ADD     HL,BC           ; Point to that byte
2852+  1663 44                  LD      B,H             ; BC = source string
2853+  1664 4D                  LD      C,L
2854+  1665 CD 53 14            CALL    CRTMST          ; Create a string entry
2855+  1668 6F                  LD      L,A             ; Length of new string
2856+  1669 CD D7 15            CALL    TOSTRA          ; Move string to string area
2857+  166C D1                  POP     DE              ; Clear stack
2858+  166D CD E8 15            CALL    GSTRDE          ; Move to string pool if needed
2859+  1670 C3 81 14            JP      TSTOPL          ; Temporary string to pool
2860+  1673             
2861+  1673 CD DC 16    RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
2862+  1676 D1                  POP     DE              ; Get string length
2863+  1677 D5                  PUSH    DE              ; And re-save
2864+  1678 1A                  LD      A,(DE)          ; Get length
2865+  1679 90                  SUB     B               ; Move back N bytes
2866+  167A C3 47 16            JP      RIGHT1          ; Go and get sub-string
2867+  167D             
2868+  167D EB          MID:    EX      DE,HL           ; Get code string address
2869+  167E 7E                  LD      A,(HL)          ; Get next byte ',' or ")"
2870+  167F CD E1 16            CALL    MIDNUM          ; Get number supplied
2871+  1682 04                  INC     B               ; Is it character zero?
2872+  1683 05                  DEC     B
2873+  1684 CA 22 0C            JP      Z,FCERR         ; Yes - Error
2874+  1687 C5                  PUSH    BC              ; Save starting position
2875+  1688 1E FF               LD      E,255           ; All of string
2876+  168A FE 29               CP      ')'             ; Any length given?
2877+  168C CA 96 16            JP      Z,RSTSTR        ; No - Rest of string
2878+  168F CD D1 09            CALL    CHKSYN          ; Make sure ',' follows
2879+  1692 2C                  .BYTE      ','
2880+  1693 CD 29 17            CALL    GETINT          ; Get integer 0-255
2881+  1696 CD D1 09    RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
2882+  1699 29                  .BYTE      ")"
2883+  169A F1                  POP     AF              ; Restore starting position
2884+  169B E3                  EX      (SP),HL         ; Get string,8ave code string
2885+  169C 01 49 16            LD      BC,MID1         ; Continuation of MID$ routine
2886+  169F C5                  PUSH    BC              ; Save for return
2887+  16A0 3D                  DEC     A               ; Starting position-1
2888+  16A1 BE                  CP      (HL)            ; Compare with length
2889+  16A2 06 00               LD      B,0             ; Zero bytes length
2890+  16A4 D0                  RET     NC              ; Null string if start past end
2891+  16A5 4F                  LD      C,A             ; Save starting position-1
2892+  16A6 7E                  LD      A,(HL)          ; Get length of string
2893+  16A7 91                  SUB     C               ; Subtract start
2894+  16A8 BB                  CP      E               ; Enough string for it?
2895+  16A9 47                  LD      B,A             ; Save maximum length available
2896+  16AA D8                  RET     C               ; Truncate string if needed
2897+  16AB 43                  LD      B,E             ; Set specified length
2898+  16AC C9                  RET                     ; Go and create string
2899+  16AD             
2900+  16AD CD 17 16    VAL:    CALL    GETLEN          ; Get length of string
2901+  16B0 CA CA 17            JP      Z,RESZER        ; Result zero
2902+  16B3 5F                  LD      E,A             ; Save length
2903+  16B4 23                  INC     HL
2904+  16B5 23                  INC     HL
2905+  16B6 7E                  LD      A,(HL)          ; Get LSB of address
2906+  16B7 23                  INC     HL
2907+  16B8 66                  LD      H,(HL)          ; Get MSB of address
2908+  16B9 6F                  LD      L,A             ; HL = String address
2909+  16BA E5                  PUSH    HL              ; Save string address
2910+  16BB 19                  ADD     HL,DE
2911+  16BC 46                  LD      B,(HL)          ; Get end of string+1 byte
2912+  16BD 72                  LD      (HL),D          ; Zero it to terminate
2913+  16BE E3                  EX      (SP),HL         ; Save string end,get start
2914+  16BF C5                  PUSH    BC              ; Save end+1 byte
2915+  16C0 7E                  LD      A,(HL)          ; Get starting byte
2916+  16C1 FE 24           CP	'$'		; Hex number indicated? [function added]
2917+  16C3 C2 CB 16        JP	NZ,VAL1
2918+  16C6 CD F5 1E        CALL	HEXTFP		; Convert Hex to FPREG
2919+  16C9 18 0D           JR	VAL3
2920+  16CB FE 25       VAL1:	CP	'%'		; Binary number indicated? [function added]
2921+  16CD C2 D5 16        JP	NZ,VAL2
2922+  16D0 CD 65 1F        CALL	BINTFP		; Convert Bin to FPREG
2923+  16D3 18 03           JR	VAL3
2924+  16D5 CD B1 1A    VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
2925+  16D8 C1          VAL3:   POP     BC              ; Restore end+1 byte
2926+  16D9 E1                  POP     HL              ; Restore end+1 address
2927+  16DA 70                  LD      (HL),B          ; Put back original byte
2928+  16DB C9                  RET
2929+  16DC             
2930+  16DC EB          LFRGNM: EX      DE,HL           ; Code string address to HL
2931+  16DD CD D1 09            CALL    CHKSYN          ; Make sure ")" follows
2932+  16E0 29                  .BYTE      ")"
2933+  16E1 C1          MIDNUM: POP     BC              ; Get return address
2934+  16E2 D1                  POP     DE              ; Get number supplied
2935+  16E3 C5                  PUSH    BC              ; Re-save return address
2936+  16E4 43                  LD      B,E             ; Number to B
2937+  16E5 C9                  RET
2938+  16E6             
2939+  16E6 CD 2C 17    INP:    CALL    MAKINT          ; Make it integer A
2940+  16E9 32 EF 30            LD      (INPORT),A      ; Set input port
2941+  16EC CD EE 30            CALL    INPSUB          ; Get input from port
2942+  16EF C3 92 13            JP      PASSA           ; Return integer A
2943+  16F2             
2944+  16F2 CD 16 17    POUT:   CALL    SETIO           ; Set up port number
2945+  16F5 C3 B6 30            JP      OUTSUB          ; Output data and return
2946+  16F8             
2947+  16F8 CD 16 17    WAIT:   CALL    SETIO           ; Set up port number
2948+  16FB F5                  PUSH    AF              ; Save AND mask
2949+  16FC 1E 00               LD      E,0             ; Assume zero if none given
2950+  16FE 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2951+  16FF CD 5B 0B            CALL    GETCHR          ; Get next character
2952+  1702 CA 0C 17            JP      Z,NOXOR         ; No XOR byte given
2953+  1705 CD D1 09            CALL    CHKSYN          ; Make sure ',' follows
2954+  1708 2C                  .BYTE      ','
2955+  1709 CD 29 17            CALL    GETINT          ; Get integer 0-255 to XOR with
2956+  170C C1          NOXOR:  POP     BC              ; Restore AND mask
2957+  170D CD EE 30    WAITLP: CALL    INPSUB          ; Get input
2958+  1710 AB                  XOR     E               ; Flip selected bits
2959+  1711 A0                  AND     B               ; Result non-zero?
2960+  1712 CA 0D 17            JP      Z,WAITLP        ; No = keep waiting
2961+  1715 C9                  RET
2962+  1716             
2963+  1716 CD 29 17    SETIO:  CALL    GETINT          ; Get integer 0-255
2964+  1719 32 EF 30            LD      (INPORT),A      ; Set input port
2965+  171C 32 B7 30            LD      (OTPORT),A      ; Set output port
2966+  171F CD D1 09            CALL    CHKSYN          ; Make sure ',' follows
2967+  1722 2C                  .BYTE      ','
2968+  1723 C3 29 17            JP      GETINT          ; Get integer 0-255 and return
2969+  1726             
2970+  1726 CD 5B 0B    FNDNUM: CALL    GETCHR          ; Get next character
2971+  1729 CD C8 0F    GETINT: CALL    GETNUM          ; Get a number from 0 to 255
2972+  172C CD 07 0C    MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
2973+  172F 7A                  LD      A,D             ; Get MSB of number
2974+  1730 B7                  OR      A               ; Zero?
2975+  1731 C2 22 0C            JP      NZ,FCERR        ; No - Error
2976+  1734 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2977+  1735 CD 5B 0B            CALL    GETCHR          ; Get next character
2978+  1738 7B                  LD      A,E             ; Get number to A
2979+  1739 C9                  RET
2980+  173A             
2981+  173A CD 0D 0C    PEEK:   CALL    DEINT           ; Get memory address
2982+  173D 1A                  LD      A,(DE)          ; Get byte in memory
2983+  173E C3 92 13            JP      PASSA           ; Return integer A
2984+  1741             
2985+  1741 CD C8 0F    POKE:   CALL    GETNUM          ; Get memory address
2986+  1744 CD 0D 0C            CALL    DEINT           ; Get integer -32768 to 3276
2987+  1747 D5                  PUSH    DE              ; Save memory address
2988+  1748 CD D1 09            CALL    CHKSYN          ; Make sure ',' follows
2989+  174B 2C                  .BYTE      ','
2990+  174C CD 29 17            CALL    GETINT          ; Get integer 0-255
2991+  174F D1                  POP     DE              ; Restore memory address
2992+  1750 12                  LD      (DE),A          ; Load it into memory
2993+  1751 C9                  RET
2994+  1752             
2995+  1752 21 28 1C    ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
2996+  1755 CD F9 19    ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
2997+  1758 C3 64 17            JP      FPADD           ; Add BCDE to FPREG
2998+  175B             
2999+  175B CD F9 19    SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3000+  175E 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3001+  175F C1          PSUB:   POP     BC              ; Get FP number from stack
3002+  1760 D1                  POP     DE
3003+  1761 CD D3 19    SUBCDE: CALL    INVSGN          ; Negate FPREG
3004+  1764 78          FPADD:  LD      A,B             ; Get FP exponent
3005+  1765 B7                  OR      A               ; Is number zero?
3006+  1766 C8                  RET     Z               ; Yes - Nothing to add
3007+  1767 3A 97 31            LD      A,(FPEXP)       ; Get FPREG exponent
3008+  176A B7                  OR      A               ; Is this number zero?
3009+  176B CA EB 19            JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3010+  176E 90                  SUB     B               ; BCDE number larger?
3011+  176F D2 7E 17            JP      NC,NOSWAP       ; No - Don't swap them
3012+  1772 2F                  CPL                     ; Two's complement
3013+  1773 3C                  INC     A               ;  FP exponent
3014+  1774 EB                  EX      DE,HL
3015+  1775 CD DB 19            CALL    STAKFP          ; Put FPREG on stack
3016+  1778 EB                  EX      DE,HL
3017+  1779 CD EB 19            CALL    FPBCDE          ; Move BCDE to FPREG
3018+  177C C1                  POP     BC              ; Restore number from stack
3019+  177D D1                  POP     DE
3020+  177E FE 19       NOSWAP: CP      24+1            ; Second number insignificant?
3021+  1780 D0                  RET     NC              ; Yes - First number is result
3022+  1781 F5                  PUSH    AF              ; Save number of bits to scale
3023+  1782 CD 10 1A            CALL    SIGNS           ; Set MSBs & sign of result
3024+  1785 67                  LD      H,A             ; Save sign of result
3025+  1786 F1                  POP     AF              ; Restore scaling factor
3026+  1787 CD 29 18            CALL    SCALE           ; Scale BCDE to same exponent
3027+  178A B4                  OR      H               ; Result to be positive?
3028+  178B 21 94 31            LD      HL,FPREG        ; Point to FPREG
3029+  178E F2 A4 17            JP      P,MINCDE        ; No - Subtract FPREG from CDE
3030+  1791 CD 09 18            CALL    PLUCDE          ; Add FPREG to CDE
3031+  1794 D2 EA 17            JP      NC,RONDUP       ; No overflow - Round it up
3032+  1797 23                  INC     HL              ; Point to exponent
3033+  1798 34                  INC     (HL)            ; Increment it
3034+  1799 CA 12 07            JP      Z,OVERR         ; Number overflowed - Error
3035+  179C 2E 01               LD      L,1             ; 1 bit to shift right
3036+  179E CD 3F 18            CALL    SHRT1           ; Shift result right
3037+  17A1 C3 EA 17            JP      RONDUP          ; Round it up
3038+  17A4             
3039+  17A4 AF          MINCDE: XOR     A               ; Clear A and carry
3040+  17A5 90                  SUB     B               ; Negate exponent
3041+  17A6 47                  LD      B,A             ; Re-save exponent
3042+  17A7 7E                  LD      A,(HL)          ; Get LSB of FPREG
3043+  17A8 9B                  SBC     A, E            ; Subtract LSB of BCDE
3044+  17A9 5F                  LD      E,A             ; Save LSB of BCDE
3045+  17AA 23                  INC     HL
3046+  17AB 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3047+  17AC 9A                  SBC     A,D             ; Subtract NMSB of BCDE
3048+  17AD 57                  LD      D,A             ; Save NMSB of BCDE
3049+  17AE 23                  INC     HL
3050+  17AF 7E                  LD      A,(HL)          ; Get MSB of FPREG
3051+  17B0 99                  SBC     A,C             ; Subtract MSB of BCDE
3052+  17B1 4F                  LD      C,A             ; Save MSB of BCDE
3053+  17B2 DC 15 18    CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
3054+  17B5             
3055+  17B5 68          BNORM:  LD      L,B             ; L = Exponent
3056+  17B6 63                  LD      H,E             ; H = LSB
3057+  17B7 AF                  XOR     A
3058+  17B8 47          BNRMLP: LD      B,A             ; Save bit count
3059+  17B9 79                  LD      A,C             ; Get MSB
3060+  17BA B7                  OR      A               ; Is it zero?
3061+  17BB C2 D7 17            JP      NZ,PNORM        ; No - Do it bit at a time
3062+  17BE 4A                  LD      C,D             ; MSB = NMSB
3063+  17BF 54                  LD      D,H             ; NMSB= LSB
3064+  17C0 65                  LD      H,L             ; LSB = VLSB
3065+  17C1 6F                  LD      L,A             ; VLSB= 0
3066+  17C2 78                  LD      A,B             ; Get exponent
3067+  17C3 D6 08               SUB     8               ; Count 8 bits
3068+  17C5 FE E0               CP      -24-8           ; Was number zero?
3069+  17C7 C2 B8 17            JP      NZ,BNRMLP       ; No - Keep normalising
3070+  17CA AF          RESZER: XOR     A               ; Result is zero
3071+  17CB 32 97 31    SAVEXP: LD      (FPEXP),A       ; Save result as zero
3072+  17CE C9                  RET
3073+  17CF             
3074+  17CF 05          NORMAL: DEC     B               ; Count bits
3075+  17D0 29                  ADD     HL,HL           ; Shift HL left
3076+  17D1 7A                  LD      A,D             ; Get NMSB
3077+  17D2 17                  RLA                     ; Shift left with last bit
3078+  17D3 57                  LD      D,A             ; Save NMSB
3079+  17D4 79                  LD      A,C             ; Get MSB
3080+  17D5 8F                  ADC     A,A             ; Shift left with last bit
3081+  17D6 4F                  LD      C,A             ; Save MSB
3082+  17D7 F2 CF 17    PNORM:  JP      P,NORMAL        ; Not done - Keep going
3083+  17DA 78                  LD      A,B             ; Number of bits shifted
3084+  17DB 5C                  LD      E,H             ; Save HL in EB
3085+  17DC 45                  LD      B,L
3086+  17DD B7                  OR      A               ; Any shifting done?
3087+  17DE CA EA 17            JP      Z,RONDUP        ; No - Round it up
3088+  17E1 21 97 31            LD      HL,FPEXP        ; Point to exponent
3089+  17E4 86                  ADD     A,(HL)          ; Add shifted bits
3090+  17E5 77                  LD      (HL),A          ; Re-save exponent
3091+  17E6 D2 CA 17            JP      NC,RESZER       ; Underflow - Result is zero
3092+  17E9 C8                  RET     Z               ; Result is zero
3093+  17EA 78          RONDUP: LD      A,B             ; Get VLSB of number
3094+  17EB 21 97 31    RONDB:  LD      HL,FPEXP        ; Point to exponent
3095+  17EE B7                  OR      A               ; Any rounding?
3096+  17EF FC FC 17            CALL    M,FPROND        ; Yes - Round number up
3097+  17F2 46                  LD      B,(HL)          ; B = Exponent
3098+  17F3 23                  INC     HL
3099+  17F4 7E                  LD      A,(HL)          ; Get sign of result
3100+  17F5 E6 80               AND     10000000B       ; Only bit 7 needed
3101+  17F7 A9                  XOR     C               ; Set correct sign
3102+  17F8 4F                  LD      C,A             ; Save correct sign in number
3103+  17F9 C3 EB 19            JP      FPBCDE          ; Move BCDE to FPREG
3104+  17FC             
3105+  17FC 1C          FPROND: INC     E               ; Round LSB
3106+  17FD C0                  RET     NZ              ; Return if ok
3107+  17FE 14                  INC     D               ; Round NMSB
3108+  17FF C0                  RET     NZ              ; Return if ok
3109+  1800 0C                  INC     C               ; Round MSB
3110+  1801 C0                  RET     NZ              ; Return if ok
3111+  1802 0E 80               LD      C,80H           ; Set normal value
3112+  1804 34                  INC     (HL)            ; Increment exponent
3113+  1805 C0                  RET     NZ              ; Return if ok
3114+  1806 C3 12 07            JP      OVERR           ; Overflow error
3115+  1809             
3116+  1809 7E          PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
3117+  180A 83                  ADD     A,E             ; Add LSB of BCDE
3118+  180B 5F                  LD      E,A             ; Save LSB of BCDE
3119+  180C 23                  INC     HL
3120+  180D 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3121+  180E 8A                  ADC     A,D             ; Add NMSB of BCDE
3122+  180F 57                  LD      D,A             ; Save NMSB of BCDE
3123+  1810 23                  INC     HL
3124+  1811 7E                  LD      A,(HL)          ; Get MSB of FPREG
3125+  1812 89                  ADC     A,C             ; Add MSB of BCDE
3126+  1813 4F                  LD      C,A             ; Save MSB of BCDE
3127+  1814 C9                  RET
3128+  1815             
3129+  1815 21 98 31    COMPL:  LD      HL,SGNRES       ; Sign of result
3130+  1818 7E                  LD      A,(HL)          ; Get sign of result
3131+  1819 2F                  CPL                     ; Negate it
3132+  181A 77                  LD      (HL),A          ; Put it back
3133+  181B AF                  XOR     A
3134+  181C 6F                  LD      L,A             ; Set L to zero
3135+  181D 90                  SUB     B               ; Negate exponent,set carry
3136+  181E 47                  LD      B,A             ; Re-save exponent
3137+  181F 7D                  LD      A,L             ; Load zero
3138+  1820 9B                  SBC     A,E             ; Negate LSB
3139+  1821 5F                  LD      E,A             ; Re-save LSB
3140+  1822 7D                  LD      A,L             ; Load zero
3141+  1823 9A                  SBC     A,D             ; Negate NMSB
3142+  1824 57                  LD      D,A             ; Re-save NMSB
3143+  1825 7D                  LD      A,L             ; Load zero
3144+  1826 99                  SBC     A,C             ; Negate MSB
3145+  1827 4F                  LD      C,A             ; Re-save MSB
3146+  1828 C9                  RET
3147+  1829             
3148+  1829 06 00       SCALE:  LD      B,0             ; Clear underflow
3149+  182B D6 08       SCALLP: SUB     8               ; 8 bits (a whole byte)?
3150+  182D DA 38 18            JP      C,SHRITE        ; No - Shift right A bits
3151+  1830 43                  LD      B,E             ; <- Shift
3152+  1831 5A                  LD      E,D             ; <- right
3153+  1832 51                  LD      D,C             ; <- eight
3154+  1833 0E 00               LD      C,0             ; <- bits
3155+  1835 C3 2B 18            JP      SCALLP          ; More bits to shift
3156+  1838             
3157+  1838 C6 09       SHRITE: ADD     A,8+1           ; Adjust count
3158+  183A 6F                  LD      L,A             ; Save bits to shift
3159+  183B AF          SHRLP:  XOR     A               ; Flag for all done
3160+  183C 2D                  DEC     L               ; All shifting done?
3161+  183D C8                  RET     Z               ; Yes - Return
3162+  183E 79                  LD      A,C             ; Get MSB
3163+  183F 1F          SHRT1:  RRA                     ; Shift it right
3164+  1840 4F                  LD      C,A             ; Re-save
3165+  1841 7A                  LD      A,D             ; Get NMSB
3166+  1842 1F                  RRA                     ; Shift right with last bit
3167+  1843 57                  LD      D,A             ; Re-save it
3168+  1844 7B                  LD      A,E             ; Get LSB
3169+  1845 1F                  RRA                     ; Shift right with last bit
3170+  1846 5F                  LD      E,A             ; Re-save it
3171+  1847 78                  LD      A,B             ; Get underflow
3172+  1848 1F                  RRA                     ; Shift right with last bit
3173+  1849 47                  LD      B,A             ; Re-save underflow
3174+  184A C3 3B 18            JP      SHRLP           ; More bits to do
3175+  184D             
3176+  184D 00 00 00 81 UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
3177+  1851             
3178+  1851 03          LOGTAB: .BYTE      3                       ; Table used by LOG
3179+  1852 AA 56 19 80         .BYTE      0AAH,056H,019H,080H     ; 0.59898
3180+  1856 F1 22 76 80         .BYTE      0F1H,022H,076H,080H     ; 0.96147
3181+  185A 45 AA 38 82         .BYTE      045H,0AAH,038H,082H     ; 2.88539
3182+  185E             
3183+  185E CD AA 19    LOG:    CALL    TSTSGN          ; Test sign of value
3184+  1861 B7                  OR      A
3185+  1862 EA 22 0C            JP      PE,FCERR        ; ?FC Error if <= zero
3186+  1865 21 97 31            LD      HL,FPEXP        ; Point to exponent
3187+  1868 7E                  LD      A,(HL)          ; Get exponent
3188+  1869 01 35 80            LD      BC,8035H        ; BCDE = SQR(1/2)
3189+  186C 11 F3 04            LD      DE,04F3H
3190+  186F 90                  SUB     B               ; Scale value to be < 1
3191+  1870 F5                  PUSH    AF              ; Save scale factor
3192+  1871 70                  LD      (HL),B          ; Save new exponent
3193+  1872 D5                  PUSH    DE              ; Save SQR(1/2)
3194+  1873 C5                  PUSH    BC
3195+  1874 CD 64 17            CALL    FPADD           ; Add SQR(1/2) to value
3196+  1877 C1                  POP     BC              ; Restore SQR(1/2)
3197+  1878 D1                  POP     DE
3198+  1879 04                  INC     B               ; Make it SQR(2)
3199+  187A CD 00 19            CALL    DVBCDE          ; Divide by SQR(2)
3200+  187D 21 4D 18            LD      HL,UNITY        ; Point to 1.
3201+  1880 CD 5B 17            CALL    SUBPHL          ; Subtract FPREG from 1
3202+  1883 21 51 18            LD      HL,LOGTAB       ; Coefficient table
3203+  1886 CD F2 1C            CALL    SUMSER          ; Evaluate sum of series
3204+  1889 01 80 80            LD      BC,8080H        ; BCDE = -0.5
3205+  188C 11 00 00            LD      DE,0000H
3206+  188F CD 64 17            CALL    FPADD           ; Subtract 0.5 from FPREG
3207+  1892 F1                  POP     AF              ; Restore scale factor
3208+  1893 CD 25 1B            CALL    RSCALE          ; Re-scale number
3209+  1896 01 31 80    MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3210+  1899 11 18 72            LD      DE,7218H
3211+  189C 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3212+  189D             
3213+  189D C1          MULT:   POP     BC              ; Get number from stack
3214+  189E D1                  POP     DE
3215+  189F CD AA 19    FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3216+  18A2 C8                  RET     Z               ; Return zero if zero
3217+  18A3 2E 00               LD      L,0             ; Flag add exponents
3218+  18A5 CD 68 19            CALL    ADDEXP          ; Add exponents
3219+  18A8 79                  LD      A,C             ; Get MSB of multiplier
3220+  18A9 32 A6 31            LD      (MULVAL),A      ; Save MSB of multiplier
3221+  18AC EB                  EX      DE,HL
3222+  18AD 22 A7 31            LD      (MULVAL+1),HL   ; Save rest of multiplier
3223+  18B0 01 00 00            LD      BC,0            ; Partial product (BCDE) = zero
3224+  18B3 50                  LD      D,B
3225+  18B4 58                  LD      E,B
3226+  18B5 21 B5 17            LD      HL,BNORM        ; Address of normalise
3227+  18B8 E5                  PUSH    HL              ; Save for return
3228+  18B9 21 C1 18            LD      HL,MULT8        ; Address of 8 bit multiply
3229+  18BC E5                  PUSH    HL              ; Save for NMSB,MSB
3230+  18BD E5                  PUSH    HL              ; 
3231+  18BE 21 94 31            LD      HL,FPREG        ; Point to number
3232+  18C1 7E          MULT8:  LD      A,(HL)          ; Get LSB of number
3233+  18C2 23                  INC     HL              ; Point to NMSB
3234+  18C3 B7                  OR      A               ; Test LSB
3235+  18C4 CA ED 18            JP      Z,BYTSFT        ; Zero - shift to next byte
3236+  18C7 E5                  PUSH    HL              ; Save address of number
3237+  18C8 2E 08               LD      L,8             ; 8 bits to multiply by
3238+  18CA 1F          MUL8LP: RRA                     ; Shift LSB right
3239+  18CB 67                  LD      H,A             ; Save LSB
3240+  18CC 79                  LD      A,C             ; Get MSB
3241+  18CD D2 DB 18            JP      NC,NOMADD       ; Bit was zero - Don't add
3242+  18D0 E5                  PUSH    HL              ; Save LSB and count
3243+  18D1 2A A7 31            LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3244+  18D4 19                  ADD     HL,DE           ; Add NMSB and LSB
3245+  18D5 EB                  EX      DE,HL           ; Leave sum in DE
3246+  18D6 E1                  POP     HL              ; Restore MSB and count
3247+  18D7 3A A6 31            LD      A,(MULVAL)      ; Get MSB of multiplier
3248+  18DA 89                  ADC     A,C             ; Add MSB
3249+  18DB 1F          NOMADD: RRA                     ; Shift MSB right
3250+  18DC 4F                  LD      C,A             ; Re-save MSB
3251+  18DD 7A                  LD      A,D             ; Get NMSB
3252+  18DE 1F                  RRA                     ; Shift NMSB right
3253+  18DF 57                  LD      D,A             ; Re-save NMSB
3254+  18E0 7B                  LD      A,E             ; Get LSB
3255+  18E1 1F                  RRA                     ; Shift LSB right
3256+  18E2 5F                  LD      E,A             ; Re-save LSB
3257+  18E3 78                  LD      A,B             ; Get VLSB
3258+  18E4 1F                  RRA                     ; Shift VLSB right
3259+  18E5 47                  LD      B,A             ; Re-save VLSB
3260+  18E6 2D                  DEC     L               ; Count bits multiplied
3261+  18E7 7C                  LD      A,H             ; Get LSB of multiplier
3262+  18E8 C2 CA 18            JP      NZ,MUL8LP       ; More - Do it
3263+  18EB E1          POPHRT: POP     HL              ; Restore address of number
3264+  18EC C9                  RET
3265+  18ED             
3266+  18ED 43          BYTSFT: LD      B,E             ; Shift partial product left
3267+  18EE 5A                  LD      E,D
3268+  18EF 51                  LD      D,C
3269+  18F0 4F                  LD      C,A
3270+  18F1 C9                  RET
3271+  18F2             
3272+  18F2 CD DB 19    DIV10:  CALL    STAKFP          ; Save FPREG on stack
3273+  18F5 01 20 84            LD      BC,8420H        ; BCDE = 10.
3274+  18F8 11 00 00            LD      DE,0000H
3275+  18FB CD EB 19            CALL    FPBCDE          ; Move 10 to FPREG
3276+  18FE             
3277+  18FE C1          DIV:    POP     BC              ; Get number from stack
3278+  18FF D1                  POP     DE
3279+  1900 CD AA 19    DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
3280+  1903 CA 06 07            JP      Z,DZERR         ; Error if division by zero
3281+  1906 2E FF               LD      L,-1            ; Flag subtract exponents
3282+  1908 CD 68 19            CALL    ADDEXP          ; Subtract exponents
3283+  190B 34                  INC     (HL)            ; Add 2 to exponent to adjust
3284+  190C 34                  INC     (HL)
3285+  190D 2B                  DEC     HL              ; Point to MSB
3286+  190E 7E                  LD      A,(HL)          ; Get MSB of dividend
3287+  190F 32 C2 30            LD      (DIV3),A        ; Save for subtraction
3288+  1912 2B                  DEC     HL
3289+  1913 7E                  LD      A,(HL)          ; Get NMSB of dividend
3290+  1914 32 BE 30            LD      (DIV2),A        ; Save for subtraction
3291+  1917 2B                  DEC     HL
3292+  1918 7E                  LD      A,(HL)          ; Get MSB of dividend
3293+  1919 32 BA 30            LD      (DIV1),A        ; Save for subtraction
3294+  191C 41                  LD      B,C             ; Get MSB
3295+  191D EB                  EX      DE,HL           ; NMSB,LSB to HL
3296+  191E AF                  XOR     A
3297+  191F 4F                  LD      C,A             ; Clear MSB of quotient
3298+  1920 57                  LD      D,A             ; Clear NMSB of quotient
3299+  1921 5F                  LD      E,A             ; Clear LSB of quotient
3300+  1922 32 C5 30            LD      (DIV4),A        ; Clear overflow count
3301+  1925 E5          DIVLP:  PUSH    HL              ; Save divisor
3302+  1926 C5                  PUSH    BC
3303+  1927 7D                  LD      A,L             ; Get LSB of number
3304+  1928 CD B9 30            CALL    DIVSUP          ; Subt' divisor from dividend
3305+  192B DE 00               SBC     A,0             ; Count for overflows
3306+  192D 3F                  CCF
3307+  192E D2 38 19            JP      NC,RESDIV       ; Restore divisor if borrow
3308+  1931 32 C5 30            LD      (DIV4),A        ; Re-save overflow count
3309+  1934 F1                  POP     AF              ; Scrap divisor
3310+  1935 F1                  POP     AF
3311+  1936 37                  SCF                     ; Set carry to
3312+  1937 D2                  .BYTE      0D2H            ; Skip "POP BC" and "POP HL"
3313+  1938             
3314+  1938 C1          RESDIV: POP     BC              ; Restore divisor
3315+  1939 E1                  POP     HL
3316+  193A 79                  LD      A,C             ; Get MSB of quotient
3317+  193B 3C                  INC     A
3318+  193C 3D                  DEC     A
3319+  193D 1F                  RRA                     ; Bit 0 to bit 7
3320+  193E FA EB 17            JP      M,RONDB         ; Done - Normalise result
3321+  1941 17                  RLA                     ; Restore carry
3322+  1942 7B                  LD      A,E             ; Get LSB of quotient
3323+  1943 17                  RLA                     ; Double it
3324+  1944 5F                  LD      E,A             ; Put it back
3325+  1945 7A                  LD      A,D             ; Get NMSB of quotient
3326+  1946 17                  RLA                     ; Double it
3327+  1947 57                  LD      D,A             ; Put it back
3328+  1948 79                  LD      A,C             ; Get MSB of quotient
3329+  1949 17                  RLA                     ; Double it
3330+  194A 4F                  LD      C,A             ; Put it back
3331+  194B 29                  ADD     HL,HL           ; Double NMSB,LSB of divisor
3332+  194C 78                  LD      A,B             ; Get MSB of divisor
3333+  194D 17                  RLA                     ; Double it
3334+  194E 47                  LD      B,A             ; Put it back
3335+  194F 3A C5 30            LD      A,(DIV4)        ; Get VLSB of quotient
3336+  1952 17                  RLA                     ; Double it
3337+  1953 32 C5 30            LD      (DIV4),A        ; Put it back
3338+  1956 79                  LD      A,C             ; Get MSB of quotient
3339+  1957 B2                  OR      D               ; Merge NMSB
3340+  1958 B3                  OR      E               ; Merge LSB
3341+  1959 C2 25 19            JP      NZ,DIVLP        ; Not done - Keep dividing
3342+  195C E5                  PUSH    HL              ; Save divisor
3343+  195D 21 97 31            LD      HL,FPEXP        ; Point to exponent
3344+  1960 35                  DEC     (HL)            ; Divide by 2
3345+  1961 E1                  POP     HL              ; Restore divisor
3346+  1962 C2 25 19            JP      NZ,DIVLP        ; Ok - Keep going
3347+  1965 C3 12 07            JP      OVERR           ; Overflow error
3348+  1968             
3349+  1968 78          ADDEXP: LD      A,B             ; Get exponent of dividend
3350+  1969 B7                  OR      A               ; Test it
3351+  196A CA 8C 19            JP      Z,OVTST3        ; Zero - Result zero
3352+  196D 7D                  LD      A,L             ; Get add/subtract flag
3353+  196E 21 97 31            LD      HL,FPEXP        ; Point to exponent
3354+  1971 AE                  XOR     (HL)            ; Add or subtract it
3355+  1972 80                  ADD     A,B             ; Add the other exponent
3356+  1973 47                  LD      B,A             ; Save new exponent
3357+  1974 1F                  RRA                     ; Test exponent for overflow
3358+  1975 A8                  XOR     B
3359+  1976 78                  LD      A,B             ; Get exponent
3360+  1977 F2 8B 19            JP      P,OVTST2        ; Positive - Test for overflow
3361+  197A C6 80               ADD     A,80H           ; Add excess 128
3362+  197C 77                  LD      (HL),A          ; Save new exponent
3363+  197D CA EB 18            JP      Z,POPHRT        ; Zero - Result zero
3364+  1980 CD 10 1A            CALL    SIGNS           ; Set MSBs and sign of result
3365+  1983 77                  LD      (HL),A          ; Save new exponent
3366+  1984 2B                  DEC     HL              ; Point to MSB
3367+  1985 C9                  RET
3368+  1986             
3369+  1986 CD AA 19    OVTST1: CALL    TSTSGN          ; Test sign of FPREG
3370+  1989 2F                  CPL                     ; Invert sign
3371+  198A E1                  POP     HL              ; Clean up stack
3372+  198B B7          OVTST2: OR      A               ; Test if new exponent zero
3373+  198C E1          OVTST3: POP     HL              ; Clear off return address
3374+  198D F2 CA 17            JP      P,RESZER        ; Result zero
3375+  1990 C3 12 07            JP      OVERR           ; Overflow error
3376+  1993             
3377+  1993 CD F6 19    MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
3378+  1996 78                  LD      A,B             ; Get exponent
3379+  1997 B7                  OR      A               ; Is it zero?
3380+  1998 C8                  RET     Z               ; Yes - Result is zero
3381+  1999 C6 02               ADD     A,2             ; Multiply by 4
3382+  199B DA 12 07            JP      C,OVERR         ; Overflow - ?OV Error
3383+  199E 47                  LD      B,A             ; Re-save exponent
3384+  199F CD 64 17            CALL    FPADD           ; Add BCDE to FPREG (Times 5)
3385+  19A2 21 97 31            LD      HL,FPEXP        ; Point to exponent
3386+  19A5 34                  INC     (HL)            ; Double number (Times 10)
3387+  19A6 C0                  RET     NZ              ; Ok - Return
3388+  19A7 C3 12 07            JP      OVERR           ; Overflow error
3389+  19AA             
3390+  19AA 3A 97 31    TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
3391+  19AD B7                  OR      A
3392+  19AE C8                  RET     Z               ; RETurn if number is zero
3393+  19AF 3A 96 31            LD      A,(FPREG+2)     ; Get MSB of FPREG
3394+  19B2 FE                  .BYTE      0FEH            ; Test sign
3395+  19B3 2F          RETREL: CPL                     ; Invert sign
3396+  19B4 17                  RLA                     ; Sign bit to carry
3397+  19B5 9F          FLGDIF: SBC     A,A             ; Carry to all bits of A
3398+  19B6 C0                  RET     NZ              ; Return -1 if negative
3399+  19B7 3C                  INC     A               ; Bump to +1
3400+  19B8 C9                  RET                     ; Positive - Return +1
3401+  19B9             
3402+  19B9 CD AA 19    SGN:    CALL    TSTSGN          ; Test sign of FPREG
3403+  19BC 06 88       FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
3404+  19BE 11 00 00            LD      DE,0            ; Zero NMSB and LSB
3405+  19C1 21 97 31    RETINT: LD      HL,FPEXP        ; Point to exponent
3406+  19C4 4F                  LD      C,A             ; CDE = MSB,NMSB and LSB
3407+  19C5 70                  LD      (HL),B          ; Save exponent
3408+  19C6 06 00               LD      B,0             ; CDE = integer to normalise
3409+  19C8 23                  INC     HL              ; Point to sign of result
3410+  19C9 36 80               LD      (HL),80H        ; Set sign of result
3411+  19CB 17                  RLA                     ; Carry = sign of integer
3412+  19CC C3 B2 17            JP      CONPOS          ; Set sign of result
3413+  19CF             
3414+  19CF CD AA 19    ABS:    CALL    TSTSGN          ; Test sign of FPREG
3415+  19D2 F0                  RET     P               ; Return if positive
3416+  19D3 21 96 31    INVSGN: LD      HL,FPREG+2      ; Point to MSB
3417+  19D6 7E                  LD      A,(HL)          ; Get sign of mantissa
3418+  19D7 EE 80               XOR     80H             ; Invert sign of mantissa
3419+  19D9 77                  LD      (HL),A          ; Re-save sign of mantissa
3420+  19DA C9                  RET
3421+  19DB             
3422+  19DB EB          STAKFP: EX      DE,HL           ; Save code string address
3423+  19DC 2A 94 31            LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3424+  19DF E3                  EX      (SP),HL         ; Stack them,get return
3425+  19E0 E5                  PUSH    HL              ; Re-save return
3426+  19E1 2A 96 31            LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3427+  19E4 E3                  EX      (SP),HL         ; Stack them,get return
3428+  19E5 E5                  PUSH    HL              ; Re-save return
3429+  19E6 EB                  EX      DE,HL           ; Restore code string address
3430+  19E7 C9                  RET
3431+  19E8             
3432+  19E8 CD F9 19    PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
3433+  19EB EB          FPBCDE: EX      DE,HL           ; Save code string address
3434+  19EC 22 94 31            LD      (FPREG),HL      ; Save LSB,NLSB of number
3435+  19EF 60                  LD      H,B             ; Exponent of number
3436+  19F0 69                  LD      L,C             ; MSB of number
3437+  19F1 22 96 31            LD      (FPREG+2),HL    ; Save MSB and exponent
3438+  19F4 EB                  EX      DE,HL           ; Restore code string address
3439+  19F5 C9                  RET
3440+  19F6             
3441+  19F6 21 94 31    BCDEFP: LD      HL,FPREG        ; Point to FPREG
3442+  19F9 5E          LOADFP: LD      E,(HL)          ; Get LSB of number
3443+  19FA 23                  INC     HL
3444+  19FB 56                  LD      D,(HL)          ; Get NMSB of number
3445+  19FC 23                  INC     HL
3446+  19FD 4E                  LD      C,(HL)          ; Get MSB of number
3447+  19FE 23                  INC     HL
3448+  19FF 46                  LD      B,(HL)          ; Get exponent of number
3449+  1A00 23          INCHL:  INC     HL              ; Used for conditional "INC HL"
3450+  1A01 C9                  RET
3451+  1A02             
3452+  1A02 11 94 31    FPTHL:  LD      DE,FPREG        ; Point to FPREG
3453+  1A05 06 04       DETHL4: LD      B,4             ; 4 bytes to move
3454+  1A07 1A          DETHLB: LD      A,(DE)          ; Get source
3455+  1A08 77                  LD      (HL),A          ; Save destination
3456+  1A09 13                  INC     DE              ; Next source
3457+  1A0A 23                  INC     HL              ; Next destination
3458+  1A0B 05                  DEC     B               ; Count bytes
3459+  1A0C C2 07 1A            JP      NZ,DETHLB       ; Loop if more
3460+  1A0F C9                  RET
3461+  1A10             
3462+  1A10 21 96 31    SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
3463+  1A13 7E                  LD      A,(HL)          ; Get MSB
3464+  1A14 07                  RLCA                    ; Old sign to carry
3465+  1A15 37                  SCF                     ; Set MSBit
3466+  1A16 1F                  RRA                     ; Set MSBit of MSB
3467+  1A17 77                  LD      (HL),A          ; Save new MSB
3468+  1A18 3F                  CCF                     ; Complement sign
3469+  1A19 1F                  RRA                     ; Old sign to carry
3470+  1A1A 23                  INC     HL
3471+  1A1B 23                  INC     HL
3472+  1A1C 77                  LD      (HL),A          ; Set sign of result
3473+  1A1D 79                  LD      A,C             ; Get MSB
3474+  1A1E 07                  RLCA                    ; Old sign to carry
3475+  1A1F 37                  SCF                     ; Set MSBit
3476+  1A20 1F                  RRA                     ; Set MSBit of MSB
3477+  1A21 4F                  LD      C,A             ; Save MSB
3478+  1A22 1F                  RRA
3479+  1A23 AE                  XOR     (HL)            ; New sign of result
3480+  1A24 C9                  RET
3481+  1A25             
3482+  1A25 78          CMPNUM: LD      A,B             ; Get exponent of number
3483+  1A26 B7                  OR      A
3484+  1A27 CA AA 19            JP      Z,TSTSGN        ; Zero - Test sign of FPREG
3485+  1A2A 21 B3 19            LD      HL,RETREL       ; Return relation routine
3486+  1A2D E5                  PUSH    HL              ; Save for return
3487+  1A2E CD AA 19            CALL    TSTSGN          ; Test sign of FPREG
3488+  1A31 79                  LD      A,C             ; Get MSB of number
3489+  1A32 C8                  RET     Z               ; FPREG zero - Number's MSB
3490+  1A33 21 96 31            LD      HL,FPREG+2      ; MSB of FPREG
3491+  1A36 AE                  XOR     (HL)            ; Combine signs
3492+  1A37 79                  LD      A,C             ; Get MSB of number
3493+  1A38 F8                  RET     M               ; Exit if signs different
3494+  1A39 CD 3F 1A            CALL    CMPFP           ; Compare FP numbers
3495+  1A3C 1F                  RRA                     ; Get carry to sign
3496+  1A3D A9                  XOR     C               ; Combine with MSB of number
3497+  1A3E C9                  RET
3498+  1A3F             
3499+  1A3F 23          CMPFP:  INC     HL              ; Point to exponent
3500+  1A40 78                  LD      A,B             ; Get exponent
3501+  1A41 BE                  CP      (HL)            ; Compare exponents
3502+  1A42 C0                  RET     NZ              ; Different
3503+  1A43 2B                  DEC     HL              ; Point to MBS
3504+  1A44 79                  LD      A,C             ; Get MSB
3505+  1A45 BE                  CP      (HL)            ; Compare MSBs
3506+  1A46 C0                  RET     NZ              ; Different
3507+  1A47 2B                  DEC     HL              ; Point to NMSB
3508+  1A48 7A                  LD      A,D             ; Get NMSB
3509+  1A49 BE                  CP      (HL)            ; Compare NMSBs
3510+  1A4A C0                  RET     NZ              ; Different
3511+  1A4B 2B                  DEC     HL              ; Point to LSB
3512+  1A4C 7B                  LD      A,E             ; Get LSB
3513+  1A4D 96                  SUB     (HL)            ; Compare LSBs
3514+  1A4E C0                  RET     NZ              ; Different
3515+  1A4F E1                  POP     HL              ; Drop RETurn
3516+  1A50 E1                  POP     HL              ; Drop another RETurn
3517+  1A51 C9                  RET
3518+  1A52             
3519+  1A52 47          FPINT:  LD      B,A             ; <- Move
3520+  1A53 4F                  LD      C,A             ; <- exponent
3521+  1A54 57                  LD      D,A             ; <- to all
3522+  1A55 5F                  LD      E,A             ; <- bits
3523+  1A56 B7                  OR      A               ; Test exponent
3524+  1A57 C8                  RET     Z               ; Zero - Return zero
3525+  1A58 E5                  PUSH    HL              ; Save pointer to number
3526+  1A59 CD F6 19            CALL    BCDEFP          ; Move FPREG to BCDE
3527+  1A5C CD 10 1A            CALL    SIGNS           ; Set MSBs & sign of result
3528+  1A5F AE                  XOR     (HL)            ; Combine with sign of FPREG
3529+  1A60 67                  LD      H,A             ; Save combined signs
3530+  1A61 FC 76 1A            CALL    M,DCBCDE        ; Negative - Decrement BCDE
3531+  1A64 3E 98               LD      A,80H+24        ; 24 bits
3532+  1A66 90                  SUB     B               ; Bits to shift
3533+  1A67 CD 29 18            CALL    SCALE           ; Shift BCDE
3534+  1A6A 7C                  LD      A,H             ; Get combined sign
3535+  1A6B 17                  RLA                     ; Sign to carry
3536+  1A6C DC FC 17            CALL    C,FPROND        ; Negative - Round number up
3537+  1A6F 06 00               LD      B,0             ; Zero exponent
3538+  1A71 DC 15 18            CALL    C,COMPL         ; If negative make positive
3539+  1A74 E1                  POP     HL              ; Restore pointer to number
3540+  1A75 C9                  RET
3541+  1A76             
3542+  1A76 1B          DCBCDE: DEC     DE              ; Decrement BCDE
3543+  1A77 7A                  LD      A,D             ; Test LSBs
3544+  1A78 A3                  AND     E
3545+  1A79 3C                  INC     A
3546+  1A7A C0                  RET     NZ              ; Exit if LSBs not FFFF
3547+  1A7B 0B                  DEC     BC              ; Decrement MSBs
3548+  1A7C C9                  RET
3549+  1A7D             
3550+  1A7D 21 97 31    INT:    LD      HL,FPEXP        ; Point to exponent
3551+  1A80 7E                  LD      A,(HL)          ; Get exponent
3552+  1A81 FE 98               CP      80H+24          ; Integer accuracy only?
3553+  1A83 3A 94 31            LD      A,(FPREG)       ; Get LSB
3554+  1A86 D0                  RET     NC              ; Yes - Already integer
3555+  1A87 7E                  LD      A,(HL)          ; Get exponent
3556+  1A88 CD 52 1A            CALL    FPINT           ; F.P to integer
3557+  1A8B 36 98               LD      (HL),80H+24     ; Save 24 bit integer
3558+  1A8D 7B                  LD      A,E             ; Get LSB of number
3559+  1A8E F5                  PUSH    AF              ; Save LSB
3560+  1A8F 79                  LD      A,C             ; Get MSB of number
3561+  1A90 17                  RLA                     ; Sign to carry
3562+  1A91 CD B2 17            CALL    CONPOS          ; Set sign of result
3563+  1A94 F1                  POP     AF              ; Restore LSB of number
3564+  1A95 C9                  RET
3565+  1A96             
3566+  1A96 21 00 00    MLDEBC: LD      HL,0            ; Clear partial product
3567+  1A99 78                  LD      A,B             ; Test multiplier
3568+  1A9A B1                  OR      C
3569+  1A9B C8                  RET     Z               ; Return zero if zero
3570+  1A9C 3E 10               LD      A,16            ; 16 bits
3571+  1A9E 29          MLDBLP: ADD     HL,HL           ; Shift P.P left
3572+  1A9F DA D6 12            JP      C,BSERR         ; ?BS Error if overflow
3573+  1AA2 EB                  EX      DE,HL
3574+  1AA3 29                  ADD     HL,HL           ; Shift multiplier left
3575+  1AA4 EB                  EX      DE,HL
3576+  1AA5 D2 AC 1A            JP      NC,NOMLAD       ; Bit was zero - No add
3577+  1AA8 09                  ADD     HL,BC           ; Add multiplicand
3578+  1AA9 DA D6 12            JP      C,BSERR         ; ?BS Error if overflow
3579+  1AAC 3D          NOMLAD: DEC     A               ; Count bits
3580+  1AAD C2 9E 1A            JP      NZ,MLDBLP       ; More
3581+  1AB0 C9                  RET
3582+  1AB1             
3583+  1AB1 FE 2D       ASCTFP: CP      '-'             ; Negative?
3584+  1AB3 F5                  PUSH    AF              ; Save it and flags
3585+  1AB4 CA BD 1A            JP      Z,CNVNUM        ; Yes - Convert number
3586+  1AB7 FE 2B               CP      '+'             ; Positive?
3587+  1AB9 CA BD 1A            JP      Z,CNVNUM        ; Yes - Convert number
3588+  1ABC 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
3589+  1ABD CD CA 17    CNVNUM: CALL    RESZER          ; Set result to zero
3590+  1AC0 47                  LD      B,A             ; Digits after point counter
3591+  1AC1 57                  LD      D,A             ; Sign of exponent
3592+  1AC2 5F                  LD      E,A             ; Exponent of ten
3593+  1AC3 2F                  CPL
3594+  1AC4 4F                  LD      C,A             ; Before or after point flag
3595+  1AC5 CD 5B 0B    MANLP:  CALL    GETCHR          ; Get next character
3596+  1AC8 DA 0E 1B            JP      C,ADDIG         ; Digit - Add to number
3597+  1ACB FE 2E               CP      '.'
3598+  1ACD CA E9 1A            JP      Z,DPOINT        ; '.' - Flag point
3599+  1AD0 FE 45               CP      'E'
3600+  1AD2 C2 ED 1A            JP      NZ,CONEXP       ; Not 'E' - Scale number
3601+  1AD5 CD 5B 0B            CALL    GETCHR          ; Get next character
3602+  1AD8 CD 01 11            CALL    SGNEXP          ; Get sign of exponent
3603+  1ADB CD 5B 0B    EXPLP:  CALL    GETCHR          ; Get next character
3604+  1ADE DA 30 1B            JP      C,EDIGIT        ; Digit - Add to exponent
3605+  1AE1 14                  INC     D               ; Is sign negative?
3606+  1AE2 C2 ED 1A            JP      NZ,CONEXP       ; No - Scale number
3607+  1AE5 AF                  XOR     A
3608+  1AE6 93                  SUB     E               ; Negate exponent
3609+  1AE7 5F                  LD      E,A             ; And re-save it
3610+  1AE8 0C                  INC     C               ; Flag end of number
3611+  1AE9 0C          DPOINT: INC     C               ; Flag point passed
3612+  1AEA CA C5 1A            JP      Z,MANLP         ; Zero - Get another digit
3613+  1AED E5          CONEXP: PUSH    HL              ; Save code string address
3614+  1AEE 7B                  LD      A,E             ; Get exponent
3615+  1AEF 90                  SUB     B               ; Subtract digits after point
3616+  1AF0 F4 06 1B    SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
3617+  1AF3 F2 FC 1A            JP      P,ENDCON        ; Positive - All done
3618+  1AF6 F5                  PUSH    AF              ; Save number of times to /10
3619+  1AF7 CD F2 18            CALL    DIV10           ; Divide by 10
3620+  1AFA F1                  POP     AF              ; Restore count
3621+  1AFB 3C                  INC     A               ; Count divides
3622+  1AFC             
3623+  1AFC C2 F0 1A    ENDCON: JP      NZ,SCALMI       ; More to do
3624+  1AFF D1                  POP     DE              ; Restore code string address
3625+  1B00 F1                  POP     AF              ; Restore sign of number
3626+  1B01 CC D3 19            CALL    Z,INVSGN        ; Negative - Negate number
3627+  1B04 EB                  EX      DE,HL           ; Code string address to HL
3628+  1B05 C9                  RET
3629+  1B06             
3630+  1B06 C8          SCALPL: RET     Z               ; Exit if no scaling needed
3631+  1B07 F5          MULTEN: PUSH    AF              ; Save count
3632+  1B08 CD 93 19            CALL    MLSP10          ; Multiply number by 10
3633+  1B0B F1                  POP     AF              ; Restore count
3634+  1B0C 3D                  DEC     A               ; Count multiplies
3635+  1B0D C9                  RET
3636+  1B0E             
3637+  1B0E D5          ADDIG:  PUSH    DE              ; Save sign of exponent
3638+  1B0F 57                  LD      D,A             ; Save digit
3639+  1B10 78                  LD      A,B             ; Get digits after point
3640+  1B11 89                  ADC     A,C             ; Add one if after point
3641+  1B12 47                  LD      B,A             ; Re-save counter
3642+  1B13 C5                  PUSH    BC              ; Save point flags
3643+  1B14 E5                  PUSH    HL              ; Save code string address
3644+  1B15 D5                  PUSH    DE              ; Save digit
3645+  1B16 CD 93 19            CALL    MLSP10          ; Multiply number by 10
3646+  1B19 F1                  POP     AF              ; Restore digit
3647+  1B1A D6 30               SUB     '0'             ; Make it absolute
3648+  1B1C CD 25 1B            CALL    RSCALE          ; Re-scale number
3649+  1B1F E1                  POP     HL              ; Restore code string address
3650+  1B20 C1                  POP     BC              ; Restore point flags
3651+  1B21 D1                  POP     DE              ; Restore sign of exponent
3652+  1B22 C3 C5 1A            JP      MANLP           ; Get another digit
3653+  1B25             
3654+  1B25 CD DB 19    RSCALE: CALL    STAKFP          ; Put number on stack
3655+  1B28 CD BC 19            CALL    FLGREL          ; Digit to add to FPREG
3656+  1B2B C1          PADD:   POP     BC              ; Restore number
3657+  1B2C D1                  POP     DE
3658+  1B2D C3 64 17            JP      FPADD           ; Add BCDE to FPREG and return
3659+  1B30             
3660+  1B30 7B          EDIGIT: LD      A,E             ; Get digit
3661+  1B31 07                  RLCA                    ; Times 2
3662+  1B32 07                  RLCA                    ; Times 4
3663+  1B33 83                  ADD     A,E             ; Times 5
3664+  1B34 07                  RLCA                    ; Times 10
3665+  1B35 86                  ADD     A,(HL)          ; Add next digit
3666+  1B36 D6 30               SUB     '0'             ; Make it absolute
3667+  1B38 5F                  LD      E,A             ; Save new digit
3668+  1B39 C3 DB 1A            JP      EXPLP           ; Look for another digit
3669+  1B3C             
3670+  1B3C E5          LINEIN: PUSH    HL              ; Save code string address
3671+  1B3D 21 9B 06            LD      HL,INMSG        ; Output " in "
3672+  1B40 CD A1 14            CALL    PRS             ; Output string at HL
3673+  1B43 E1                  POP     HL              ; Restore code string address
3674+  1B44 EB          PRNTHL: EX      DE,HL           ; Code string address to DE
3675+  1B45 AF                  XOR     A
3676+  1B46 06 98               LD      B,80H+24        ; 24 bits
3677+  1B48 CD C1 19            CALL    RETINT          ; Return the integer
3678+  1B4B 21 A0 14            LD      HL,PRNUMS       ; Print number string
3679+  1B4E E5                  PUSH    HL              ; Save for return
3680+  1B4F 21 99 31    NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
3681+  1B52 E5                  PUSH    HL              ; Save for return
3682+  1B53 CD AA 19            CALL    TSTSGN          ; Test sign of FPREG
3683+  1B56 36 20               LD      (HL),' '        ; Space at start
3684+  1B58 F2 5D 1B            JP      P,SPCFST        ; Positive - Space to start
3685+  1B5B 36 2D               LD      (HL),'-'        ; '-' sign at start
3686+  1B5D 23          SPCFST: INC     HL              ; First byte of number
3687+  1B5E 36 30               LD      (HL),'0'        ; '0' if zero
3688+  1B60 CA 13 1C            JP      Z,JSTZER        ; Return '0' if zero
3689+  1B63 E5                  PUSH    HL              ; Save buffer address
3690+  1B64 FC D3 19            CALL    M,INVSGN        ; Negate FPREG if negative
3691+  1B67 AF                  XOR     A               ; Zero A
3692+  1B68 F5                  PUSH    AF              ; Save it
3693+  1B69 CD 19 1C            CALL    RNGTST          ; Test number is in range
3694+  1B6C 01 43 91    SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
3695+  1B6F 11 F8 4F            LD      DE,4FF8H
3696+  1B72 CD 25 1A            CALL    CMPNUM          ; Compare numbers
3697+  1B75 B7                  OR      A
3698+  1B76 E2 8A 1B            JP      PO,INRNG        ; > 99999.9 - Sort it out
3699+  1B79 F1                  POP     AF              ; Restore count
3700+  1B7A CD 07 1B            CALL    MULTEN          ; Multiply by ten
3701+  1B7D F5                  PUSH    AF              ; Re-save count
3702+  1B7E C3 6C 1B            JP      SIXDIG          ; Test it again
3703+  1B81             
3704+  1B81 CD F2 18    GTSIXD: CALL    DIV10           ; Divide by 10
3705+  1B84 F1                  POP     AF              ; Get count
3706+  1B85 3C                  INC     A               ; Count divides
3707+  1B86 F5                  PUSH    AF              ; Re-save count
3708+  1B87 CD 19 1C            CALL    RNGTST          ; Test number is in range
3709+  1B8A CD 52 17    INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
3710+  1B8D 3C                  INC     A
3711+  1B8E CD 52 1A            CALL    FPINT           ; F.P to integer
3712+  1B91 CD EB 19            CALL    FPBCDE          ; Move BCDE to FPREG
3713+  1B94 01 06 03            LD      BC,0306H        ; 1E+06 to 1E-03 range
3714+  1B97 F1                  POP     AF              ; Restore count
3715+  1B98 81                  ADD     A,C             ; 6 digits before point
3716+  1B99 3C                  INC     A               ; Add one
3717+  1B9A FA A6 1B            JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
3718+  1B9D FE 08               CP      6+1+1           ; More than 999999 ?
3719+  1B9F D2 A6 1B            JP      NC,MAKNUM       ; Yes - Do it in 'E' form
3720+  1BA2 3C                  INC     A               ; Adjust for exponent
3721+  1BA3 47                  LD      B,A             ; Exponent of number
3722+  1BA4 3E 02               LD      A,2             ; Make it zero after
3723+  1BA6             
3724+  1BA6 3D          MAKNUM: DEC     A               ; Adjust for digits to do
3725+  1BA7 3D                  DEC     A
3726+  1BA8 E1                  POP     HL              ; Restore buffer address
3727+  1BA9 F5                  PUSH    AF              ; Save count
3728+  1BAA 11 2C 1C            LD      DE,POWERS       ; Powers of ten
3729+  1BAD 05                  DEC     B               ; Count digits before point
3730+  1BAE C2 B7 1B            JP      NZ,DIGTXT       ; Not zero - Do number
3731+  1BB1 36 2E               LD      (HL),'.'        ; Save point
3732+  1BB3 23                  INC     HL              ; Move on
3733+  1BB4 36 30               LD      (HL),'0'        ; Save zero
3734+  1BB6 23                  INC     HL              ; Move on
3735+  1BB7 05          DIGTXT: DEC     B               ; Count digits before point
3736+  1BB8 36 2E               LD      (HL),'.'        ; Save point in case
3737+  1BBA CC 00 1A            CALL    Z,INCHL         ; Last digit - move on
3738+  1BBD C5                  PUSH    BC              ; Save digits before point
3739+  1BBE E5                  PUSH    HL              ; Save buffer address
3740+  1BBF D5                  PUSH    DE              ; Save powers of ten
3741+  1BC0 CD F6 19            CALL    BCDEFP          ; Move FPREG to BCDE
3742+  1BC3 E1                  POP     HL              ; Powers of ten table
3743+  1BC4 06 2F               LD      B, '0'-1        ; ASCII '0' - 1
3744+  1BC6 04          TRYAGN: INC     B               ; Count subtractions
3745+  1BC7 7B                  LD      A,E             ; Get LSB
3746+  1BC8 96                  SUB     (HL)            ; Subtract LSB
3747+  1BC9 5F                  LD      E,A             ; Save LSB
3748+  1BCA 23                  INC     HL
3749+  1BCB 7A                  LD      A,D             ; Get NMSB
3750+  1BCC 9E                  SBC     A,(HL)          ; Subtract NMSB
3751+  1BCD 57                  LD      D,A             ; Save NMSB
3752+  1BCE 23                  INC     HL
3753+  1BCF 79                  LD      A,C             ; Get MSB
3754+  1BD0 9E                  SBC     A,(HL)          ; Subtract MSB
3755+  1BD1 4F                  LD      C,A             ; Save MSB
3756+  1BD2 2B                  DEC     HL              ; Point back to start
3757+  1BD3 2B                  DEC     HL
3758+  1BD4 D2 C6 1B            JP      NC,TRYAGN       ; No overflow - Try again
3759+  1BD7 CD 09 18            CALL    PLUCDE          ; Restore number
3760+  1BDA 23                  INC     HL              ; Start of next number
3761+  1BDB CD EB 19            CALL    FPBCDE          ; Move BCDE to FPREG
3762+  1BDE EB                  EX      DE,HL           ; Save point in table
3763+  1BDF E1                  POP     HL              ; Restore buffer address
3764+  1BE0 70                  LD      (HL),B          ; Save digit in buffer
3765+  1BE1 23                  INC     HL              ; And move on
3766+  1BE2 C1                  POP     BC              ; Restore digit count
3767+  1BE3 0D                  DEC     C               ; Count digits
3768+  1BE4 C2 B7 1B            JP      NZ,DIGTXT       ; More - Do them
3769+  1BE7 05                  DEC     B               ; Any decimal part?
3770+  1BE8 CA F7 1B            JP      Z,DOEBIT        ; No - Do 'E' bit
3771+  1BEB 2B          SUPTLZ: DEC     HL              ; Move back through buffer
3772+  1BEC 7E                  LD      A,(HL)          ; Get character
3773+  1BED FE 30               CP      '0'             ; '0' character?
3774+  1BEF CA EB 1B            JP      Z,SUPTLZ        ; Yes - Look back for more
3775+  1BF2 FE 2E               CP      '.'             ; A decimal point?
3776+  1BF4 C4 00 1A            CALL    NZ,INCHL        ; Move back over digit
3777+  1BF7             
3778+  1BF7 F1          DOEBIT: POP     AF              ; Get 'E' flag
3779+  1BF8 CA 16 1C            JP      Z,NOENED        ; No 'E' needed - End buffer
3780+  1BFB 36 45               LD      (HL),'E'        ; Put 'E' in buffer
3781+  1BFD 23                  INC     HL              ; And move on
3782+  1BFE 36 2B               LD      (HL),'+'        ; Put '+' in buffer
3783+  1C00 F2 07 1C            JP      P,OUTEXP        ; Positive - Output exponent
3784+  1C03 36 2D               LD      (HL),'-'        ; Put '-' in buffer
3785+  1C05 2F                  CPL                     ; Negate exponent
3786+  1C06 3C                  INC     A
3787+  1C07 06 2F       OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
3788+  1C09 04          EXPTEN: INC     B               ; Count subtractions
3789+  1C0A D6 0A               SUB     10              ; Tens digit
3790+  1C0C D2 09 1C            JP      NC,EXPTEN       ; More to do
3791+  1C0F C6 3A               ADD     A,'0'+10        ; Restore and make ASCII
3792+  1C11 23                  INC     HL              ; Move on
3793+  1C12 70                  LD      (HL),B          ; Save MSB of exponent
3794+  1C13 23          JSTZER: INC     HL              ;
3795+  1C14 77                  LD      (HL),A          ; Save LSB of exponent
3796+  1C15 23                  INC     HL
3797+  1C16 71          NOENED: LD      (HL),C          ; Mark end of buffer
3798+  1C17 E1                  POP     HL              ; Restore code string address
3799+  1C18 C9                  RET
3800+  1C19             
3801+  1C19 01 74 94    RNGTST: LD      BC,9474H        ; BCDE = 999999.
3802+  1C1C 11 F7 23            LD      DE,23F7H
3803+  1C1F CD 25 1A            CALL    CMPNUM          ; Compare numbers
3804+  1C22 B7                  OR      A
3805+  1C23 E1                  POP     HL              ; Return address to HL
3806+  1C24 E2 81 1B            JP      PO,GTSIXD       ; Too big - Divide by ten
3807+  1C27 E9                  JP      (HL)            ; Otherwise return to caller
3808+  1C28             
3809+  1C28 00 00 00 80 HALF:   .BYTE      00H,00H,00H,80H ; 0.5
3810+  1C2C             
3811+  1C2C A0 86 01    POWERS: .BYTE      0A0H,086H,001H  ; 100000
3812+  1C2F 10 27 00            .BYTE      010H,027H,000H  ;  10000
3813+  1C32 E8 03 00            .BYTE      0E8H,003H,000H  ;   1000
3814+  1C35 64 00 00            .BYTE      064H,000H,000H  ;    100
3815+  1C38 0A 00 00            .BYTE      00AH,000H,000H  ;     10
3816+  1C3B 01 00 00            .BYTE      001H,000H,000H  ;      1
3817+  1C3E             
3818+  1C3E 21 D3 19    NEGAFT: LD  HL,INVSGN           ; Negate result
3819+  1C41 E3                  EX      (SP),HL         ; To be done after caller
3820+  1C42 E9                  JP      (HL)            ; Return to caller
3821+  1C43             
3822+  1C43 CD DB 19    SQR:    CALL    STAKFP          ; Put value on stack
3823+  1C46 21 28 1C            LD      HL,HALF         ; Set power to 1/2
3824+  1C49 CD E8 19            CALL    PHLTFP          ; Move 1/2 to FPREG
3825+  1C4C             
3826+  1C4C C1          POWER:  POP     BC              ; Get base
3827+  1C4D D1                  POP     DE
3828+  1C4E CD AA 19            CALL    TSTSGN          ; Test sign of power
3829+  1C51 78                  LD      A,B             ; Get exponent of base
3830+  1C52 CA 91 1C            JP      Z,EXP           ; Make result 1 if zero
3831+  1C55 F2 5C 1C            JP      P,POWER1        ; Positive base - Ok
3832+  1C58 B7                  OR      A               ; Zero to negative power?
3833+  1C59 CA 06 07            JP      Z,DZERR         ; Yes - ?/0 Error
3834+  1C5C B7          POWER1: OR      A               ; Base zero?
3835+  1C5D CA CB 17            JP      Z,SAVEXP        ; Yes - Return zero
3836+  1C60 D5                  PUSH    DE              ; Save base
3837+  1C61 C5                  PUSH    BC
3838+  1C62 79                  LD      A,C             ; Get MSB of base
3839+  1C63 F6 7F               OR      01111111B       ; Get sign status
3840+  1C65 CD F6 19            CALL    BCDEFP          ; Move power to BCDE
3841+  1C68 F2 79 1C            JP      P,POWER2        ; Positive base - Ok
3842+  1C6B D5                  PUSH    DE              ; Save power
3843+  1C6C C5                  PUSH    BC
3844+  1C6D CD 7D 1A            CALL    INT             ; Get integer of power
3845+  1C70 C1                  POP     BC              ; Restore power
3846+  1C71 D1                  POP     DE
3847+  1C72 F5                  PUSH    AF              ; MSB of base
3848+  1C73 CD 25 1A            CALL    CMPNUM          ; Power an integer?
3849+  1C76 E1                  POP     HL              ; Restore MSB of base
3850+  1C77 7C                  LD      A,H             ; but don't affect flags
3851+  1C78 1F                  RRA                     ; Exponent odd or even?
3852+  1C79 E1          POWER2: POP     HL              ; Restore MSB and exponent
3853+  1C7A 22 96 31            LD      (FPREG+2),HL    ; Save base in FPREG
3854+  1C7D E1                  POP     HL              ; LSBs of base
3855+  1C7E 22 94 31            LD      (FPREG),HL      ; Save in FPREG
3856+  1C81 DC 3E 1C            CALL    C,NEGAFT        ; Odd power - Negate result
3857+  1C84 CC D3 19            CALL    Z,INVSGN        ; Negative base - Negate it
3858+  1C87 D5                  PUSH    DE              ; Save power
3859+  1C88 C5                  PUSH    BC
3860+  1C89 CD 5E 18            CALL    LOG             ; Get LOG of base
3861+  1C8C C1                  POP     BC              ; Restore power
3862+  1C8D D1                  POP     DE
3863+  1C8E CD 9F 18            CALL    FPMULT          ; Multiply LOG by power
3864+  1C91             
3865+  1C91 CD DB 19    EXP:    CALL    STAKFP          ; Put value on stack
3866+  1C94 01 38 81            LD      BC,08138H       ; BCDE = 1/Ln(2)
3867+  1C97 11 3B AA            LD      DE,0AA3BH
3868+  1C9A CD 9F 18            CALL    FPMULT          ; Multiply value by 1/LN(2)
3869+  1C9D 3A 97 31            LD      A,(FPEXP)       ; Get exponent
3870+  1CA0 FE 88               CP      80H+8           ; Is it in range?
3871+  1CA2 D2 86 19            JP      NC,OVTST1       ; No - Test for overflow
3872+  1CA5 CD 7D 1A            CALL    INT             ; Get INT of FPREG
3873+  1CA8 C6 80               ADD     A,80H           ; For excess 128
3874+  1CAA C6 02               ADD     A,2             ; Exponent > 126?
3875+  1CAC DA 86 19            JP      C,OVTST1        ; Yes - Test for overflow
3876+  1CAF F5                  PUSH    AF              ; Save scaling factor
3877+  1CB0 21 4D 18            LD      HL,UNITY        ; Point to 1.
3878+  1CB3 CD 55 17            CALL    ADDPHL          ; Add 1 to FPREG
3879+  1CB6 CD 96 18            CALL    MULLN2          ; Multiply by LN(2)
3880+  1CB9 F1                  POP     AF              ; Restore scaling factor
3881+  1CBA C1                  POP     BC              ; Restore exponent
3882+  1CBB D1                  POP     DE
3883+  1CBC F5                  PUSH    AF              ; Save scaling factor
3884+  1CBD CD 61 17            CALL    SUBCDE          ; Subtract exponent from FPREG
3885+  1CC0 CD D3 19            CALL    INVSGN          ; Negate result
3886+  1CC3 21 D1 1C            LD      HL,EXPTAB       ; Coefficient table
3887+  1CC6 CD 01 1D            CALL    SMSER1          ; Sum the series
3888+  1CC9 11 00 00            LD      DE,0            ; Zero LSBs
3889+  1CCC C1                  POP     BC              ; Scaling factor
3890+  1CCD 4A                  LD      C,D             ; Zero MSB
3891+  1CCE C3 9F 18            JP      FPMULT          ; Scale result to correct value
3892+  1CD1             
3893+  1CD1 08          EXPTAB: .BYTE      8                       ; Table used by EXP
3894+  1CD2 40 2E 94 74         .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
3895+  1CD6 70 4F 2E 77         .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
3896+  1CDA 6E 02 88 7A         .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
3897+  1CDE E6 A0 2A 7C         .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
3898+  1CE2 50 AA AA 7E         .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
3899+  1CE6 FF FF 7F 7F         .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
3900+  1CEA 00 00 80 81         .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
3901+  1CEE 00 00 00 81         .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
3902+  1CF2             
3903+  1CF2 CD DB 19    SUMSER: CALL    STAKFP          ; Put FPREG on stack
3904+  1CF5 11 9D 18            LD      DE,MULT         ; Multiply by "X"
3905+  1CF8 D5                  PUSH    DE              ; To be done after
3906+  1CF9 E5                  PUSH    HL              ; Save address of table
3907+  1CFA CD F6 19            CALL    BCDEFP          ; Move FPREG to BCDE
3908+  1CFD CD 9F 18            CALL    FPMULT          ; Square the value
3909+  1D00 E1                  POP     HL              ; Restore address of table
3910+  1D01 CD DB 19    SMSER1: CALL    STAKFP          ; Put value on stack
3911+  1D04 7E                  LD      A,(HL)          ; Get number of coefficients
3912+  1D05 23                  INC     HL              ; Point to start of table
3913+  1D06 CD E8 19            CALL    PHLTFP          ; Move coefficient to FPREG
3914+  1D09 06                  .BYTE      06H             ; Skip "POP AF"
3915+  1D0A F1          SUMLP:  POP     AF              ; Restore count
3916+  1D0B C1                  POP     BC              ; Restore number
3917+  1D0C D1                  POP     DE
3918+  1D0D 3D                  DEC     A               ; Cont coefficients
3919+  1D0E C8                  RET     Z               ; All done
3920+  1D0F D5                  PUSH    DE              ; Save number
3921+  1D10 C5                  PUSH    BC
3922+  1D11 F5                  PUSH    AF              ; Save count
3923+  1D12 E5                  PUSH    HL              ; Save address in table
3924+  1D13 CD 9F 18            CALL    FPMULT          ; Multiply FPREG by BCDE
3925+  1D16 E1                  POP     HL              ; Restore address in table
3926+  1D17 CD F9 19            CALL    LOADFP          ; Number at HL to BCDE
3927+  1D1A E5                  PUSH    HL              ; Save address in table
3928+  1D1B CD 64 17            CALL    FPADD           ; Add coefficient to FPREG
3929+  1D1E E1                  POP     HL              ; Restore address in table
3930+  1D1F C3 0A 1D            JP      SUMLP           ; More coefficients
3931+  1D22             
3932+  1D22 CD AA 19    RND:    CALL    TSTSGN          ; Test sign of FPREG
3933+  1D25 21 C9 30            LD      HL,SEED+2       ; Random number seed
3934+  1D28 FA 83 1D            JP      M,RESEED        ; Negative - Re-seed
3935+  1D2B 21 EA 30            LD      HL,LSTRND       ; Last random number
3936+  1D2E CD E8 19            CALL    PHLTFP          ; Move last RND to FPREG
3937+  1D31 21 C9 30            LD      HL,SEED+2       ; Random number seed
3938+  1D34 C8                  RET     Z               ; Return if RND(0)
3939+  1D35 86                  ADD     A,(HL)          ; Add (SEED)+2)
3940+  1D36 E6 07               AND     00000111B       ; 0 to 7
3941+  1D38 06 00               LD      B,0
3942+  1D3A 77                  LD      (HL),A          ; Re-save seed
3943+  1D3B 23                  INC     HL              ; Move to coefficient table
3944+  1D3C 87                  ADD     A,A             ; 4 bytes
3945+  1D3D 87                  ADD     A,A             ; per entry
3946+  1D3E 4F                  LD      C,A             ; BC = Offset into table
3947+  1D3F 09                  ADD     HL,BC           ; Point to coefficient
3948+  1D40 CD F9 19            CALL    LOADFP          ; Coefficient to BCDE
3949+  1D43 CD 9F 18            CALL    FPMULT  ;       ; Multiply FPREG by coefficient
3950+  1D46 3A C8 30            LD      A,(SEED+1)      ; Get (SEED+1)
3951+  1D49 3C                  INC     A               ; Add 1
3952+  1D4A E6 03               AND     00000011B       ; 0 to 3
3953+  1D4C 06 00               LD      B,0
3954+  1D4E FE 01               CP      1               ; Is it zero?
3955+  1D50 88                  ADC     A,B             ; Yes - Make it 1
3956+  1D51 32 C8 30            LD      (SEED+1),A      ; Re-save seed
3957+  1D54 21 87 1D            LD      HL,RNDTAB-4     ; Addition table
3958+  1D57 87                  ADD     A,A             ; 4 bytes
3959+  1D58 87                  ADD     A,A             ; per entry
3960+  1D59 4F                  LD      C,A             ; BC = Offset into table
3961+  1D5A 09                  ADD     HL,BC           ; Point to value
3962+  1D5B CD 55 17            CALL    ADDPHL          ; Add value to FPREG
3963+  1D5E CD F6 19    RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
3964+  1D61 7B                  LD      A,E             ; Get LSB
3965+  1D62 59                  LD      E,C             ; LSB = MSB
3966+  1D63 EE 4F               XOR     01001111B       ; Fiddle around
3967+  1D65 4F                  LD      C,A             ; New MSB
3968+  1D66 36 80               LD      (HL),80H        ; Set exponent
3969+  1D68 2B                  DEC     HL              ; Point to MSB
3970+  1D69 46                  LD      B,(HL)          ; Get MSB
3971+  1D6A 36 80               LD      (HL),80H        ; Make value -0.5
3972+  1D6C 21 C7 30            LD      HL,SEED         ; Random number seed
3973+  1D6F 34                  INC     (HL)            ; Count seed
3974+  1D70 7E                  LD      A,(HL)          ; Get seed
3975+  1D71 D6 AB               SUB     171             ; Do it modulo 171
3976+  1D73 C2 7A 1D            JP      NZ,RND2         ; Non-zero - Ok
3977+  1D76 77                  LD      (HL),A          ; Zero seed
3978+  1D77 0C                  INC     C               ; Fillde about
3979+  1D78 15                  DEC     D               ; with the
3980+  1D79 1C                  INC     E               ; number
3981+  1D7A CD B5 17    RND2:   CALL    BNORM           ; Normalise number
3982+  1D7D 21 EA 30            LD      HL,LSTRND       ; Save random number
3983+  1D80 C3 02 1A            JP      FPTHL           ; Move FPREG to last and return
3984+  1D83             
3985+  1D83 77          RESEED: LD      (HL),A          ; Re-seed random numbers
3986+  1D84 2B                  DEC     HL
3987+  1D85 77                  LD      (HL),A
3988+  1D86 2B                  DEC     HL
3989+  1D87 77                  LD      (HL),A
3990+  1D88 C3 5E 1D            JP      RND1            ; Return RND seed
3991+  1D8B             
3992+  1D8B 68 B1 46 68 RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
3993+  1D8F 99 E9 92 69         .BYTE   099H,0E9H,092H,069H
3994+  1D93 10 D1 75 68         .BYTE   010H,0D1H,075H,068H
3995+  1D97             
3996+  1D97 21 E1 1D    COS:    LD      HL,HALFPI       ; Point to PI/2
3997+  1D9A CD 55 17            CALL    ADDPHL          ; Add it to PPREG
3998+  1D9D CD DB 19    SIN:    CALL    STAKFP          ; Put angle on stack
3999+  1DA0 01 49 83            LD      BC,8349H        ; BCDE = 2 PI
4000+  1DA3 11 DB 0F            LD      DE,0FDBH
4001+  1DA6 CD EB 19            CALL    FPBCDE          ; Move 2 PI to FPREG
4002+  1DA9 C1                  POP     BC              ; Restore angle
4003+  1DAA D1                  POP     DE
4004+  1DAB CD 00 19            CALL    DVBCDE          ; Divide angle by 2 PI
4005+  1DAE CD DB 19            CALL    STAKFP          ; Put it on stack
4006+  1DB1 CD 7D 1A            CALL    INT             ; Get INT of result
4007+  1DB4 C1                  POP     BC              ; Restore number
4008+  1DB5 D1                  POP     DE
4009+  1DB6 CD 61 17            CALL    SUBCDE          ; Make it 0 <= value < 1
4010+  1DB9 21 E5 1D            LD      HL,QUARTR       ; Point to 0.25
4011+  1DBC CD 5B 17            CALL    SUBPHL          ; Subtract value from 0.25
4012+  1DBF CD AA 19            CALL    TSTSGN          ; Test sign of value
4013+  1DC2 37                  SCF                     ; Flag positive
4014+  1DC3 F2 CD 1D            JP      P,SIN1          ; Positive - Ok
4015+  1DC6 CD 52 17            CALL    ROUND           ; Add 0.5 to value
4016+  1DC9 CD AA 19            CALL    TSTSGN          ; Test sign of value
4017+  1DCC B7                  OR      A               ; Flag negative
4018+  1DCD F5          SIN1:   PUSH    AF              ; Save sign
4019+  1DCE F4 D3 19            CALL    P,INVSGN        ; Negate value if positive
4020+  1DD1 21 E5 1D            LD      HL,QUARTR       ; Point to 0.25
4021+  1DD4 CD 55 17            CALL    ADDPHL          ; Add 0.25 to value
4022+  1DD7 F1                  POP     AF              ; Restore sign
4023+  1DD8 D4 D3 19            CALL    NC,INVSGN       ; Negative - Make positive
4024+  1DDB 21 E9 1D            LD      HL,SINTAB       ; Coefficient table
4025+  1DDE C3 F2 1C            JP      SUMSER          ; Evaluate sum of series
4026+  1DE1             
4027+  1DE1 DB 0F 49 81 HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
4028+  1DE5             
4029+  1DE5 00 00 00 7F QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
4030+  1DE9             
4031+  1DE9 05          SINTAB: .BYTE   5                       ; Table used by SIN
4032+  1DEA BA D7 1E 86         .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
4033+  1DEE 64 26 99 87         .BYTE   064H,026H,099H,087H     ;-76.575
4034+  1DF2 58 34 23 87         .BYTE   058H,034H,023H,087H     ; 81.602
4035+  1DF6 E0 5D A5 86         .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
4036+  1DFA DA 0F 49 83         .BYTE   0DAH,00FH,049H,083H     ;  6.2832
4037+  1DFE             
4038+  1DFE CD DB 19    TAN:    CALL    STAKFP          ; Put angle on stack
4039+  1E01 CD 9D 1D            CALL    SIN             ; Get SIN of angle
4040+  1E04 C1                  POP     BC              ; Restore angle
4041+  1E05 E1                  POP     HL
4042+  1E06 CD DB 19            CALL    STAKFP          ; Save SIN of angle
4043+  1E09 EB                  EX      DE,HL           ; BCDE = Angle
4044+  1E0A CD EB 19            CALL    FPBCDE          ; Angle to FPREG
4045+  1E0D CD 97 1D            CALL    COS             ; Get COS of angle
4046+  1E10 C3 FE 18            JP      DIV             ; TAN = SIN / COS
4047+  1E13             
4048+  1E13 CD AA 19    ATN:    CALL    TSTSGN          ; Test sign of value
4049+  1E16 FC 3E 1C            CALL    M,NEGAFT        ; Negate result after if -ve
4050+  1E19 FC D3 19            CALL    M,INVSGN        ; Negate value if -ve
4051+  1E1C 3A 97 31            LD      A,(FPEXP)       ; Get exponent
4052+  1E1F FE 81               CP      81H             ; Number less than 1?
4053+  1E21 DA 30 1E            JP      C,ATN1          ; Yes - Get arc tangnt
4054+  1E24 01 00 81            LD      BC,8100H        ; BCDE = 1
4055+  1E27 51                  LD      D,C
4056+  1E28 59                  LD      E,C
4057+  1E29 CD 00 19            CALL    DVBCDE          ; Get reciprocal of number
4058+  1E2C 21 5B 17            LD      HL,SUBPHL       ; Sub angle from PI/2
4059+  1E2F E5                  PUSH    HL              ; Save for angle > 1
4060+  1E30 21 3A 1E    ATN1:   LD      HL,ATNTAB       ; Coefficient table
4061+  1E33 CD F2 1C            CALL    SUMSER          ; Evaluate sum of series
4062+  1E36 21 E1 1D            LD      HL,HALFPI       ; PI/2 - angle in case > 1
4063+  1E39 C9                  RET                     ; Number > 1 - Sub from PI/2
4064+  1E3A             
4065+  1E3A 09          ATNTAB: .BYTE   9                       ; Table used by ATN
4066+  1E3B 4A D7 3B 78         .BYTE   04AH,0D7H,03BH,078H     ; 1/17
4067+  1E3F 02 6E 84 7B         .BYTE   002H,06EH,084H,07BH     ;-1/15
4068+  1E43 FE C1 2F 7C         .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
4069+  1E47 74 31 9A 7D         .BYTE   074H,031H,09AH,07DH     ;-1/11
4070+  1E4B 84 3D 5A 7D         .BYTE   084H,03DH,05AH,07DH     ; 1/9
4071+  1E4F C8 7F 91 7E         .BYTE   0C8H,07FH,091H,07EH     ;-1/7
4072+  1E53 E4 BB 4C 7E         .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
4073+  1E57 6C AA AA 7F         .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
4074+  1E5B 00 00 00 81         .BYTE   000H,000H,000H,081H     ; 1/1
4075+  1E5F             
4076+  1E5F             
4077+  1E5F C9          ARET:   RET                     ; A RETurn instruction
4078+  1E60             
4079+  1E60 D7          GETINP: RST	    10H             ;input a character
4080+  1E61 C9                  RET
4081+  1E62             
4082+  1E62             CLS: 
4083+  1E62 3E 0C               LD      A,CS            ; ASCII Clear screen
4084+  1E64 C3 9C 1F            JP      MONOUT          ; Output character
4085+  1E67             
4086+  1E67 CD 29 17    WIDTH:  CALL    GETINT          ; Get integer 0-255
4087+  1E6A 7B                  LD      A,E             ; Width to A
4088+  1E6B 32 F2 30            LD      (LWIDTH),A      ; Set width
4089+  1E6E C9                  RET
4090+  1E6F             
4091+  1E6F CD C8 0F    LINES:  CALL    GETNUM          ; Get a number
4092+  1E72 CD 0D 0C            CALL    DEINT           ; Get integer -32768 to 32767
4093+  1E75 ED 53 F6 30         LD      (LINESC),DE     ; Set lines counter
4094+  1E79 ED 53 F8 30         LD      (LINESN),DE     ; Set lines number
4095+  1E7D C9                  RET
4096+  1E7E             
4097+  1E7E CD 0D 0C    DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
4098+  1E81 D5                  PUSH    DE              ; Save number
4099+  1E82 E1                  POP     HL              ; Number to HL
4100+  1E83 46                  LD      B,(HL)          ; Get LSB of contents
4101+  1E84 23                  INC     HL
4102+  1E85 7E                  LD      A,(HL)          ; Get MSB of contents
4103+  1E86 C3 83 13            JP      ABPASS          ; Return integer AB
4104+  1E89             
4105+  1E89 CD C8 0F    DOKE:   CALL    GETNUM          ; Get a number
4106+  1E8C CD 0D 0C            CALL    DEINT           ; Get integer -32768 to 32767
4107+  1E8F D5                  PUSH    DE              ; Save address
4108+  1E90 CD D1 09            CALL    CHKSYN          ; Make sure ',' follows
4109+  1E93 2C                  .BYTE      ','
4110+  1E94 CD C8 0F            CALL    GETNUM          ; Get a number
4111+  1E97 CD 0D 0C            CALL    DEINT           ; Get integer -32768 to 32767
4112+  1E9A E3                  EX      (SP),HL         ; Save value,get address
4113+  1E9B 73                  LD      (HL),E          ; Save LSB of value
4114+  1E9C 23                  INC     HL
4115+  1E9D 72                  LD      (HL),D          ; Save MSB of value
4116+  1E9E E1                  POP     HL              ; Restore code string address
4117+  1E9F C9                  RET
4118+  1EA0             
4119+  1EA0             
4120+  1EA0             ; HEX$(nn) Convert 16 bit number to Hexadecimal string
4121+  1EA0             
4122+  1EA0 CD CB 0F    HEX: 	CALL	TSTNUM          ; Verify it's a number
4123+  1EA3 CD 0D 0C            CALL	DEINT           ; Get integer -32768 to 32767
4124+  1EA6 C5                  PUSH	BC              ; Save contents of BC
4125+  1EA7 21 99 31            LD	    HL,PBUFF
4126+  1EAA 7A                  LD	    A,D             ; Get high order into A
4127+  1EAB FE 00               CP      $0
4128+  1EAD 28 0C       		JR      Z,HEX2          ; Skip output if both high digits are zero
4129+  1EAF CD D8 1E            CALL    BYT2ASC         ; Convert D to ASCII
4130+  1EB2 78          		LD      A,B
4131+  1EB3 FE 30       		CP      '0'
4132+  1EB5 28 02       		JR      Z,HEX1          ; Don't store high digit if zero
4133+  1EB7 70                  LD	    (HL),B          ; Store it to PBUFF
4134+  1EB8 23                  INC	    HL              ; Next location
4135+  1EB9 71          HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
4136+  1EBA 23                  INC     HL              ; Next location
4137+  1EBB 7B          HEX2:   LD	    A,E             ; Get lower byte
4138+  1EBC CD D8 1E            CALL    BYT2ASC         ; Convert E to ASCII
4139+  1EBF 7A          		LD      A,D
4140+  1EC0 FE 00               CP      $0
4141+  1EC2 20 05       		JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
4142+  1EC4 78          		LD      A,B
4143+  1EC5 FE 30       		CP      '0'             ; If high digit of lower byte is zero then don't print
4144+  1EC7 28 02       		JR      Z,HEX4
4145+  1EC9 70          HEX3:   LD      (HL),B          ; to PBUFF+2
4146+  1ECA 23                  INC     HL              ; Next location
4147+  1ECB 71          HEX4:   LD      (HL),C          ; to PBUFF+3
4148+  1ECC 23                  INC     HL              ; PBUFF+4 to zero
4149+  1ECD AF                  XOR     A               ; Terminating character
4150+  1ECE 77                  LD      (HL),A          ; Store zero to terminate
4151+  1ECF 23                  INC     HL              ; Make sure PBUFF is terminated
4152+  1ED0 77                  LD      (HL),A          ; Store the double zero there
4153+  1ED1 C1                  POP     BC              ; Get BC back
4154+  1ED2 21 99 31            LD      HL,PBUFF        ; Reset to start of PBUFF
4155+  1ED5 C3 31 14            JP      STR1            ; Convert the PBUFF to a string and return it
4156+  1ED8             
4157+  1ED8 47          BYT2ASC	LD      B,A             ; Save original value
4158+  1ED9 E6 0F               AND     $0F             ; Strip off upper nybble
4159+  1EDB FE 0A               CP      $0A             ; 0-9?
4160+  1EDD 38 02               JR      C,ADD30         ; If A-F, add 7 more
4161+  1EDF C6 07               ADD     A,$07           ; Bring value up to ASCII A-F
4162+  1EE1 C6 30       ADD30	ADD     A,$30           ; And make ASCII
4163+  1EE3 4F                  LD      C,A             ; Save converted char to C
4164+  1EE4 78                  LD      A,B             ; Retrieve original value
4165+  1EE5 0F                  RRCA                    ; and Rotate it right
4166+  1EE6 0F                  RRCA
4167+  1EE7 0F                  RRCA
4168+  1EE8 0F                  RRCA
4169+  1EE9 E6 0F               AND     $0F             ; Mask off upper nybble
4170+  1EEB FE 0A               CP      $0A             ; 0-9? < A hex?
4171+  1EED 38 02               JR      C,ADD301        ; Skip Add 7
4172+  1EEF C6 07               ADD     A,$07           ; Bring it up to ASCII A-F
4173+  1EF1 C6 30       ADD301	ADD     A,$30           ; And make it full ASCII
4174+  1EF3 47                  LD      B,A             ; Store high order byte
4175+  1EF4 C9                  RET	
4176+  1EF5             
4177+  1EF5             ; Convert "&Hnnnn" to FPREG
4178+  1EF5             ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
4179+  1EF5             ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
4180+  1EF5 EB          HEXTFP  EX      DE,HL           ; Move code string pointer to DE
4181+  1EF6 21 00 00            LD      HL,$0000        ; Zero out the value
4182+  1EF9 CD 0E 1F            CALL    GETHEX          ; Check the number for valid hex
4183+  1EFC DA 2E 1F            JP      C,HXERR         ; First value wasn't hex, HX error
4184+  1EFF 18 05               JR      HEXLP1          ; Convert first character
4185+  1F01 CD 0E 1F    HEXLP   CALL    GETHEX          ; Get second and addtional characters
4186+  1F04 38 1F               JR      C,HEXIT         ; Exit if not a hex character
4187+  1F06 29          HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
4188+  1F07 29                  ADD     HL,HL
4189+  1F08 29                  ADD     HL,HL
4190+  1F09 29                  ADD     HL,HL
4191+  1F0A B5                  OR      L               ; Add in D0-D3 into L
4192+  1F0B 6F                  LD      L,A             ; Save new value
4193+  1F0C 18 F3               JR      HEXLP           ; And continue until all hex characters are in
4194+  1F0E             
4195+  1F0E 13          GETHEX  INC     DE              ; Next location
4196+  1F0F 1A                  LD      A,(DE)          ; Load character at pointer
4197+  1F10 FE 20               CP      ' '
4198+  1F12 CA 0E 1F            JP      Z,GETHEX        ; Skip spaces
4199+  1F15 D6 30               SUB     $30             ; Get absolute value
4200+  1F17 D8                  RET     C               ; < "0", error
4201+  1F18 FE 0A               CP      $0A
4202+  1F1A 38 05               JR      C,NOSUB7        ; Is already in the range 0-9
4203+  1F1C D6 07               SUB     $07             ; Reduce to A-F
4204+  1F1E FE 0A               CP      $0A             ; Value should be $0A-$0F at this point
4205+  1F20 D8                  RET     C               ; CY set if was :            ; < = > ? @
4206+  1F21 FE 10       NOSUB7  CP      $10             ; > Greater than "F"?
4207+  1F23 3F                  CCF
4208+  1F24 C9                  RET                     ; CY set if it wasn't valid hex
4209+  1F25                 
4210+  1F25 EB          HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
4211+  1F26 7A                  LD      A,D             ; Load DE into AC
4212+  1F27 4B                  LD      C,E             ; For prep to 
4213+  1F28 E5                  PUSH    HL
4214+  1F29 CD 82 13            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4215+  1F2C E1                  POP     HL
4216+  1F2D C9                  RET
4217+  1F2E             
4218+  1F2E 1E 26       HXERR:  LD      E,HX            ; ?HEX Error
4219+  1F30 C3 17 07            JP      ERROR
4220+  1F33             
4221+  1F33             ; BIN$(NN) Convert integer to a 1-16 char binary string
4222+  1F33 CD CB 0F    BIN:    CALL    TSTNUM          ; Verify it's a number
4223+  1F36 CD 0D 0C            CALL    DEINT           ; Get integer -32768 to 32767
4224+  1F39 C5          BIN2:   PUSH    BC              ; Save contents of BC
4225+  1F3A 21 99 31            LD      HL,PBUFF
4226+  1F3D 06 11               LD      B,17            ; One higher than max char count
4227+  1F3F             ZEROSUP:                        ; Suppress leading zeros
4228+  1F3F 05                  DEC     B               ; Max 16 chars
4229+  1F40 78                  LD      A,B
4230+  1F41 FE 01               CP      $01
4231+  1F43 28 08               JR      Z,BITOUT        ; Always output at least one character
4232+  1F45 CB 13               RL      E
4233+  1F47 CB 12               RL      D
4234+  1F49 30 F4               JR      NC,ZEROSUP
4235+  1F4B 18 04               JR      BITOUT2
4236+  1F4D             BITOUT:      
4237+  1F4D CB 13               RL      E
4238+  1F4F CB 12               RL      D               ; Top bit now in carry
4239+  1F51             BITOUT2:
4240+  1F51 3E 30               LD      A,'0'           ; Char for '0'
4241+  1F53 CE 00               ADC     A,0             ; If carry set then '0' --> '1'
4242+  1F55 77                  LD      (HL),A
4243+  1F56 23                  INC     HL
4244+  1F57 05                  DEC     B
4245+  1F58 20 F3               JR      NZ,BITOUT
4246+  1F5A AF                  XOR     A               ; Terminating character
4247+  1F5B 77                  LD      (HL),A          ; Store zero to terminate
4248+  1F5C 23                  INC     HL              ; Make sure PBUFF is terminated
4249+  1F5D 77                  LD      (HL),A          ; Store the double zero there
4250+  1F5E C1                  POP     BC
4251+  1F5F 21 99 31            LD      HL,PBUFF
4252+  1F62 C3 31 14            JP      STR1
4253+  1F65             
4254+  1F65             ; Convert "&Bnnnn" to FPREG
4255+  1F65             ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
4256+  1F65 EB          BINTFP: EX      DE,HL           ; Move code string pointer to DE
4257+  1F66 21 00 00            LD      HL,$0000        ; Zero out the value
4258+  1F69 CD 82 1F            CALL    CHKBIN          ; Check the number for valid bin
4259+  1F6C DA 90 1F            JP      C,BINERR        ; First value wasn't bin, HX error
4260+  1F6F D6 30       BINIT:  SUB     '0'
4261+  1F71 29                  ADD     HL,HL           ; Rotate HL left
4262+  1F72 B5                  OR      L
4263+  1F73 6F                  LD      L,A
4264+  1F74 CD 82 1F            CALL    CHKBIN          ; Get second and addtional characters
4265+  1F77 30 F6               JR      NC,BINIT        ; Process if a bin character
4266+  1F79 EB                  EX      DE,HL           ; Value into DE, Code string into HL
4267+  1F7A 7A                  LD      A,D             ; Load DE into AC
4268+  1F7B 4B                  LD      C,E             ; For prep to 
4269+  1F7C E5                  PUSH    HL
4270+  1F7D CD 82 13            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4271+  1F80 E1                  POP     HL
4272+  1F81 C9                  RET
4273+  1F82             
4274+  1F82             ; Char is in A, NC if char is 0 or 1
4275+  1F82 13          CHKBIN: INC     DE
4276+  1F83 1A                  LD      A,(DE)
4277+  1F84 FE 20               CP      ' '
4278+  1F86 CA 82 1F            JP      Z,CHKBIN        ; Skip spaces
4279+  1F89 FE 30               CP      '0'             ; Set C if < '0'
4280+  1F8B D8                  RET     C
4281+  1F8C FE 32               CP      '2'
4282+  1F8E 3F                  CCF                     ; Set C if > '1'
4283+  1F8F C9                  RET
4284+  1F90             
4285+  1F90 1E 28       BINERR: LD      E,BN            ; ?BIN Error
4286+  1F92 C3 17 07            JP      ERROR
4287+  1F95             
4288+  1F95             
4289+  1F95             JJUMP1: 
4290+  1F95 DD 21 FF FF         LD      IX,-1           ; Flag cold start
4291+  1F99 C3 67 03            JP      CSTART          ; Go and initialise
4292+  1F9C             
4293+  1F9C             MONOUT: 
4294+  1F9C C3 08 00            JP      $0008           ; output a char
4295+  1F9F             
4296+  1F9F             
4297+  1F9F             MONITR: 
4298+  1F9F C3 00 00            JP      $0000           ; Restart (Normally Monitor Start)
4299+  1FA2             
4300+  1FA2             
4301+  1FA2 3E 00       INITST: LD      A,0             ; Clear break flag
4302+  1FA4 32 FD 30            LD      (BRKFLG),A
4303+  1FA7 C3 6E 03            JP      INIT
4304+  1FAA             
4305+  1FAA ED 45       ARETN:  RETN                    ; Return from NMI
4306+  1FAC             
4307+  1FAC             
4308+  1FAC F5          TSTBIT: PUSH    AF              ; Save bit mask
4309+  1FAD A0                  AND     B               ; Get common bits
4310+  1FAE C1                  POP     BC              ; Restore bit mask
4311+  1FAF B8                  CP      B               ; Same bit set?
4312+  1FB0 3E 00               LD      A,0             ; Return 0 in A
4313+  1FB2 C9                  RET
4314+  1FB3             
4315+  1FB3 CD DC 09    OUTNCR: CALL    OUTC            ; Output character in A
4316+  1FB6 C3 03 0E            JP      PRNTCRLF        ; Output CRLF
4317+  1FB9             
0693   1FB9             .end
tasm: Number of errors = 0
