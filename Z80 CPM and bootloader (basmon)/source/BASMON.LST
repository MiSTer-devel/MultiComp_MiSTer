0001   0000             ;==================================================================================
0002   0000             ; The updates to the original BASIC within this file are copyright Grant Searle
0003   0000             ;
0004   0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0005   0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0006   0000             ;
0007   0000             ; http://searle.hostei.com/grant/index.html
0008   0000             ;
0009   0000             ; eMail: home.micros01@btinternet.com
0010   0000             ;
0011   0000             ; If the above don't work, please perform an Internet search to see if I have
0012   0000             ; updated the web page hosting service.
0013   0000             ;
0014   0000             ;==================================================================================
0015   0000             
0016   0000             
0017   0000             ;==================================================================================
0018   0000             ; Contents of this file are copyright Grant Searle
0019   0000             ; HEX routines from Joel Owens.
0020   0000             ;
0021   0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0022   0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0023   0000             ;
0024   0000             ; http://searle.hostei.com/grant/index.html
0025   0000             ;
0026   0000             ; eMail: home.micros01@btinternet.com
0027   0000             ;
0028   0000             ; If the above don't work, please perform an Internet search to see if I have
0029   0000             ; updated the web page hosting service.
0030   0000             ;
0031   0000             ;==================================================================================
0032   0000             
0033   0000             ;------------------------------------------------------------------------------
0034   0000             ;
0035   0000             ; Z80 Monitor Rom
0036   0000             ;
0037   0000             ;------------------------------------------------------------------------------
0038   0000             ; General Equates
0039   0000             ;------------------------------------------------------------------------------
0040   0000             
0041   0000             ;CR		.EQU	0DH
0042   0000             ;LF		.EQU	0AH
0043   0000             ;ESC		.EQU	1BH
0044   0000             ;CTRLC	.EQU	03H
0045   0000             M_CLS		.EQU	0CH
0046   0000             
0047   0000             
0048   0000             loadAddr	.EQU	0D000h	; CP/M load address
0049   0000             numSecs		.EQU	24	; Number of 512 sectors to be loaded
0050   0000             
0051   0000             
0052   0000             RTS_HIGH	.EQU	0D5H
0053   0000             RTS_LOW		.EQU	095H
0054   0000             
0055   0000             ACIA0_D		.EQU	$81
0056   0000             ACIA0_C		.EQU	$80
0057   0000             ACIA1_D		.EQU	$83
0058   0000             ACIA1_C		.EQU	$82
0059   0000             
0060   0000             SD_DATA		.EQU	088H
0061   0000             SD_CONTROL	.EQU	089H
0062   0000             SD_STATUS	.EQU	089H
0063   0000             SD_LBA0		.EQU	08AH
0064   0000             SD_LBA1		.EQU	08BH
0065   0000             SD_LBA2		.EQU	08CH
0066   0000             
0067   3000             	.ORG	$3000
0068   3000             
0069   3000             primaryIO	.ds	1
0070   3001             secNo		.ds	1
0071   3002             dmaAddr		.ds	2
0072   3004             InitTxtB        .ds     2
0073   3006             
0074   3006 00          lba0		.DB	00h
0075   3007 00          lba1		.DB	00h
0076   3008 00          lba2		.DB	00h
0077   3009 00          lba3		.DB	00h
0078   300A             
0079   300A             stackSpace	.ds	32
0080   302A             M_STACK   	.EQU    $	; Stack top
0081   302A             
0082   302A             
0083   302A             ;------------------------------------------------------------------------------
0084   302A             ;                         START OF MONITOR ROM
0085   302A             ;------------------------------------------------------------------------------
0086   302A             
0087   0000             MON		.ORG	$0000		; MONITOR ROM RESET VECTOR
0088   0000             ;------------------------------------------------------------------------------
0089   0000             ; Reset
0090   0000             ;------------------------------------------------------------------------------
0091   0000 F3          RST00		DI			;Disable INTerrupts
0092   0001 C3 A4 00    		JP	M_INIT		;Initialize Hardware and go
0093   0004 00          		NOP
0094   0005 00          		NOP
0095   0006 00          		NOP
0096   0007 00          		NOP
0097   0008             ;------------------------------------------------------------------------------
0098   0008             ; TX a character over RS232 wait for TXDONE first.
0099   0008             ;------------------------------------------------------------------------------
0100   0008 C3 32 00    RST08		JP	conout
0101   000B 00          		NOP
0102   000C 00          		NOP
0103   000D 00          		NOP
0104   000E 00          		NOP
0105   000F 00          		NOP
0106   0010             ;------------------------------------------------------------------------------
0107   0010             ; RX a character from buffer wait until char ready.
0108   0010             ;------------------------------------------------------------------------------
0109   0010 C3 1B 00    RST10		JP	conin
0110   0013 00          		NOP
0111   0014 00          		NOP
0112   0015 00          		NOP
0113   0016 00          		NOP
0114   0017 00          		NOP
0115   0018             ;------------------------------------------------------------------------------
0116   0018             ; Check input buffer status
0117   0018             ;------------------------------------------------------------------------------
0118   0018 C3 6C 00    RST18		JP	CKINCHAR
0119   001B             
0120   001B             
0121   001B             ;------------------------------------------------------------------------------
0122   001B             ; Console input routine
0123   001B             ; Use the "primaryIO" flag to determine which input port to monitor.
0124   001B             ;------------------------------------------------------------------------------
0125   001B             conin:
0126   001B 3A 00 30    		LD	A,(primaryIO)
0127   001E FE 00       		CP	0
0128   0020 20 08       		JR	NZ,coninB
0129   0022             coninA:
0130   0022             
0131   0022             waitForCharA:
0132   0022 CD 73 00    		call ckincharA
0133   0025 28 FB       		JR	Z, waitForCharA
0134   0027 DB 81       		IN   	A,(ACIA0_D)
0135   0029 C9          		RET	; Char ready in A
0136   002A             
0137   002A             coninB:
0138   002A             
0139   002A             waitForCharB:
0140   002A CD 7A 00    		call ckincharB
0141   002D 28 FB       		JR	Z, waitForCharB
0142   002F DB 83       		IN   	A,(ACIA1_D)
0143   0031 C9          		RET	; Char ready in A
0144   0032             
0145   0032             ;------------------------------------------------------------------------------
0146   0032             ; Console output routine
0147   0032             ; Use the "primaryIO" flag to determine which output port to send a character.
0148   0032             ;------------------------------------------------------------------------------
0149   0032 F5          conout:		PUSH	AF		; Store character
0150   0033 3A 00 30    		LD	A,(primaryIO)
0151   0036 FE 00       		CP	0
0152   0038 20 0D       		JR	NZ,conoutB1
0153   003A 18 01       		JR	conoutA1
0154   003C             conoutA:
0155   003C F5          		PUSH	AF
0156   003D             
0157   003D CD 60 00    conoutA1:	CALL	CKACIA0		; See if ACIA channel A is finished transmitting
0158   0040 28 FB       		JR	Z,conoutA1	; Loop until ACIA flag signals ready
0159   0042 F1          		POP	AF		; RETrieve character
0160   0043 D3 81       		OUT	(ACIA0_D),A	; OUTput the character
0161   0045 C9          		RET
0162   0046             
0163   0046             conoutB:
0164   0046 F5          		PUSH	AF
0165   0047             
0166   0047 CD 66 00    conoutB1:	CALL	CKACIA1		; See if ACIA channel B is finished transmitting
0167   004A 28 FB       		JR	Z,conoutB1	; Loop until ACIA flag signals ready
0168   004C F1          		POP	AF		; RETrieve character
0169   004D D3 83       		OUT	(ACIA1_D),A	; OUTput the character
0170   004F C9          		RET
0171   0050             
0172   0050             ;------------------------------------------------------------------------------
0173   0050             ; Non blocking console output routine
0174   0050             ; On return Z flag is 0, if the character could be written, else 1
0175   0050             ; Use the "primaryIO" flag to determine which output port to send a character.
0176   0050             ;------------------------------------------------------------------------------
0177   0050             nbconoutB:
0178   0050 F5                   	PUSH	AF
0179   0051             
0180   0051 CD 66 00    nbconoutB1:	CALL	CKACIA1		; See if ACIA channel B has finished transmitting
0181   0054 20 04       		JR      NZ, nbconoutB2  ; Ready to write
0182   0056 F1          		POP	AF	        ; Remove the parameter we don't need 
0183   0057 E6 00       	        AND     $00             ; Indicate failure
0184   0059 C9          		RET	        	; Return if ACIA flag signals not ready
0185   005A             nbconoutB2:	
0186   005A F1          	        POP	AF		; RETrieve character
0187   005B D3 83       		OUT	(ACIA1_D),A	; OUTput the character
0188   005D F6 FF       	        OR      $ff             ; Indicate success
0189   005F C9          		RET
0190   0060             
0191   0060             ;------------------------------------------------------------------------------
0192   0060             ; I/O status check routine
0193   0060             ; Use the "primaryIO" flag to determine which port to check.
0194   0060             ;------------------------------------------------------------------------------
0195   0060             CKACIA0
0196   0060 DB 80       		IN   	A,(ACIA0_C)	; Status byte D1=TX Buff Empty, D0=RX char ready	
0197   0062 0F          		RRCA			; Rotates RX status into Carry Flag,	
0198   0063 CB 47       		BIT  	0,A		; Set Zero flag if still transmitting character	
0199   0065 C9                  RET
0200   0066             
0201   0066             CKACIA1
0202   0066 DB 82       		IN   	A,(ACIA1_C)	; Status byte D1=TX Buff Empty, D0=RX char ready	
0203   0068 0F          		RRCA			; Rotates RX status into Carry Flag,	
0204   0069 CB 47       		BIT  	0,A		; Set Zero flag if still transmitting character	
0205   006B C9                  RET
0206   006C             
0207   006C             ;------------------------------------------------------------------------------
0208   006C             ; Check if there is a character in the input buffer
0209   006C             ; Use the "primaryIO" flag to determine which port to check.
0210   006C             ;------------------------------------------------------------------------------
0211   006C             CKINCHAR
0212   006C 3A 00 30    		LD	A,(primaryIO)
0213   006F FE 00       		CP	0
0214   0071 20 07       		JR	NZ,ckincharB
0215   0073             
0216   0073             ckincharA:
0217   0073             
0218   0073 DB 80       		IN   A,(ACIA0_C)		; Status byte
0219   0075 E6 01       		AND  $01
0220   0077 FE 00       		CP   $0			; Z flag set if no char
0221   0079 C9          		RET
0222   007A             
0223   007A             ckincharB:
0224   007A             
0225   007A DB 82       		IN   A,(ACIA1_C)		; Status byte
0226   007C E6 01       		AND  $01
0227   007E FE 00       		CP   $0			; Z flag set if no char
0228   0080 C9          		RET
0229   0081             
0230   0081             ;------------------------------------------------------------------------------
0231   0081             ; Filtered Character I/O
0232   0081             ;------------------------------------------------------------------------------
0233   0081             
0234   0081 D7          RDCHR		RST	10H
0235   0082 FE 0A       		CP	LF
0236   0084 28 FB       		JR	Z,RDCHR		; Ignore LF
0237   0086 FE 1B       		CP	ESC
0238   0088 20 02       		JR	NZ,RDCHR1
0239   008A 3E 03       		LD	A,CTRLC		; Change ESC to CTRL-C
0240   008C C9          RDCHR1		RET
0241   008D             
0242   008D FE 0D       WRCHR		CP	CR
0243   008F 28 0A       		JR	Z,WRCRLF	; When CR, write CRLF
0244   0091 FE 0C       		CP	M_CLS
0245   0093 28 04       		JR	Z,WR		; Allow write of "CLS"
0246   0095 FE 20       		CP	' '		; Don't write out any other control codes
0247   0097 38 01       		JR	C,NOWR		; ie. < space
0248   0099 CF          WR		RST	08H
0249   009A C9          NOWR		RET
0250   009B             
0251   009B 3E 0D       WRCRLF		LD	A,CR
0252   009D CF          		RST	08H
0253   009E 3E 0A       		LD	A,LF
0254   00A0 CF          		RST	08H
0255   00A1 3E 0D       		LD	A,CR
0256   00A3 C9          		RET
0257   00A4             
0258   00A4             
0259   00A4             ;------------------------------------------------------------------------------
0260   00A4             ; Initialise hardware and start main loop
0261   00A4             ;------------------------------------------------------------------------------
0262   00A4 31 2A 30    M_INIT		LD   SP,M_STACK		; Set the Stack Pointer
0263   00A7             
0264   00A7 3E 95       	   LD        A,RTS_LOW
0265   00A9 D3 80       	   OUT       (ACIA0_C),A         ; Initialise ACIA0
0266   00AB D3 82       	   OUT       (ACIA1_C),A         ; Initialise ACIA1
0267   00AD             		; Display the "Press space to start" message on both consoles
0268   00AD 3E 00       		LD	A,$00
0269   00AF 32 00 30    		LD	(primaryIO),A
0270   00B2 21 81 03        		LD   	HL,INITTXT
0271   00B5 CD 37 01    		CALL 	M_PRINT
0272   00B8             		; On Display B we need to take care that it does not hang. 	
0273   00B8 21 81 03        		LD   	HL,INITTXT
0274   00BB 22 04 30    		LD      (InitTxtB),HL
0275   00BE             
0276   00BE 2A 04 30    printInitB:	LD   	HL,(InitTxtB)
0277   00C1 7E          		LD   	A,(HL)	; Get character
0278   00C2 B7          		OR   	A	; Is it $00 ?
0279   00C3 28 0C       		JR      Z, waitForSpace
0280   00C5 CD 50 00            	CALL    nbconoutB	; Print it
0281   00C8 28 07       		JR      Z, waitForSpace ; If we can't write, don't increment
0282   00CA 23          		INC	HL
0283   00CB 22 04 30    		LD 	(InitTxtB),HL   ; Store pointer into message for next round 
0284   00CE C3 BE 00                    JP      printInitB
0285   00D1             		; Wait until space is in one of the buffers to determine the active console
0286   00D1             
0287   00D1             waitForSpace:
0288   00D1             
0289   00D1 CD 73 00    		CALL ckincharA
0290   00D4 28 0F       		JR	Z,chkSpaceB
0291   00D6 3E 00       		LD	A,$00
0292   00D8 32 00 30    		LD	(primaryIO),A
0293   00DB CD 1B 00    		CALL	conin
0294   00DE FE 20       		CP	' '
0295   00E0 C2 D1 00    		JP	NZ, waitForSpace
0296   00E3 18 12       		JR	spacePressed
0297   00E5             
0298   00E5             chkSpaceB:	
0299   00E5 CD 7A 00    		CALL ckincharB
0300   00E8 28 D4       	        JR	Z,printInitB ; If no key pressed, try to continue writing the init message on B
0301   00EA 3E 01       		LD	A,$01
0302   00EC 32 00 30    		LD	(primaryIO),A
0303   00EF CD 1B 00    		CALL	conin
0304   00F2 FE 20       		CP	' '
0305   00F4 C2 BE 00    		JP	NZ, printInitB ; If space not pressed, try to continue writing the init message on B
0306   00F7             
0307   00F7             spacePressed:
0308   00F7             
0309   00F7             		; Clear message on both consoles
0310   00F7 3E 0C       		LD	A,$0C
0311   00F9 CD 3C 00    		CALL	conoutA
0312   00FC CD 50 00    	        CALL	nbconoutB
0313   00FF             
0314   00FF             		;; We only clear the message on the active console,
0315   00FF             		;; because trying to write on a console not connected could
0316   00FF             		;; make the system freeze.
0317   00FF             
0318   00FF             		; primaryIO is now set to the channel where SPACE was pressed
0319   00FF             	
0320   00FF             
0321   00FF CD 3E 01    		CALL TXCRLF	; TXCRLF
0322   0102 21 B2 02    		LD   HL,M_SIGNON	; Print SIGNON message
0323   0105 CD 37 01    		CALL M_PRINT
0324   0108             
0325   0108             ;------------------------------------------------------------------------------
0326   0108             ; Monitor command loop
0327   0108             ;------------------------------------------------------------------------------
0328   0108 21 08 01    MAIN  		LD   HL,MAIN	; Save entry point for Monitor	
0329   010B E5          		PUSH HL		; This is the return address
0330   010C CD 3E 01    MAIN0		CALL TXCRLF	; Entry point for Monitor, Normal	
0331   010F 3E 3E       		LD   A,'>'	; Get a ">"	
0332   0111 CF          		RST 08H		; print it
0333   0112             
0334   0112 CD 81 00    MAIN1		CALL RDCHR	; Get a character from the input port
0335   0115 FE 20       		CP   ' '	; <spc> or less? 	
0336   0117 38 F9       		JR   C,MAIN1	; Go back
0337   0119             	
0338   0119 FE 3A       		CP   ':'	; ":"?
0339   011B CA B5 01    		JP   Z,LOAD	; First character of a HEX load
0340   011E             
0341   011E CD 8D 00    		CALL WRCHR	; Print char on console
0342   0121             
0343   0121 E6 5F       		AND  $5F	; Make character uppercase
0344   0123             
0345   0123 FE 42       		CP   'B'
0346   0125 CA F6 01    		JP   Z,BASIC
0347   0128             
0348   0128 FE 47       		CP   'G'
0349   012A CA AF 01    		JP   Z,M_GOTO
0350   012D             
0351   012D FE 58       		CP   'X'
0352   012F CA 0D 02    		JP   Z,CPMLOAD
0353   0132             
0354   0132 3E 3F       		LD   A,'?'	; Get a "?"	
0355   0134 CF          		RST 08H		; Print it
0356   0135 18 D5       		JR   MAIN0
0357   0137             	
0358   0137             ;------------------------------------------------------------------------------
0359   0137             ; Print string of characters to Serial A until byte=$00, WITH CR, LF
0360   0137             ;------------------------------------------------------------------------------
0361   0137 7E          M_PRINT		LD   A,(HL)	; Get character
0362   0138 B7          		OR   A		; Is it $00 ?
0363   0139 C8          		RET  Z		; Then RETurn on terminator
0364   013A CF          		RST  08H	; Print it
0365   013B 23          		INC  HL		; Next Character
0366   013C 18 F9       		JR   M_PRINT	; Continue until $00
0367   013E             
0368   013E             
0369   013E 3E 0D       TXCRLF		LD   A,$0D	; 
0370   0140 CF          		RST  08H	; Print character 
0371   0141 3E 0A       		LD   A,$0A	; 
0372   0143 CF          		RST  08H	; Print character
0373   0144 C9          		RET
0374   0145             
0375   0145             ;------------------------------------------------------------------------------
0376   0145             ; Get a character from the console, must be $20-$7F to be valid (no control characters)
0377   0145             ; <Ctrl-c> and <SPACE> breaks with the Zero Flag set
0378   0145             ;------------------------------------------------------------------------------	
0379   0145 CD 81 00    M_GETCHR		CALL RDCHR	; RX a Character
0380   0148 FE 03       		CP   $03	; <ctrl-c> User break?
0381   014A C8          		RET  Z			
0382   014B FE 20       		CP   $20	; <space> or better?
0383   014D 38 F6       		JR   C,M_GETCHR	; Do it again until we get something usable
0384   014F C9          		RET
0385   0150             ;------------------------------------------------------------------------------
0386   0150             ; Gets two ASCII characters from the console (assuming them to be HEX 0-9 A-F)
0387   0150             ; Moves them into B and C, converts them into a byte value in A and updates a
0388   0150             ; Checksum value in E
0389   0150             ;------------------------------------------------------------------------------
0390   0150 CD 45 01    GET2		CALL M_GETCHR	; Get us a valid character to work with
0391   0153 47          		LD   B,A	; Load it in B
0392   0154 CD 45 01    		CALL M_GETCHR	; Get us another character
0393   0157 4F          		LD   C,A	; load it in C
0394   0158 CD 8F 01    		CALL BCTOA	; Convert ASCII to byte
0395   015B 4F          		LD   C,A	; Build the checksum
0396   015C 7B          		LD   A,E
0397   015D 91          		SUB  C		; The checksum should always equal zero when checked
0398   015E 5F          		LD   E,A	; Save the checksum back where it came from
0399   015F 79          		LD   A,C	; Retrieve the byte and go back
0400   0160 C9          		RET
0401   0161             ;------------------------------------------------------------------------------
0402   0161             ; Gets four Hex characters from the console, converts them to values in HL
0403   0161             ;------------------------------------------------------------------------------
0404   0161 21 00 00    GETHL		LD   HL,$0000	; Gets xxxx but sets Carry Flag on any Terminator
0405   0164 CD A8 01    		CALL ECHO	; RX a Character
0406   0167 FE 0D       		CP   $0D	; <CR>?
0407   0169 20 0E       		JR   NZ,GETX2	; other key		
0408   016B 37          SETCY		SCF		; Set Carry Flag
0409   016C C9          		RET             ; and Return to main program		
0410   016D             ;------------------------------------------------------------------------------
0411   016D             ; This routine converts last four hex characters (0-9 A-F) user types into a value in HL
0412   016D             ; Rotates the old out and replaces with the new until the user hits a terminating character
0413   016D             ;------------------------------------------------------------------------------
0414   016D 21 00 00    GETX		LD   HL,$0000	; CLEAR HL
0415   0170 CD A8 01    GETX1		CALL ECHO	; RX a character from the console
0416   0173 FE 0D       		CP   $0D	; <CR>
0417   0175 C8          		RET  Z		; quit
0418   0176 FE 2C       		CP   $2C	; <,> can be used to safely quit for multiple entries
0419   0178 C8          		RET  Z		; (Like filling both DE and HL from the user)
0420   0179 FE 03       GETX2		CP   $03	; Likewise, a <ctrl-C> will terminate clean, too, but
0421   017B 28 EE       		JR   Z,SETCY	; It also sets the Carry Flag for testing later.
0422   017D 29          		ADD  HL,HL	; Otherwise, rotate the previous low nibble to high
0423   017E 29          		ADD  HL,HL	; rather slowly
0424   017F 29          		ADD  HL,HL	; until we get to the top
0425   0180 29          		ADD  HL,HL	; and then we can continue on.
0426   0181 D6 30       		SUB  $30	; Convert ASCII to byte	value
0427   0183 FE 0A       		CP   $0A	; Are we in the 0-9 range?
0428   0185 38 02       		JR   C,GETX3	; Then we just need to sub $30, but if it is A-F
0429   0187 D6 07       		SUB  $07	; We need to take off 7 more to get the value down to
0430   0189 E6 0F       GETX3		AND  $0F	; to the right hex value
0431   018B 85          		ADD  A,L	; Add the high nibble to the low
0432   018C 6F          		LD   L,A	; Move the byte back to A
0433   018D 18 E1       		JR   GETX1	; and go back for next character until he terminates
0434   018F             ;------------------------------------------------------------------------------
0435   018F             ; Convert ASCII characters in B C registers to a byte value in A
0436   018F             ;------------------------------------------------------------------------------
0437   018F 78          BCTOA		LD   A,B	; Move the hi order byte to A
0438   0190 D6 30       		SUB  $30	; Take it down from Ascii
0439   0192 FE 0A       		CP   $0A	; Are we in the 0-9 range here?
0440   0194 38 02       		JR   C,BCTOA1	; If so, get the next nybble
0441   0196 D6 07       		SUB  $07	; But if A-F, take it down some more
0442   0198 07          BCTOA1		RLCA		; Rotate the nybble from low to high
0443   0199 07          		RLCA		; One bit at a time
0444   019A 07          		RLCA		; Until we
0445   019B 07          		RLCA		; Get there with it
0446   019C 47          		LD   B,A	; Save the converted high nybble
0447   019D 79          		LD   A,C	; Now get the low order byte
0448   019E D6 30       		SUB  $30	; Convert it down from Ascii
0449   01A0 FE 0A       		CP   $0A	; 0-9 at this point?
0450   01A2 38 02       		JR   C,BCTOA2	; Good enough then, but
0451   01A4 D6 07       		SUB  $07	; Take off 7 more if it's A-F
0452   01A6 80          BCTOA2		ADD  A,B	; Add in the high order nybble
0453   01A7 C9          		RET
0454   01A8             
0455   01A8             ;------------------------------------------------------------------------------
0456   01A8             ; Get a character and echo it back to the user
0457   01A8             ;------------------------------------------------------------------------------
0458   01A8 CD 81 00    ECHO		CALL	RDCHR
0459   01AB CD 8D 00    		CALL	WRCHR
0460   01AE C9          		RET
0461   01AF             
0462   01AF             ;------------------------------------------------------------------------------
0463   01AF             ; GOTO command
0464   01AF             ;------------------------------------------------------------------------------
0465   01AF CD 61 01    M_GOTO		CALL GETHL		; ENTRY POINT FOR <G>oto addr. Get XXXX from user.
0466   01B2 D8          		RET  C			; Return if invalid       	
0467   01B3 E5          		PUSH HL
0468   01B4 C9          		RET			; Jump to HL address value
0469   01B5             
0470   01B5             ;------------------------------------------------------------------------------
0471   01B5             ; LOAD Intel Hex format file from the console.
0472   01B5             ; [Intel Hex Format is:
0473   01B5             ; 1) Colon (Frame 0)
0474   01B5             ; 2) Record Length Field (Frames 1 and 2)
0475   01B5             ; 3) Load Address Field (Frames 3,4,5,6)
0476   01B5             ; 4) Record Type Field (Frames 7 and 8)
0477   01B5             ; 5) Data Field (Frames 9 to 9+2*(Record Length)-1
0478   01B5             ; 6) Checksum Field - Sum of all byte values from Record Length to and 
0479   01B5             ;   including Checksum Field = 0 ]
0480   01B5             ;------------------------------------------------------------------------------	
0481   01B5 1E 00       LOAD		LD   E,0	; First two Characters is the Record Length Field
0482   01B7 CD 50 01    		CALL GET2	; Get us two characters into BC, convert it to a byte <A>
0483   01BA 57          		LD   D,A	; Load Record Length count into D
0484   01BB CD 50 01    		CALL GET2	; Get next two characters, Memory Load Address <H>
0485   01BE 67          		LD   H,A	; put value in H register.
0486   01BF CD 50 01    		CALL GET2	; Get next two characters, Memory Load Address <L>
0487   01C2 6F          		LD   L,A	; put value in L register.
0488   01C3 CD 50 01    		CALL GET2	; Get next two characters, Record Field Type
0489   01C6 FE 01       		CP   $01	; Record Field Type 00 is Data, 01 is End of File
0490   01C8 20 09       		JR   NZ,LOAD2	; Must be the end of that file
0491   01CA CD 50 01    		CALL GET2	; Get next two characters, assemble into byte
0492   01CD 7B          		LD   A,E	; Recall the Checksum byte
0493   01CE A7          		AND  A		; Is it Zero?
0494   01CF 28 1E       		JR   Z,LOAD00	; Print footer reached message
0495   01D1 18 15       		JR   LOADERR	; Checksums don't add up, Error out
0496   01D3             		
0497   01D3 7A          LOAD2		LD   A,D	; Retrieve line character counter	
0498   01D4 A7          		AND  A		; Are we done with this line?
0499   01D5 28 0B       		JR   Z,LOAD3	; Get two more ascii characters, build a byte and checksum
0500   01D7 CD 50 01    		CALL GET2	; Get next two chars, convert to byte in A, checksum it
0501   01DA 77          		LD   (HL),A	; Move converted byte in A to memory location
0502   01DB 23          		INC  HL		; Increment pointer to next memory location	
0503   01DC 3E 2E       		LD   A,'.'	; Print out a "." for every byte loaded
0504   01DE CF          		RST  08H	;
0505   01DF 15          		DEC  D		; Decrement line character counter
0506   01E0 18 F1       		JR   LOAD2	; and keep loading into memory until line is complete
0507   01E2             		
0508   01E2 CD 50 01    LOAD3		CALL GET2	; Get two chars, build byte and checksum
0509   01E5 7B          		LD   A,E	; Check the checksum value
0510   01E6 A7          		AND  A		; Is it zero?
0511   01E7 C8          		RET  Z
0512   01E8             
0513   01E8 21 70 03    LOADERR		LD   HL,CKSUMERR  ; Get "Checksum Error" message
0514   01EB CD 37 01    		CALL M_PRINT	; Print Message from (HL) and terminate the load
0515   01EE C9          		RET
0516   01EF             
0517   01EF 21 AB 03    LOAD00  	LD   HL,LDETXT	; Print load complete message
0518   01F2 CD 37 01    		CALL M_PRINT
0519   01F5 C9          		RET
0520   01F6             
0521   01F6             ;------------------------------------------------------------------------------
0522   01F6             ; Start BASIC command
0523   01F6             ;------------------------------------------------------------------------------
0524   01F6             BASIC
0525   01F6 21 5E 03        		LD HL,M_BASTXT
0526   01F9 CD 37 01    		CALL M_PRINT
0527   01FC CD 45 01    		CALL M_GETCHR
0528   01FF C8          		RET Z	; Cancel if CTRL-C
0529   0200 E6 5F       		AND  $5F ; uppercase
0530   0202 FE 43       		CP 'C'
0531   0204 CA B6 03    		JP  Z,COLD
0532   0207 FE 57       		CP 'W'
0533   0209 CA B9 03    		JP  Z,WARM
0534   020C C9          		RET
0535   020D             
0536   020D             ;------------------------------------------------------------------------------
0537   020D             ; CP/M load command
0538   020D             ;------------------------------------------------------------------------------
0539   020D             CPMLOAD
0540   020D             
0541   020D 21 1F 02        	LD HL,CPMTXT
0542   0210 CD 37 01    		CALL M_PRINT
0543   0213 CD 45 01    		CALL M_GETCHR
0544   0216 C8          		RET Z	; Cancel if CTRL-C
0545   0217 E6 5F       		AND  $5F ; uppercase
0546   0219 FE 59       		CP 'Y'
0547   021B CA 40 02    		JP  Z,CPMLOAD2
0548   021E C9          		RET
0549   021F             CPMTXT
0550   021F 0D 0A       		.BYTE	$0D,$0A
0551   0221 42 6F 6F 74 		.TEXT	"Boot CP/M?"
0551   0225 20 43 50 2F 
0551   0229 4D 3F 
0552   022B 00          		.BYTE	$00
0553   022C             
0554   022C             CPMTXT2
0555   022C 0D 0A       		.BYTE	$0D,$0A
0556   022E 4C 6F 61 64 		.TEXT	"Loading CP/M..."
0556   0232 69 6E 67 20 
0556   0236 43 50 2F 4D 
0556   023A 2E 2E 2E 
0557   023D 0D 0A 00    		.BYTE	$0D,$0A,$00
0558   0240             
0559   0240             CPMLOAD2
0560   0240 21 2C 02        	LD HL,CPMTXT2
0561   0243 CD 37 01    		CALL M_PRINT
0562   0246             		
0563   0246 06 18       		LD	B,numSecs
0564   0248             
0565   0248 3E 00       		LD	A,0
0566   024A 32 06 30    		LD	(lba0),A
0567   024D 32 07 30    		ld 	(lba1),A
0568   0250 32 08 30    		ld 	(lba2),A
0569   0253 32 09 30    		ld 	(lba3),A
0570   0256             		
0571   0256 21 00 D0    		LD	HL,loadAddr
0572   0259 22 02 30    		LD	(dmaAddr),HL
0573   025C             processSectors:
0574   025C             
0575   025C CD 8A 02    		call	readhst
0576   025F             
0577   025F 11 00 02    		LD	DE,0200H
0578   0262 2A 02 30    		LD	HL,(dmaAddr)
0579   0265 19          		ADD	HL,DE
0580   0266 22 02 30    		LD	(dmaAddr),HL
0581   0269 3A 06 30    		LD	A,(lba0)
0582   026C 3C          		INC	A
0583   026D 32 06 30    		LD	(lba0),A
0584   0270             
0585   0270 10 EA       		djnz	processSectors
0586   0272             
0587   0272             ; Start CP/M using entry at top of BIOS
0588   0272             ; The current active console stream ID is pushed onto the stack
0589   0272             ; to allow the CBIOS to pick it up
0590   0272             ; 0 = ACIA0, 1 = ACIA1
0591   0272             		
0592   0272 3A 00 30    		ld	A,(primaryIO)
0593   0275 F5          		PUSH	AF
0594   0276 2A FE FF    		ld	HL,($FFFE)
0595   0279 E9          		jp	(HL)
0596   027A             
0597   027A             
0598   027A             ;------------------------------------------------------------------------------
0599   027A             ; ROUTINES AS USED IN BIOS
0600   027A             ;------------------------------------------------------------------------------
0601   027A             
0602   027A             ;================================================================================================
0603   027A             ; Convert track/head/sector into LBA for physical access to the disk
0604   027A             ;================================================================================================
0605   027A             setLBAaddr:	
0606   027A             		; Transfer LBA to disk (LBA3 not used on SD card)
0607   027A 3A 08 30    		LD	A,(lba2)
0608   027D D3 8C       		OUT	(SD_LBA2),A
0609   027F 3A 07 30    		LD	A,(lba1)
0610   0282 D3 8B       		OUT	(SD_LBA1),A
0611   0284 3A 06 30    		LD	A,(lba0)
0612   0287 D3 8A       		OUT	(SD_LBA0),A
0613   0289 C9          		RET
0614   028A             		
0615   028A             ;================================================================================================
0616   028A             ; Read physical sector from host
0617   028A             ;================================================================================================
0618   028A             
0619   028A             readhst:
0620   028A F5          		PUSH 	AF
0621   028B C5          		PUSH 	BC
0622   028C E5          		PUSH 	HL
0623   028D             
0624   028D DB 89       rdWait1: IN	A,(SD_STATUS)
0625   028F FE 80       		CP	128
0626   0291 20 FA       		JR	NZ,rdWait1
0627   0293             		
0628   0293 CD 7A 02    		CALL 	setLBAaddr
0629   0296             		
0630   0296 3E 00       		LD	A,$00	; 00 = Read block
0631   0298 D3 89       		OUT	(SD_CONTROL),A
0632   029A             
0633   029A 0E 04       		LD 	c,4
0634   029C             ;		LD 	HL,hstbuf
0635   029C             rd4secs:
0636   029C 06 80       		LD 	b,128
0637   029E             rdByte:
0638   029E             
0639   029E DB 89       rdWait2: IN	A,(SD_STATUS)
0640   02A0 FE E0       		CP	224	; Read byte waiting
0641   02A2 20 FA       		JR	NZ,rdWait2
0642   02A4             
0643   02A4 DB 88       		IN	A,(SD_DATA)
0644   02A6             
0645   02A6 77          		LD 	(HL),A
0646   02A7 23          		INC 	HL
0647   02A8 05          		dec 	b
0648   02A9 20 F3       		JR 	NZ, rdByte
0649   02AB 0D          		dec 	c
0650   02AC 20 EE       		JR 	NZ,rd4secs
0651   02AE             
0652   02AE E1          		POP 	HL
0653   02AF C1          		POP 	BC
0654   02B0 F1          		POP 	AF
0655   02B1             
0656   02B1             ;		XOR 	a
0657   02B1             ;		ld	(erflag),a
0658   02B1 C9          		RET
0659   02B2             
0660   02B2             ;------------------------------------------------------------------------------
0661   02B2             ; END OF ROUTINES AS USED IN BIOS
0662   02B2             ;------------------------------------------------------------------------------
0663   02B2             
0664   02B2             
0665   02B2 43 50 2F 4D M_SIGNON	.BYTE	"CP/M Boot ROM 2.0"
0665   02B6 20 42 6F 6F 
0665   02BA 74 20 52 4F 
0665   02BE 4D 20 32 2E 
0665   02C2 30 
0666   02C3 20 62 79 20 		.BYTE	" by G. Searle"
0666   02C7 47 2E 20 53 
0666   02CB 65 61 72 6C 
0666   02CF 65 
0667   02D0 0D 0A       		.BYTE	$0D,$0A
0668   02D2 0D 0A       		.BYTE	$0D,$0A
0669   02D4 42 43 20 6F 		.TEXT	"BC or BW - ROM BASIC Cold/Warm"
0669   02D8 72 20 42 57 
0669   02DC 20 2D 20 52 
0669   02E0 4F 4D 20 42 
0669   02E4 41 53 49 43 
0669   02E8 20 43 6F 6C 
0669   02EC 64 2F 57 61 
0669   02F0 72 6D 
0670   02F2 0D 0A       		.BYTE	$0D,$0A
0671   02F4 58 20 20 20 		.TEXT	"X        - Boot CP/M (load $D000-$FFFF)"
0671   02F8 20 20 20 20 
0671   02FC 20 2D 20 42 
0671   0300 6F 6F 74 20 
0671   0304 43 50 2F 4D 
0671   0308 20 28 6C 6F 
0671   030C 61 64 20 24 
0671   0310 44 30 30 30 
0671   0314 2D 24 46 46 
0671   0318 46 46 29 
0672   031B 0D 0A       		.BYTE	$0D,$0A
0673   031D 3A 6E 6E 6E 		.TEXT	":nnnn... - Load Intel-Hex file record"
0673   0321 6E 2E 2E 2E 
0673   0325 20 2D 20 4C 
0673   0329 6F 61 64 20 
0673   032D 49 6E 74 65 
0673   0331 6C 2D 48 65 
0673   0335 78 20 66 69 
0673   0339 6C 65 20 72 
0673   033D 65 63 6F 72 
0673   0341 64 
0674   0342 0D 0A       		.BYTE	$0D,$0A
0675   0344 47 6E 6E 6E 		.TEXT	"Gnnnn    - Run loc nnnn"
0675   0348 6E 20 20 20 
0675   034C 20 2D 20 52 
0675   0350 75 6E 20 6C 
0675   0354 6F 63 20 6E 
0675   0358 6E 6E 6E 
0676   035B 0D 0A       		.BYTE	$0D,$0A
0677   035D 00                 	.BYTE   $00
0678   035E             
0679   035E             M_BASTXT
0680   035E 0D 0A       		.BYTE	$0D,$0A
0681   0360 43 6F 6C 64 		.TEXT	"Cold or warm?"
0681   0364 20 6F 72 20 
0681   0368 77 61 72 6D 
0681   036C 3F 
0682   036D 0D 0A 00    		.BYTE	$0D,$0A,$00
0683   0370             
0684   0370 43 68 65 63 CKSUMERR	.BYTE	"Checksum error"
0684   0374 6B 73 75 6D 
0684   0378 20 65 72 72 
0684   037C 6F 72 
0685   037E 0D 0A 00    		.BYTE	$0D,$0A,$00
0686   0381             
0687   0381             INITTXT  
0688   0381 0C          		.BYTE	$0C
0689   0382 50 72 65 73 		.TEXT	"Press [space] to activate the console."
0689   0386 73 20 5B 73 
0689   038A 70 61 63 65 
0689   038E 5D 20 74 6F 
0689   0392 20 61 63 74 
0689   0396 69 76 61 74 
0689   039A 65 20 74 68 
0689   039E 65 20 63 6F 
0689   03A2 6E 73 6F 6C 
0689   03A6 65 2E 
0690   03A8 0D 0A 00    		.BYTE	$0D,$0A, $00
0691   03AB             
0692   03AB             LDETXT  
0693   03AB 43 6F 6D 70 		.TEXT	"Complete"
0693   03AF 6C 65 74 65 
0694   03B3 0D 0A 00    		.BYTE	$0D,$0A, $00
0695   03B6             
0696   03B6             ;===========================================================================================================================
0697   03B6             
0698   03B6             ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
0699   03B6             ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
0700   03B6             ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
0701   03B6             ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
0702   03B6             ; the original ROM code (checksum A934H). PA
0703   03B6             
0704   03B6             ; GENERAL EQUATES
0705   03B6             
0706   03B6             CTRLC   .EQU    03H             ; Control "C"
0707   03B6             CTRLG   .EQU    07H             ; Control "G"
0708   03B6             BKSP    .EQU    08H             ; Back space
0709   03B6             LF      .EQU    0AH             ; Line feed
0710   03B6             CS      .EQU    0CH             ; Clear screen
0711   03B6             CR      .EQU    0DH             ; Carriage return
0712   03B6             CTRLO   .EQU    0FH             ; Control "O"
0713   03B6             CTRLQ	.EQU	11H		        ; Control "Q"
0714   03B6             CTRLR   .EQU    12H             ; Control "R"
0715   03B6             CTRLS   .EQU    13H             ; Control "S"
0716   03B6             CTRLU   .EQU    15H             ; Control "U"
0717   03B6             ESC     .EQU    1BH             ; Escape
0718   03B6             DEL     .EQU    7FH             ; Delete
0719   03B6             
0720   03B6             ; BASIC WORK SPACE LOCATIONS
0721   03B6             
0722   03B6             WRKSPC  .EQU    30B0H             ; BASIC Work space
0723   03B6             USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
0724   03B6             OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
0725   03B6             OTPORT  .EQU    WRKSPC+7H           ; Port (p)
0726   03B6             DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
0727   03B6             DIV1    .EQU    WRKSPC+0AH           ; <- Values
0728   03B6             DIV2    .EQU    WRKSPC+0EH           ; <-   to
0729   03B6             DIV3    .EQU    WRKSPC+12H           ; <-   be
0730   03B6             DIV4    .EQU    WRKSPC+15H           ; <-inserted
0731   03B6             SEED    .EQU    WRKSPC+17H           ; Random number seed
0732   03B6             LSTRND  .EQU    WRKSPC+3AH           ; Last random number
0733   03B6             INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
0734   03B6             INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
0735   03B6             NULLS   .EQU    WRKSPC+41H           ; Number of nulls
0736   03B6             LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
0737   03B6             COMMAN  .EQU    WRKSPC+43H           ; Width for commas
0738   03B6             NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
0739   03B6             CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
0740   03B6             LINESC  .EQU    WRKSPC+46H           ; Lines counter
0741   03B6             LINESN  .EQU    WRKSPC+48H           ; Lines number
0742   03B6             CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
0743   03B6             NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
0744   03B6             BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
0745   03B6             RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
0746   03B6             POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
0747   03B6             PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
0748   03B6             RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
0749   03B6             STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
0750   03B6             LINEAT  .EQU    WRKSPC+5CH           ; Current line number
0751   03B6             BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
0752   03B6             BUFFER  .EQU    WRKSPC+61H           ; Input buffer
0753   03B6             STACK   .EQU    WRKSPC+66H           ; Initial stack
0754   03B6             CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
0755   03B6             LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
0756   03B6             TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
0757   03B6             DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
0758   03B6             LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
0759   03B6             TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
0760   03B6             TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
0761   03B6             TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
0762   03B6             STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
0763   03B6             CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
0764   03B6             LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
0765   03B6             DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
0766   03B6             FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
0767   03B6             LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
0768   03B6             READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
0769   03B6             BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
0770   03B6             NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
0771   03B6             ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
0772   03B6             CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
0773   03B6             PROGND  .EQU    WRKSPC+0D6H          ; End of program
0774   03B6             VAREND  .EQU    WRKSPC+0D8H          ; End of variables
0775   03B6             ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
0776   03B6             NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
0777   03B6             FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
0778   03B6             FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
0779   03B6             FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
0780   03B6             FPEXP   .EQU    FPREG+3         ; Floating point exponent
0781   03B6             SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
0782   03B6             PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
0783   03B6             MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
0784   03B6             PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area
0785   03B6             STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
0786   03B6             
0787   03B6             ; BASIC ERROR CODE VALUES
0788   03B6             
0789   03B6             NF      .EQU    00H             ; NEXT without FOR
0790   03B6             SN      .EQU    02H             ; Syntax error
0791   03B6             RG      .EQU    04H             ; RETURN without GOSUB
0792   03B6             OD      .EQU    06H             ; Out of DATA
0793   03B6             FC      .EQU    08H             ; Function call error
0794   03B6             OV      .EQU    0AH             ; Overflow
0795   03B6             OM      .EQU    0CH             ; Out of memory
0796   03B6             UL      .EQU    0EH             ; Undefined line number
0797   03B6             BS      .EQU    10H             ; Bad subscript
0798   03B6             DD      .EQU    12H             ; Re-DIMensioned array
0799   03B6             DZ      .EQU    14H             ; Division by zero (/0)
0800   03B6             ID      .EQU    16H             ; Illegal direct
0801   03B6             TM      .EQU    18H             ; Type miss-match
0802   03B6             OS      .EQU    1AH             ; Out of string space
0803   03B6             LS      .EQU    1CH             ; String too long
0804   03B6             ST      .EQU    1EH             ; String formula too complex
0805   03B6             CN      .EQU    20H             ; Can't CONTinue
0806   03B6             UF      .EQU    22H             ; UnDEFined FN function
0807   03B6             MO      .EQU    24H             ; Missing operand
0808   03B6             HX      .EQU    26H             ; HEX error
0809   03B6             BN      .EQU    28H             ; BIN error
0810   03B6             
0811   03B6             ;        .ORG    00396H
0812   03B6             
0813   03B6 C3 BC 03    COLD:   JP      STARTB          ; Jump for cold start
0814   03B9 C3 5A 04    WARM:   JP      WARMST          ; Jump for warm start
0815   03BC             STARTB: 
0816   03BC DD 21 00 00         LD      IX,0            ; Flag cold start
0817   03C0 C3 C7 03            JP      CSTART          ; Jump to initialise
0818   03C3             
0819   03C3 6D 0C               .WORD   DEINT           ; Get integer -32768 to 32767
0820   03C5 E3 13               .WORD   ABPASS          ; Return integer in AB
0821   03C7             
0822   03C7             
0823   03C7 21 B0 30    CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
0824   03CA F9                  LD      SP,HL           ; Set up a temporary stack
0825   03CB C3 02 20            JP      INITST          ; Go to initialise
0826   03CE             
0827   03CE 11 94 06    INIT:   LD      DE,INITAB       ; Initialise workspace
0828   03D1 06 63               LD      B,INITBE-INITAB+3; Bytes to copy
0829   03D3 21 B0 30            LD      HL,WRKSPC       ; Into workspace RAM
0830   03D6 1A          COPY:   LD      A,(DE)          ; Get source
0831   03D7 77                  LD      (HL),A          ; To destination
0832   03D8 23                  INC     HL              ; Next destination
0833   03D9 13                  INC     DE              ; Next source
0834   03DA 05                  DEC     B               ; Count bytes
0835   03DB C2 D6 03            JP      NZ,COPY         ; More to move
0836   03DE F9                  LD      SP,HL           ; Temporary stack
0837   03DF CD 95 08            CALL    CLREG           ; Clear registers and stack
0838   03E2 CD 63 0E            CALL    PRNTCRLF        ; Output CRLF
0839   03E5 32 5A 31            LD      (BUFFER+72+1),A ; Mark end of buffer
0840   03E8 32 A9 31            LD      (PROGST),A      ; Initialise program area
0841   03EB 21 A9 04    MSIZE:  LD      HL,MEMMSG       ; Point to message
0842   03EE CD 01 15            CALL    PRS             ; Output "Memory size"
0843   03F1 CD B2 08            CALL    PROMPT          ; Get input with '?'
0844   03F4 CD BB 0B            CALL    GETCHR          ; Get next character
0845   03F7 B7                  OR      A               ; Set flags
0846   03F8 C2 10 04            JP      NZ,TSTMEM       ; If number - Test if RAM there
0847   03FB 21 0D 32            LD      HL,STLOOK       ; Point to start of RAM
0848   03FE 23          MLOOP:  INC     HL              ; Next byte
0849   03FF 7C                  LD      A,H             ; Above address FFFF ?
0850   0400 B5                  OR      L
0851   0401 CA 22 04            JP      Z,SETTOP        ; Yes - 64K RAM
0852   0404 7E                  LD      A,(HL)          ; Get contents
0853   0405 47                  LD      B,A             ; Save it
0854   0406 2F                  CPL                     ; Flip all bits
0855   0407 77                  LD      (HL),A          ; Put it back
0856   0408 BE                  CP      (HL)            ; RAM there if same
0857   0409 70                  LD      (HL),B          ; Restore old contents
0858   040A CA FE 03            JP      Z,MLOOP         ; If RAM - test next byte
0859   040D C3 22 04            JP      SETTOP          ; Top of RAM found
0860   0410             
0861   0410 CD 87 0C    TSTMEM: CALL    ATOH            ; Get high memory into DE
0862   0413 B7                  OR      A               ; Set flags on last byte
0863   0414 C2 63 07            JP      NZ,SNERR        ; ?SN Error if bad character
0864   0417 EB                  EX      DE,HL           ; Address into HL
0865   0418 2B                  DEC     HL              ; Back one byte
0866   0419 3E D9               LD      A,11011001B     ; Test byte
0867   041B 46                  LD      B,(HL)          ; Get old contents
0868   041C 77                  LD      (HL),A          ; Load test byte
0869   041D BE                  CP      (HL)            ; RAM there if same
0870   041E 70                  LD      (HL),B          ; Restore old contents
0871   041F C2 EB 03            JP      NZ,MSIZE        ; Ask again if no RAM
0872   0422             
0873   0422 2B          SETTOP: DEC     HL              ; Back one byte
0874   0423 11 0C 32            LD      DE,STLOOK-1     ; See if enough RAM
0875   0426 CD 2B 0A            CALL    CPDEHL          ; Compare DE with HL
0876   0429 DA EB 03            JP      C,MSIZE         ; Ask again if not enough RAM
0877   042C 11 CE FF            LD      DE,0-50         ; 50 Bytes string space
0878   042F 22 5F 31            LD      (LSTRAM),HL     ; Save last available RAM
0879   0432 19                  ADD     HL,DE           ; Allocate string space
0880   0433 22 0A 31            LD      (STRSPC),HL     ; Save string space
0881   0436 CD 70 08            CALL    CLRPTR          ; Clear program area
0882   0439 2A 0A 31            LD      HL,(STRSPC)     ; Get end of memory
0883   043C 11 EF FF            LD      DE,0-17         ; Offset for free bytes
0884   043F 19                  ADD     HL,DE           ; Adjust HL
0885   0440 11 A9 31            LD      DE,PROGST       ; Start of program text
0886   0443 7D                  LD      A,L             ; Get LSB
0887   0444 93                  SUB     E               ; Adjust it
0888   0445 6F                  LD      L,A             ; Re-save
0889   0446 7C                  LD      A,H             ; Get MSB
0890   0447 9A                  SBC     A,D             ; Adjust it
0891   0448 67                  LD      H,A             ; Re-save
0892   0449 E5                  PUSH    HL              ; Save bytes free
0893   044A 21 72 04            LD      HL,SIGNON       ; Sign-on message
0894   044D CD 01 15            CALL    PRS             ; Output string
0895   0450 E1                  POP     HL              ; Get bytes free back
0896   0451 CD A4 1B            CALL    PRNTHL          ; Output amount of free memory
0897   0454 21 63 04            LD      HL,BFREE        ; " Bytes free" message
0898   0457 CD 01 15            CALL    PRS             ; Output string
0899   045A             
0900   045A 31 16 31    WARMST: LD      SP,STACK        ; Temporary stack
0901   045D CD 95 08    BRKRET: CALL    CLREG           ; Clear registers and stack
0902   0460 C3 AE 07            JP      PRNTOK          ; Go to get command line
0903   0463             
0904   0463 20 42 79 74 BFREE:  .BYTE   " Bytes free",CR,LF,0,0
0904   0467 65 73 20 66 
0904   046B 72 65 65 0D 
0904   046F 0A 00 00 
0905   0472             
0906   0472 5A 38 30 20 SIGNON: .BYTE   "Z80 BASIC Ver 4.7b",CR,LF
0906   0476 42 41 53 49 
0906   047A 43 20 56 65 
0906   047E 72 20 34 2E 
0906   0482 37 62 0D 0A 
0907   0486 43 6F 70 79         .BYTE   "Copyright ",40,"C",41
0907   048A 72 69 67 68 
0907   048E 74 20 28 43 
0907   0492 29 
0908   0493 20 31 39 37         .BYTE   " 1978 by Microsoft",CR,LF,0,0
0908   0497 38 20 62 79 
0908   049B 20 4D 69 63 
0908   049F 72 6F 73 6F 
0908   04A3 66 74 0D 0A 
0908   04A7 00 00 
0909   04A9             
0910   04A9 4D 65 6D 6F MEMMSG: .BYTE   "Memory top",0
0910   04AD 72 79 20 74 
0910   04B1 6F 70 00 
0911   04B4             
0912   04B4             ; FUNCTION ADDRESS TABLE
0913   04B4             
0914   04B4 19 1A       FNCTAB: .WORD   SGN
0915   04B6 DD 1A               .WORD   INT
0916   04B8 2F 1A               .WORD   ABS
0917   04BA B3 30               .WORD   USR
0918   04BC C1 13               .WORD   FRE
0919   04BE 46 17               .WORD   INP
0920   04C0 EF 13               .WORD   POS
0921   04C2 A3 1C               .WORD   SQR
0922   04C4 82 1D               .WORD   RND
0923   04C6 BE 18               .WORD   LOG
0924   04C8 F1 1C               .WORD   EXP
0925   04CA F7 1D               .WORD   COS
0926   04CC FD 1D               .WORD   SIN
0927   04CE 5E 1E               .WORD   TAN
0928   04D0 73 1E               .WORD   ATN
0929   04D2 9A 17               .WORD   PEEK
0930   04D4 DE 1E               .WORD   DEEK
0931   04D6 01 31               .WORD   POINT
0932   04D8 73 16               .WORD   LEN
0933   04DA 8B 14               .WORD   STR
0934   04DC 0D 17               .WORD   VAL
0935   04DE 82 16               .WORD   ASC
0936   04E0 93 16               .WORD   CHR
0937   04E2 00 1F               .WORD   HEX
0938   04E4 93 1F               .WORD   BIN
0939   04E6 A3 16               .WORD   LEFT
0940   04E8 D3 16               .WORD   RIGHT
0941   04EA DD 16               .WORD   MID
0942   04EC             
0943   04EC             ; RESERVED WORD LIST
0944   04EC             
0945   04EC C5 4E 44    WORDS:  .BYTE   'E'+80H,"ND"
0946   04EF C6 4F 52            .BYTE   'F'+80H,"OR"
0947   04F2 CE 45 58 54         .BYTE   'N'+80H,"EXT"
0948   04F6 C4 41 54 41         .BYTE   'D'+80H,"ATA"
0949   04FA C9 4E 50 55         .BYTE   'I'+80H,"NPUT"
0949   04FE 54 
0950   04FF C4 49 4D            .BYTE   'D'+80H,"IM"
0951   0502 D2 45 41 44         .BYTE   'R'+80H,"EAD"
0952   0506 CC 45 54            .BYTE   'L'+80H,"ET"
0953   0509 C7 4F 54 4F         .BYTE   'G'+80H,"OTO"
0954   050D D2 55 4E            .BYTE   'R'+80H,"UN"
0955   0510 C9 46               .BYTE   'I'+80H,"F"
0956   0512 D2 45 53 54         .BYTE   'R'+80H,"ESTORE"
0956   0516 4F 52 45 
0957   0519 C7 4F 53 55         .BYTE   'G'+80H,"OSUB"
0957   051D 42 
0958   051E D2 45 54 55         .BYTE   'R'+80H,"ETURN"
0958   0522 52 4E 
0959   0524 D2 45 4D            .BYTE   'R'+80H,"EM"
0960   0527 D3 54 4F 50         .BYTE   'S'+80H,"TOP"
0961   052B CF 55 54            .BYTE   'O'+80H,"UT"
0962   052E CF 4E               .BYTE   'O'+80H,"N"
0963   0530 CE 55 4C 4C         .BYTE   'N'+80H,"ULL"
0964   0534 D7 41 49 54         .BYTE   'W'+80H,"AIT"
0965   0538 C4 45 46            .BYTE   'D'+80H,"EF"
0966   053B D0 4F 4B 45         .BYTE   'P'+80H,"OKE"
0967   053F C4 4F 4B 45         .BYTE   'D'+80H,"OKE"
0968   0543 D3 43 52 45         .BYTE   'S'+80H,"CREEN"
0968   0547 45 4E 
0969   0549 CC 49 4E 45         .BYTE   'L'+80H,"INES"
0969   054D 53 
0970   054E C3 4C 53            .BYTE   'C'+80H,"LS"
0971   0551 D7 49 44 54         .BYTE   'W'+80H,"IDTH"
0971   0555 48 
0972   0556 CD 4F 4E 49         .BYTE   'M'+80H,"ONITOR"
0972   055A 54 4F 52 
0973   055D D3 45 54            .BYTE   'S'+80H,"ET"
0974   0560 D2 45 53 45         .BYTE   'R'+80H,"ESET"
0974   0564 54 
0975   0565 D0 52 49 4E         .BYTE   'P'+80H,"RINT"
0975   0569 54 
0976   056A C3 4F 4E 54         .BYTE   'C'+80H,"ONT"
0977   056E CC 49 53 54         .BYTE   'L'+80H,"IST"
0978   0572 C3 4C 45 41         .BYTE   'C'+80H,"LEAR"
0978   0576 52 
0979   0577 C3 4C 4F 41         .BYTE   'C'+80H,"LOAD"
0979   057B 44 
0980   057C C3 53 41 56         .BYTE   'C'+80H,"SAVE"
0980   0580 45 
0981   0581 CE 45 57            .BYTE   'N'+80H,"EW"
0982   0584             
0983   0584 D4 41 42 28         .BYTE   'T'+80H,"AB("
0984   0588 D4 4F               .BYTE   'T'+80H,"O"
0985   058A C6 4E               .BYTE   'F'+80H,"N"
0986   058C D3 50 43 28         .BYTE   'S'+80H,"PC("
0987   0590 D4 48 45 4E         .BYTE   'T'+80H,"HEN"
0988   0594 CE 4F 54            .BYTE   'N'+80H,"OT"
0989   0597 D3 54 45 50         .BYTE   'S'+80H,"TEP"
0990   059B             
0991   059B AB                  .BYTE   '+'+80H
0992   059C AD                  .BYTE   '-'+80H
0993   059D AA                  .BYTE   '*'+80H
0994   059E AF                  .BYTE   '/'+80H
0995   059F DE                  .BYTE   '^'+80H
0996   05A0 C1 4E 44            .BYTE   'A'+80H,"ND"
0997   05A3 CF 52               .BYTE   'O'+80H,"R"
0998   05A5 BE                  .BYTE   '>'+80H
0999   05A6 BD                  .BYTE   '='+80H
1000   05A7 BC                  .BYTE   '<'+80H
1001   05A8             
1002   05A8 D3 47 4E            .BYTE   'S'+80H,"GN"
1003   05AB C9 4E 54            .BYTE   'I'+80H,"NT"
1004   05AE C1 42 53            .BYTE   'A'+80H,"BS"
1005   05B1 D5 53 52            .BYTE   'U'+80H,"SR"
1006   05B4 C6 52 45            .BYTE   'F'+80H,"RE"
1007   05B7 C9 4E 50            .BYTE   'I'+80H,"NP"
1008   05BA D0 4F 53            .BYTE   'P'+80H,"OS"
1009   05BD D3 51 52            .BYTE   'S'+80H,"QR"
1010   05C0 D2 4E 44            .BYTE   'R'+80H,"ND"
1011   05C3 CC 4F 47            .BYTE   'L'+80H,"OG"
1012   05C6 C5 58 50            .BYTE   'E'+80H,"XP"
1013   05C9 C3 4F 53            .BYTE   'C'+80H,"OS"
1014   05CC D3 49 4E            .BYTE   'S'+80H,"IN"
1015   05CF D4 41 4E            .BYTE   'T'+80H,"AN"
1016   05D2 C1 54 4E            .BYTE   'A'+80H,"TN"
1017   05D5 D0 45 45 4B         .BYTE   'P'+80H,"EEK"
1018   05D9 C4 45 45 4B         .BYTE   'D'+80H,"EEK"
1019   05DD D0 4F 49 4E         .BYTE   'P'+80H,"OINT"
1019   05E1 54 
1020   05E2 CC 45 4E            .BYTE   'L'+80H,"EN"
1021   05E5 D3 54 52 24         .BYTE   'S'+80H,"TR$"
1022   05E9 D6 41 4C            .BYTE   'V'+80H,"AL"
1023   05EC C1 53 43            .BYTE   'A'+80H,"SC"
1024   05EF C3 48 52 24         .BYTE   'C'+80H,"HR$"
1025   05F3 C8 45 58 24         .BYTE   'H'+80H,"EX$"
1026   05F7 C2 49 4E 24         .BYTE   'B'+80H,"IN$"
1027   05FB CC 45 46 54         .BYTE   'L'+80H,"EFT$"
1027   05FF 24 
1028   0600 D2 49 47 48         .BYTE   'R'+80H,"IGHT$"
1028   0604 54 24 
1029   0606 CD 49 44 24         .BYTE   'M'+80H,"ID$"
1030   060A 80                  .BYTE   80H             ; End of list marker
1031   060B             
1032   060B             ; KEYWORD ADDRESS TABLE
1033   060B             
1034   060B 05 0C       WORDTB: .WORD   PEND
1035   060D 02 0B               .WORD   FOR
1036   060F DD 0F               .WORD   NEXT
1037   0611 52 0D               .WORD   DATA
1038   0613 E4 0E               .WORD   INPUT
1039   0615 19 12               .WORD   DIM
1040   0617 13 0F               .WORD   READ
1041   0619 69 0D               .WORD   LET
1042   061B 0F 0D               .WORD   GOTO
1043   061D F2 0C               .WORD   RUN
1044   061F E1 0D               .WORD   IF
1045   0621 CB 0B               .WORD   RESTOR
1046   0623 FE 0C               .WORD   GOSUB
1047   0625 2D 0D               .WORD   RETURN
1048   0627 54 0D               .WORD   REM
1049   0629 03 0C               .WORD   STOP
1050   062B 52 17               .WORD   POUT
1051   062D C3 0D               .WORD   ON
1052   062F 44 0C               .WORD   NULL
1053   0631 58 17               .WORD   WAIT
1054   0633 F7 13               .WORD   DEF
1055   0635 A1 17               .WORD   POKE
1056   0637 E9 1E               .WORD   DOKE
1057   0639 54 0D               .WORD   REM
1058   063B CF 1E               .WORD   LINES
1059   063D C2 1E               .WORD   CLS
1060   063F C7 1E               .WORD   WIDTH
1061   0641 FF 1F               .WORD   MONITR
1062   0643 04 31               .WORD   PSET
1063   0645 07 31               .WORD   RESET
1064   0647 05 0E               .WORD   PRINT
1065   0649 31 0C               .WORD   CONT
1066   064B 77 0A               .WORD   LIST
1067   064D AC 0C               .WORD   CLEAR
1068   064F 54 0D               .WORD   REM
1069   0651 54 0D               .WORD   REM
1070   0653 6F 08               .WORD   NEW
1071   0655             
1072   0655             ; RESERVED WORD TOKEN VALUES
1073   0655             
1074   0655             ZEND    .EQU    080H            ; END
1075   0655             ZFOR    .EQU    081H            ; FOR
1076   0655             ZDATA   .EQU    083H            ; DATA
1077   0655             ZGOTO   .EQU    088H            ; GOTO
1078   0655             ZGOSUB  .EQU    08CH            ; GOSUB
1079   0655             ZREM    .EQU    08EH            ; REM
1080   0655             ZPRINT  .EQU    09EH            ; PRINT
1081   0655             ZNEW    .EQU    0A4H            ; NEW
1082   0655             
1083   0655             ZTAB    .EQU    0A5H            ; TAB
1084   0655             ZTO     .EQU    0A6H            ; TO
1085   0655             ZFN     .EQU    0A7H            ; FN
1086   0655             ZSPC    .EQU    0A8H            ; SPC
1087   0655             ZTHEN   .EQU    0A9H            ; THEN
1088   0655             ZNOT    .EQU    0AAH            ; NOT
1089   0655             ZSTEP   .EQU    0ABH            ; STEP
1090   0655             
1091   0655             ZPLUS   .EQU    0ACH            ; +
1092   0655             ZMINUS  .EQU    0ADH            ; -
1093   0655             ZTIMES  .EQU    0AEH            ; *
1094   0655             ZDIV    .EQU    0AFH            ; /
1095   0655             ZOR     .EQU    0B2H            ; OR
1096   0655             ZGTR    .EQU    0B3H            ; >
1097   0655             ZEQUAL  .EQU    0B4H            ; M
1098   0655             ZLTH    .EQU    0B5H            ; <
1099   0655             ZSGN    .EQU    0B6H            ; SGN
1100   0655             ZPOINT  .EQU    0C7H            ; POINT
1101   0655             ZLEFT   .EQU    0CDH +2         ; LEFT$
1102   0655             
1103   0655             ; ARITHMETIC PRECEDENCE TABLE
1104   0655             
1105   0655 79          PRITAB: .BYTE   79H             ; Precedence value
1106   0656 8B 1B               .WORD   PADD            ; FPREG = <last> + FPREG
1107   0658             
1108   0658 79                  .BYTE   79H             ; Precedence value
1109   0659 BF 17               .WORD   PSUB            ; FPREG = <last> - FPREG
1110   065B             
1111   065B 7C                  .BYTE   7CH             ; Precedence value
1112   065C FD 18               .WORD   MULT            ; PPREG = <last> * FPREG
1113   065E             
1114   065E 7C                  .BYTE   7CH             ; Precedence value
1115   065F 5E 19               .WORD   DIV             ; FPREG = <last> / FPREG
1116   0661             
1117   0661 7F                  .BYTE   7FH             ; Precedence value
1118   0662 AC 1C               .WORD   POWER           ; FPREG = <last> ^ FPREG
1119   0664             
1120   0664 50                  .BYTE   50H             ; Precedence value
1121   0665 72 11               .WORD   PAND            ; FPREG = <last> AND FPREG
1122   0667             
1123   0667 46                  .BYTE   46H             ; Precedence value
1124   0668 71 11               .WORD   POR             ; FPREG = <last> OR FPREG
1125   066A             
1126   066A             ; BASIC ERROR CODE LIST
1127   066A             
1128   066A 4E 46       ERRORS: .BYTE   "NF"            ; NEXT without FOR
1129   066C 53 4E               .BYTE   "SN"            ; Syntax error
1130   066E 52 47               .BYTE   "RG"            ; RETURN without GOSUB
1131   0670 4F 44               .BYTE   "OD"            ; Out of DATA
1132   0672 46 43               .BYTE   "FC"            ; Illegal function call
1133   0674 4F 56               .BYTE   "OV"            ; Overflow error
1134   0676 4F 4D               .BYTE   "OM"            ; Out of memory
1135   0678 55 4C               .BYTE   "UL"            ; Undefined line
1136   067A 42 53               .BYTE   "BS"            ; Bad subscript
1137   067C 44 44               .BYTE   "DD"            ; Re-DIMensioned array
1138   067E 2F 30               .BYTE   "/0"            ; Division by zero
1139   0680 49 44               .BYTE   "ID"            ; Illegal direct
1140   0682 54 4D               .BYTE   "TM"            ; Type mis-match
1141   0684 4F 53               .BYTE   "OS"            ; Out of string space
1142   0686 4C 53               .BYTE   "LS"            ; String too long
1143   0688 53 54               .BYTE   "ST"            ; String formula too complex
1144   068A 43 4E               .BYTE   "CN"            ; Can't CONTinue
1145   068C 55 46               .BYTE   "UF"            ; Undefined FN function
1146   068E 4D 4F               .BYTE   "MO"            ; Missing operand
1147   0690 48 58               .BYTE   "HX"            ; HEX error
1148   0692 42 4E               .BYTE   "BN"            ; BIN error
1149   0694             
1150   0694             ; INITIALISATION TABLE -------------------------------------------------------
1151   0694             
1152   0694 C3 5A 04    INITAB: JP      WARMST          ; Warm start jump
1153   0697 C3 82 0C            JP      FCERR           ; "USR (X)" jump (Set to Error)
1154   069A D3 00               OUT     (0),A           ; "OUT p,n" skeleton
1155   069C C9                  RET
1156   069D D6 00               SUB     0               ; Division support routine
1157   069F 6F                  LD      L,A
1158   06A0 7C                  LD      A,H
1159   06A1 DE 00               SBC     A,0
1160   06A3 67                  LD      H,A
1161   06A4 78                  LD      A,B
1162   06A5 DE 00               SBC     A,0
1163   06A7 47                  LD      B,A
1164   06A8 3E 00               LD      A,0
1165   06AA C9                  RET
1166   06AB 00 00 00            .BYTE   0,0,0                   ; Random number seed table used by RND
1167   06AE 35 4A CA 99         .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
1168   06B2 39 1C 76 98         .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
1169   06B6 22 95 B3 98         .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
1170   06BA 0A DD 47 98         .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
1171   06BE 53 D1 99 99         .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
1172   06C2 0A 1A 9F 98         .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
1173   06C6 65 BC CD 98         .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
1174   06CA D6 77 3E 98         .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
1175   06CE 52 C7 4F 80         .BYTE   052H,0C7H,04FH,080H     ; Last random number
1176   06D2 DB 00               IN      A,(0)           ; INP (x) skeleton
1177   06D4 C9                  RET
1178   06D5 01                  .BYTE   1               ; POS (x) number (1)
1179   06D6 FF                  .BYTE   255             ; Terminal width (255 = no auto CRLF)
1180   06D7 1C                  .BYTE   28              ; Width for commas (3 columns)
1181   06D8 00                  .BYTE   0               ; No nulls after input bytes
1182   06D9 00                  .BYTE   0               ; Output enabled (^O off)
1183   06DA 14 00               .WORD   20              ; Initial lines counter
1184   06DC 14 00               .WORD   20              ; Initial lines number
1185   06DE 00 00               .WORD   0               ; Array load/save check sum
1186   06E0 00                  .BYTE   0               ; Break not by NMI
1187   06E1 00                  .BYTE   0               ; Break flag
1188   06E2 C3 A8 09            JP      TTYLIN          ; Input reflection (set to TTY)
1189   06E5 C3 00 00            JP      $0000           ; POINT reflection unused
1190   06E8 C3 00 00            JP      $0000           ; SET reflection
1191   06EB C3 00 00            JP      $0000          	; RESET reflection
1192   06EE 0D 32               .WORD   STLOOK          ; Temp string space
1193   06F0 FE FF               .WORD   -2              ; Current line number (cold)
1194   06F2 AA 31               .WORD   PROGST+1        ; Start of program text
1195   06F4             INITBE:                         
1196   06F4             
1197   06F4             ; END OF INITIALISATION TABLE ---------------------------------------------------
1198   06F4             
1199   06F4 20 45 72 72 ERRMSG: .BYTE   " Error",0
1199   06F8 6F 72 00 
1200   06FB 20 69 6E 20 INMSG:  .BYTE   " in ",0
1200   06FF 00 
1201   0700             ZERBYT  .EQU    $-1             ; A zero byte
1202   0700 4F 6B 0D 0A OKMSG:  .BYTE   "Ok",CR,LF,0,0
1202   0704 00 00 
1203   0706 42 72 65 61 BRKMSG: .BYTE   "Break",0
1203   070A 6B 00 
1204   070C             
1205   070C 21 04 00    BAKSTK: LD      HL,4            ; Look for "FOR" block with
1206   070F 39                  ADD     HL,SP           ; same index as specified
1207   0710 7E          LOKFOR: LD      A,(HL)          ; Get block ID
1208   0711 23                  INC     HL              ; Point to index address
1209   0712 FE 81               CP      ZFOR            ; Is it a "FOR" token
1210   0714 C0                  RET     NZ              ; No - exit
1211   0715 4E                  LD      C,(HL)          ; BC = Address of "FOR" index
1212   0716 23                  INC     HL
1213   0717 46                  LD      B,(HL)
1214   0718 23                  INC     HL              ; Point to sign of STEP
1215   0719 E5                  PUSH    HL              ; Save pointer to sign
1216   071A 69                  LD      L,C             ; HL = address of "FOR" index
1217   071B 60                  LD      H,B
1218   071C 7A                  LD      A,D             ; See if an index was specified
1219   071D B3                  OR      E               ; DE = 0 if no index specified
1220   071E EB                  EX      DE,HL           ; Specified index into HL
1221   071F CA 26 07            JP      Z,INDFND        ; Skip if no index given
1222   0722 EB                  EX      DE,HL           ; Index back into DE
1223   0723 CD 2B 0A            CALL    CPDEHL          ; Compare index with one given
1224   0726 01 0D 00    INDFND: LD      BC,16-3         ; Offset to next block
1225   0729 E1                  POP     HL              ; Restore pointer to sign
1226   072A C8                  RET     Z               ; Return if block found
1227   072B 09                  ADD     HL,BC           ; Point to next block
1228   072C C3 10 07            JP      LOKFOR          ; Keep on looking
1229   072F             
1230   072F CD 49 07    MOVUP:  CALL    ENFMEM          ; See if enough memory
1231   0732 C5          MOVSTR: PUSH    BC              ; Save end of source
1232   0733 E3                  EX      (SP),HL         ; Swap source and dest" end
1233   0734 C1                  POP     BC              ; Get end of destination
1234   0735 CD 2B 0A    MOVLP:  CALL    CPDEHL          ; See if list moved
1235   0738 7E                  LD      A,(HL)          ; Get byte
1236   0739 02                  LD      (BC),A          ; Move it
1237   073A C8                  RET     Z               ; Exit if all done
1238   073B 0B                  DEC     BC              ; Next byte to move to
1239   073C 2B                  DEC     HL              ; Next byte to move
1240   073D C3 35 07            JP      MOVLP           ; Loop until all bytes moved
1241   0740             
1242   0740 E5          CHKSTK: PUSH    HL              ; Save code string address
1243   0741 2A 8A 31            LD      HL,(ARREND)     ; Lowest free memory
1244   0744 06 00               LD      B,0             ; BC = Number of levels to test
1245   0746 09                  ADD     HL,BC           ; 2 Bytes for each level
1246   0747 09                  ADD     HL,BC
1247   0748 3E                  .BYTE   3EH             ; Skip "PUSH HL"
1248   0749 E5          ENFMEM: PUSH    HL              ; Save code string address
1249   074A 3E D0               LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
1250   074C 95                  SUB     L
1251   074D 6F                  LD      L,A
1252   074E 3E FF               LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
1253   0750 9C                  SBC     A,H
1254   0751 DA 58 07            JP      C,OMERR         ; Not enough - ?OM Error
1255   0754 67                  LD      H,A
1256   0755 39                  ADD     HL,SP           ; Test if stack is overflowed
1257   0756 E1                  POP     HL              ; Restore code string address
1258   0757 D8                  RET     C               ; Return if enough mmory
1259   0758 1E 0C       OMERR:  LD      E,OM            ; ?OM Error
1260   075A C3 77 07            JP      ERROR
1261   075D             
1262   075D 2A 79 31    DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
1263   0760 22 0C 31            LD      (LINEAT),HL     ; Save as current line
1264   0763 1E 02       SNERR:  LD      E,SN            ; ?SN Error
1265   0765 01                  .BYTE   01H             ; Skip "LD E,DZ"
1266   0766 1E 14       DZERR:  LD      E,DZ            ; ?/0 Error
1267   0768 01                  .BYTE   01H             ; Skip "LD E,NF"
1268   0769 1E 00       NFERR:  LD      E,NF            ; ?NF Error
1269   076B 01                  .BYTE   01H             ; Skip "LD E,DD"
1270   076C 1E 12       DDERR:  LD      E,DD            ; ?DD Error
1271   076E 01                  .BYTE   01H             ; Skip "LD E,UF"
1272   076F 1E 22       UFERR:  LD      E,UF            ; ?UF Error
1273   0771 01                  .BYTE   01H             ; Skip "LD E,OV
1274   0772 1E 0A       OVERR:  LD      E,OV            ; ?OV Error
1275   0774 01                  .BYTE   01H             ; Skip "LD E,TM"
1276   0775 1E 18       TMERR:  LD      E,TM            ; ?TM Error
1277   0777             
1278   0777 CD 95 08    ERROR:  CALL    CLREG           ; Clear registers and stack
1279   077A 32 F5 30            LD      (CTLOFG),A      ; Enable output (A is 0)
1280   077D CD 56 0E            CALL    STTLIN          ; Start new line
1281   0780 21 6A 06            LD      HL,ERRORS       ; Point to error codes
1282   0783 57                  LD      D,A             ; D = 0 (A is 0)
1283   0784 3E 3F               LD      A,'?'
1284   0786 CD 3C 0A            CALL    OUTC            ; Output '?'
1285   0789 19                  ADD     HL,DE           ; Offset to correct error code
1286   078A 7E                  LD      A,(HL)          ; First character
1287   078B CD 3C 0A            CALL    OUTC            ; Output it
1288   078E CD BB 0B            CALL    GETCHR          ; Get next character
1289   0791 CD 3C 0A            CALL    OUTC            ; Output it
1290   0794 21 F4 06            LD      HL,ERRMSG       ; "Error" message
1291   0797 CD 01 15    ERRIN:  CALL    PRS             ; Output message
1292   079A 2A 0C 31            LD      HL,(LINEAT)     ; Get line of error
1293   079D 11 FE FF            LD      DE,-2           ; Cold start error if -2
1294   07A0 CD 2B 0A            CALL    CPDEHL          ; See if cold start error
1295   07A3 CA C7 03            JP      Z,CSTART        ; Cold start error - Restart
1296   07A6 7C                  LD      A,H             ; Was it a direct error?
1297   07A7 A5                  AND     L               ; Line = -1 if direct error
1298   07A8 3C                  INC     A
1299   07A9 C4 9C 1B            CALL    NZ,LINEIN       ; No - output line of error
1300   07AC 3E                  .BYTE   3EH             ; Skip "POP BC"
1301   07AD C1          POPNOK: POP     BC              ; Drop address in input buffer
1302   07AE             
1303   07AE AF          PRNTOK: XOR     A               ; Output "Ok" and get command
1304   07AF 32 F5 30            LD      (CTLOFG),A      ; Enable output
1305   07B2 CD 56 0E            CALL    STTLIN          ; Start new line
1306   07B5 21 00 07            LD      HL,OKMSG        ; "Ok" message
1307   07B8 CD 01 15            CALL    PRS             ; Output "Ok"
1308   07BB 21 FF FF    GETCMD: LD      HL,-1           ; Flag direct mode
1309   07BE 22 0C 31            LD      (LINEAT),HL     ; Save as current line
1310   07C1 CD A8 09            CALL    GETLIN          ; Get an input line
1311   07C4 DA BB 07            JP      C,GETCMD        ; Get line again if break
1312   07C7 CD BB 0B            CALL    GETCHR          ; Get first character
1313   07CA 3C                  INC     A               ; Test if end of line
1314   07CB 3D                  DEC     A               ; Without affecting Carry
1315   07CC CA BB 07            JP      Z,GETCMD        ; Nothing entered - Get another
1316   07CF F5                  PUSH    AF              ; Save Carry status
1317   07D0 CD 87 0C            CALL    ATOH            ; Get line number into DE
1318   07D3 D5                  PUSH    DE              ; Save line number
1319   07D4 CD BF 08            CALL    CRUNCH          ; Tokenise rest of line
1320   07D7 47                  LD      B,A             ; Length of tokenised line
1321   07D8 D1                  POP     DE              ; Restore line number
1322   07D9 F1                  POP     AF              ; Restore Carry
1323   07DA D2 9B 0B            JP      NC,EXCUTE       ; No line number - Direct mode
1324   07DD D5                  PUSH    DE              ; Save line number
1325   07DE C5                  PUSH    BC              ; Save length of tokenised line
1326   07DF AF                  XOR     A
1327   07E0 32 7C 31            LD      (LSTBIN),A      ; Clear last byte input
1328   07E3 CD BB 0B            CALL    GETCHR          ; Get next character
1329   07E6 B7                  OR      A               ; Set flags
1330   07E7 F5                  PUSH    AF              ; And save them
1331   07E8 CD 4F 08            CALL    SRCHLN          ; Search for line number in DE
1332   07EB DA F4 07            JP      C,LINFND        ; Jump if line found
1333   07EE F1                  POP     AF              ; Get status
1334   07EF F5                  PUSH    AF              ; And re-save
1335   07F0 CA 28 0D            JP      Z,ULERR         ; Nothing after number - Error
1336   07F3 B7                  OR      A               ; Clear Carry
1337   07F4 C5          LINFND: PUSH    BC              ; Save address of line in prog
1338   07F5 D2 0B 08            JP      NC,INEWLN       ; Line not found - Insert new
1339   07F8 EB                  EX      DE,HL           ; Next line address in DE
1340   07F9 2A 86 31            LD      HL,(PROGND)     ; End of program
1341   07FC 1A          SFTPRG: LD      A,(DE)          ; Shift rest of program down
1342   07FD 02                  LD      (BC),A
1343   07FE 03                  INC     BC              ; Next destination
1344   07FF 13                  INC     DE              ; Next source
1345   0800 CD 2B 0A            CALL    CPDEHL          ; All done?
1346   0803 C2 FC 07            JP      NZ,SFTPRG       ; More to do
1347   0806 60                  LD      H,B             ; HL - New end of program
1348   0807 69                  LD      L,C
1349   0808 22 86 31            LD      (PROGND),HL     ; Update end of program
1350   080B             
1351   080B D1          INEWLN: POP     DE              ; Get address of line,
1352   080C F1                  POP     AF              ; Get status
1353   080D CA 32 08            JP      Z,SETPTR        ; No text - Set up pointers
1354   0810 2A 86 31            LD      HL,(PROGND)     ; Get end of program
1355   0813 E3                  EX      (SP),HL         ; Get length of input line
1356   0814 C1                  POP     BC              ; End of program to BC
1357   0815 09                  ADD     HL,BC           ; Find new end
1358   0816 E5                  PUSH    HL              ; Save new end
1359   0817 CD 2F 07            CALL    MOVUP           ; Make space for line
1360   081A E1                  POP     HL              ; Restore new end
1361   081B 22 86 31            LD      (PROGND),HL     ; Update end of program pointer
1362   081E EB                  EX      DE,HL           ; Get line to move up in HL
1363   081F 74                  LD      (HL),H          ; Save MSB
1364   0820 D1                  POP     DE              ; Get new line number
1365   0821 23                  INC     HL              ; Skip pointer
1366   0822 23                  INC     HL
1367   0823 73                  LD      (HL),E          ; Save LSB of line number
1368   0824 23                  INC     HL
1369   0825 72                  LD      (HL),D          ; Save MSB of line number
1370   0826 23                  INC     HL              ; To first byte in line
1371   0827 11 11 31            LD      DE,BUFFER       ; Copy buffer to program
1372   082A 1A          MOVBUF: LD      A,(DE)          ; Get source
1373   082B 77                  LD      (HL),A          ; Save destinations
1374   082C 23                  INC     HL              ; Next source
1375   082D 13                  INC     DE              ; Next destination
1376   082E B7                  OR      A               ; Done?
1377   082F C2 2A 08            JP      NZ,MOVBUF       ; No - Repeat
1378   0832 CD 7B 08    SETPTR: CALL    RUNFST          ; Set line pointers
1379   0835 23                  INC     HL              ; To LSB of pointer
1380   0836 EB                  EX      DE,HL           ; Address to DE
1381   0837 62          PTRLP:  LD      H,D             ; Address to HL
1382   0838 6B                  LD      L,E
1383   0839 7E                  LD      A,(HL)          ; Get LSB of pointer
1384   083A 23                  INC     HL              ; To MSB of pointer
1385   083B B6                  OR      (HL)            ; Compare with MSB pointer
1386   083C CA BB 07            JP      Z,GETCMD        ; Get command line if end
1387   083F 23                  INC     HL              ; To LSB of line number
1388   0840 23                  INC     HL              ; Skip line number
1389   0841 23                  INC     HL              ; Point to first byte in line
1390   0842 AF                  XOR     A               ; Looking for 00 byte
1391   0843 BE          FNDEND: CP      (HL)            ; Found end of line?
1392   0844 23                  INC     HL              ; Move to next byte
1393   0845 C2 43 08            JP      NZ,FNDEND       ; No - Keep looking
1394   0848 EB                  EX      DE,HL           ; Next line address to HL
1395   0849 73                  LD      (HL),E          ; Save LSB of pointer
1396   084A 23                  INC     HL
1397   084B 72                  LD      (HL),D          ; Save MSB of pointer
1398   084C C3 37 08            JP      PTRLP           ; Do next line
1399   084F             
1400   084F 2A 0E 31    SRCHLN: LD      HL,(BASTXT)     ; Start of program text
1401   0852 44          SRCHLP: LD      B,H             ; BC = Address to look at
1402   0853 4D                  LD      C,L
1403   0854 7E                  LD      A,(HL)          ; Get address of next line
1404   0855 23                  INC     HL
1405   0856 B6                  OR      (HL)            ; End of program found?
1406   0857 2B                  DEC     HL
1407   0858 C8                  RET     Z               ; Yes - Line not found
1408   0859 23                  INC     HL
1409   085A 23                  INC     HL
1410   085B 7E                  LD      A,(HL)          ; Get LSB of line number
1411   085C 23                  INC     HL
1412   085D 66                  LD      H,(HL)          ; Get MSB of line number
1413   085E 6F                  LD      L,A
1414   085F CD 2B 0A            CALL    CPDEHL          ; Compare with line in DE
1415   0862 60                  LD      H,B             ; HL = Start of this line
1416   0863 69                  LD      L,C
1417   0864 7E                  LD      A,(HL)          ; Get LSB of next line address
1418   0865 23                  INC     HL
1419   0866 66                  LD      H,(HL)          ; Get MSB of next line address
1420   0867 6F                  LD      L,A             ; Next line to HL
1421   0868 3F                  CCF
1422   0869 C8                  RET     Z               ; Lines found - Exit
1423   086A 3F                  CCF
1424   086B D0                  RET     NC              ; Line not found,at line after
1425   086C C3 52 08            JP      SRCHLP          ; Keep looking
1426   086F             
1427   086F C0          NEW:    RET     NZ              ; Return if any more on line
1428   0870 2A 0E 31    CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
1429   0873 AF                  XOR     A               ; Set program area to empty
1430   0874 77                  LD      (HL),A          ; Save LSB = 00
1431   0875 23                  INC     HL
1432   0876 77                  LD      (HL),A          ; Save MSB = 00
1433   0877 23                  INC     HL
1434   0878 22 86 31            LD      (PROGND),HL     ; Set program end
1435   087B             
1436   087B 2A 0E 31    RUNFST: LD      HL,(BASTXT)     ; Clear all variables
1437   087E 2B                  DEC     HL
1438   087F             
1439   087F 22 7E 31    INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
1440   0882 2A 5F 31            LD      HL,(LSTRAM)     ; Get end of RAM
1441   0885 22 73 31            LD      (STRBOT),HL     ; Clear string space
1442   0888 AF                  XOR     A
1443   0889 CD CB 0B            CALL    RESTOR          ; Reset DATA pointers
1444   088C 2A 86 31            LD      HL,(PROGND)     ; Get end of program
1445   088F 22 88 31            LD      (VAREND),HL     ; Clear variables
1446   0892 22 8A 31            LD      (ARREND),HL     ; Clear arrays
1447   0895             
1448   0895 C1          CLREG:  POP     BC              ; Save return address
1449   0896 2A 0A 31            LD      HL,(STRSPC)     ; Get end of working RAN
1450   0899 F9                  LD      SP,HL           ; Set stack
1451   089A 21 63 31            LD      HL,TMSTPL       ; Temporary string pool
1452   089D 22 61 31            LD      (TMSTPT),HL     ; Reset temporary string ptr
1453   08A0 AF                  XOR     A               ; A = 00
1454   08A1 6F                  LD      L,A             ; HL = 0000
1455   08A2 67                  LD      H,A
1456   08A3 22 84 31            LD      (CONTAD),HL     ; No CONTinue
1457   08A6 32 7B 31            LD      (FORFLG),A      ; Clear FOR flag
1458   08A9 22 8E 31            LD      (FNRGNM),HL     ; Clear FN argument
1459   08AC E5                  PUSH    HL              ; HL = 0000
1460   08AD C5                  PUSH    BC              ; Put back return
1461   08AE 2A 7E 31    DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
1462   08B1 C9                  RET                     ; Return to execution driver
1463   08B2             
1464   08B2 3E 3F       PROMPT: LD      A,'?'           ; '?'
1465   08B4 CD 3C 0A            CALL    OUTC            ; Output character
1466   08B7 3E 20               LD      A,' '           ; Space
1467   08B9 CD 3C 0A            CALL    OUTC            ; Output character
1468   08BC C3 FE 30            JP      RINPUT          ; Get input line
1469   08BF             
1470   08BF AF          CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
1471   08C0 32 5E 31            LD      (DATFLG),A      ; Reset literal flag
1472   08C3 0E 05               LD      C,2+3           ; 2 byte number and 3 nulls
1473   08C5 11 11 31            LD      DE,BUFFER       ; Start of input buffer
1474   08C8 7E          CRNCLP: LD      A,(HL)          ; Get byte
1475   08C9 FE 20               CP      ' '             ; Is it a space?
1476   08CB CA 47 09            JP      Z,MOVDIR        ; Yes - Copy direct
1477   08CE 47                  LD      B,A             ; Save character
1478   08CF FE 22               CP      '"'             ; Is it a quote?
1479   08D1 CA 67 09            JP      Z,CPYLIT        ; Yes - Copy literal string
1480   08D4 B7                  OR      A               ; Is it end of buffer?
1481   08D5 CA 6E 09            JP      Z,ENDBUF        ; Yes - End buffer
1482   08D8 3A 5E 31            LD      A,(DATFLG)      ; Get data type
1483   08DB B7                  OR      A               ; Literal?
1484   08DC 7E                  LD      A,(HL)          ; Get byte to copy
1485   08DD C2 47 09            JP      NZ,MOVDIR       ; Literal - Copy direct
1486   08E0 FE 3F               CP      '?'             ; Is it '?' short for PRINT
1487   08E2 3E 9E               LD      A,ZPRINT        ; "PRINT" token
1488   08E4 CA 47 09            JP      Z,MOVDIR        ; Yes - replace it
1489   08E7 7E                  LD      A,(HL)          ; Get byte again
1490   08E8 FE 30               CP      '0'             ; Is it less than '0'
1491   08EA DA F2 08            JP      C,FNDWRD        ; Yes - Look for reserved words
1492   08ED FE 3C               CP      60; ";"+1           ; Is it "0123456789:;" ?
1493   08EF DA 47 09            JP      C,MOVDIR        ; Yes - copy it direct
1494   08F2 D5          FNDWRD: PUSH    DE              ; Look for reserved words
1495   08F3 11 EB 04            LD      DE,WORDS-1      ; Point to table
1496   08F6 C5                  PUSH    BC              ; Save count
1497   08F7 01 43 09            LD      BC,RETNAD       ; Where to return to
1498   08FA C5                  PUSH    BC              ; Save return address
1499   08FB 06 7F               LD      B,ZEND-1        ; First token value -1
1500   08FD 7E                  LD      A,(HL)          ; Get byte
1501   08FE FE 61               CP      'a'             ; Less than 'a' ?
1502   0900 DA 0B 09            JP      C,SEARCH        ; Yes - search for words
1503   0903 FE 7B               CP      'z'+1           ; Greater than 'z' ?
1504   0905 D2 0B 09            JP      NC,SEARCH       ; Yes - search for words
1505   0908 E6 5F               AND     01011111B       ; Force upper case
1506   090A 77                  LD      (HL),A          ; Replace byte
1507   090B 4E          SEARCH: LD      C,(HL)          ; Search for a word
1508   090C EB                  EX      DE,HL
1509   090D 23          GETNXT: INC     HL              ; Get next reserved word
1510   090E B6                  OR      (HL)            ; Start of word?
1511   090F F2 0D 09            JP      P,GETNXT        ; No - move on
1512   0912 04                  INC     B               ; Increment token value
1513   0913 7E                  LD      A, (HL)         ; Get byte from table
1514   0914 E6 7F               AND     01111111B       ; Strip bit 7
1515   0916 C8                  RET     Z               ; Return if end of list
1516   0917 B9                  CP      C               ; Same character as in buffer?
1517   0918 C2 0D 09            JP      NZ,GETNXT       ; No - get next word
1518   091B EB                  EX      DE,HL
1519   091C E5                  PUSH    HL              ; Save start of word
1520   091D             
1521   091D 13          NXTBYT: INC     DE              ; Look through rest of word
1522   091E 1A                  LD      A,(DE)          ; Get byte from table
1523   091F B7                  OR      A               ; End of word ?
1524   0920 FA 3F 09            JP      M,MATCH         ; Yes - Match found
1525   0923 4F                  LD      C,A             ; Save it
1526   0924 78                  LD      A,B             ; Get token value
1527   0925 FE 88               CP      ZGOTO           ; Is it "GOTO" token ?
1528   0927 C2 2E 09            JP      NZ,NOSPC        ; No - Don't allow spaces
1529   092A CD BB 0B            CALL    GETCHR          ; Get next character
1530   092D 2B                  DEC     HL              ; Cancel increment from GETCHR
1531   092E 23          NOSPC:  INC     HL              ; Next byte
1532   092F 7E                  LD      A,(HL)          ; Get byte
1533   0930 FE 61               CP      'a'             ; Less than 'a' ?
1534   0932 DA 37 09            JP      C,NOCHNG        ; Yes - don't change
1535   0935 E6 5F               AND     01011111B       ; Make upper case
1536   0937 B9          NOCHNG: CP      C               ; Same as in buffer ?
1537   0938 CA 1D 09            JP      Z,NXTBYT        ; Yes - keep testing
1538   093B E1                  POP     HL              ; Get back start of word
1539   093C C3 0B 09            JP      SEARCH          ; Look at next word
1540   093F             
1541   093F 48          MATCH:  LD      C,B             ; Word found - Save token value
1542   0940 F1                  POP     AF              ; Throw away return
1543   0941 EB                  EX      DE,HL
1544   0942 C9                  RET                     ; Return to "RETNAD"
1545   0943 EB          RETNAD: EX      DE,HL           ; Get address in string
1546   0944 79                  LD      A,C             ; Get token value
1547   0945 C1                  POP     BC              ; Restore buffer length
1548   0946 D1                  POP     DE              ; Get destination address
1549   0947 23          MOVDIR: INC     HL              ; Next source in buffer
1550   0948 12                  LD      (DE),A          ; Put byte in buffer
1551   0949 13                  INC     DE              ; Move up buffer
1552   094A 0C                  INC     C               ; Increment length of buffer
1553   094B D6 3A               SUB     ':'             ; End of statement?
1554   094D CA 55 09            JP      Z,SETLIT        ; Jump if multi-statement line
1555   0950 FE 49               CP      ZDATA-3AH       ; Is it DATA statement ?
1556   0952 C2 58 09            JP      NZ,TSTREM       ; No - see if REM
1557   0955 32 5E 31    SETLIT: LD      (DATFLG),A      ; Set literal flag
1558   0958 D6 54       TSTREM: SUB     ZREM-3AH        ; Is it REM?
1559   095A C2 C8 08            JP      NZ,CRNCLP       ; No - Leave flag
1560   095D 47                  LD      B,A             ; Copy rest of buffer
1561   095E 7E          NXTCHR: LD      A,(HL)          ; Get byte
1562   095F B7                  OR      A               ; End of line ?
1563   0960 CA 6E 09            JP      Z,ENDBUF        ; Yes - Terminate buffer
1564   0963 B8                  CP      B               ; End of statement ?
1565   0964 CA 47 09            JP      Z,MOVDIR        ; Yes - Get next one
1566   0967 23          CPYLIT: INC     HL              ; Move up source string
1567   0968 12                  LD      (DE),A          ; Save in destination
1568   0969 0C                  INC     C               ; Increment length
1569   096A 13                  INC     DE              ; Move up destination
1570   096B C3 5E 09            JP      NXTCHR          ; Repeat
1571   096E             
1572   096E 21 10 31    ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
1573   0971 12                  LD      (DE),A          ; Mark end of buffer (A = 00)
1574   0972 13                  INC     DE
1575   0973 12                  LD      (DE),A          ; A = 00
1576   0974 13                  INC     DE
1577   0975 12                  LD      (DE),A          ; A = 00
1578   0976 C9                  RET
1579   0977             
1580   0977 3A F4 30    DODEL:  LD      A,(NULFLG)      ; Get null flag status
1581   097A B7                  OR      A               ; Is it zero?
1582   097B 3E 00               LD      A,0             ; Zero A - Leave flags
1583   097D 32 F4 30            LD      (NULFLG),A      ; Zero null flag
1584   0980 C2 8B 09            JP      NZ,ECHDEL       ; Set - Echo it
1585   0983 05                  DEC     B               ; Decrement length
1586   0984 CA A8 09            JP      Z,GETLIN        ; Get line again if empty
1587   0987 CD 3C 0A            CALL    OUTC            ; Output null character
1588   098A 3E                  .BYTE   3EH             ; Skip "DEC B"
1589   098B 05          ECHDEL: DEC     B               ; Count bytes in buffer
1590   098C 2B                  DEC     HL              ; Back space buffer
1591   098D CA 9F 09            JP      Z,OTKLN         ; No buffer - Try again
1592   0990 7E                  LD      A,(HL)          ; Get deleted byte
1593   0991 CD 3C 0A            CALL    OUTC            ; Echo it
1594   0994 C3 B1 09            JP      MORINP          ; Get more input
1595   0997             
1596   0997 05          DELCHR: DEC     B               ; Count bytes in buffer
1597   0998 2B                  DEC     HL              ; Back space buffer
1598   0999 CD 3C 0A            CALL    OUTC            ; Output character in A
1599   099C C2 B1 09            JP      NZ,MORINP       ; Not end - Get more
1600   099F CD 3C 0A    OTKLN:  CALL    OUTC            ; Output character in A
1601   09A2 CD 63 0E    KILIN:  CALL    PRNTCRLF        ; Output CRLF
1602   09A5 C3 A8 09            JP      TTYLIN          ; Get line again
1603   09A8             
1604   09A8             GETLIN:
1605   09A8 21 11 31    TTYLIN: LD      HL,BUFFER       ; Get a line by character
1606   09AB 06 01               LD      B,1             ; Set buffer as empty
1607   09AD AF                  XOR     A
1608   09AE 32 F4 30            LD      (NULFLG),A      ; Clear null flag
1609   09B1 CD 66 0A    MORINP: CALL    CLOTST          ; Get character and test ^O
1610   09B4 4F                  LD      C,A             ; Save character in C
1611   09B5 FE 7F               CP      DEL             ; Delete character?
1612   09B7 CA 77 09            JP      Z,DODEL         ; Yes - Process it
1613   09BA 3A F4 30            LD      A,(NULFLG)      ; Get null flag
1614   09BD B7                  OR      A               ; Test null flag status
1615   09BE CA CA 09            JP      Z,PROCES        ; Reset - Process character
1616   09C1 3E 00               LD      A,0             ; Set a null
1617   09C3 CD 3C 0A            CALL    OUTC            ; Output null
1618   09C6 AF                  XOR     A               ; Clear A
1619   09C7 32 F4 30            LD      (NULFLG),A      ; Reset null flag
1620   09CA 79          PROCES: LD      A,C             ; Get character
1621   09CB FE 07               CP      CTRLG           ; Bell?
1622   09CD CA 0E 0A            JP      Z,PUTCTL        ; Yes - Save it
1623   09D0 FE 03               CP      CTRLC           ; Is it control "C"?
1624   09D2 CC 63 0E            CALL    Z,PRNTCRLF      ; Yes - Output CRLF
1625   09D5 37                  SCF                     ; Flag break
1626   09D6 C8                  RET     Z               ; Return if control "C"
1627   09D7 FE 0D               CP      CR              ; Is it enter?
1628   09D9 CA 5E 0E            JP      Z,ENDINP        ; Yes - Terminate input
1629   09DC FE 15               CP      CTRLU           ; Is it control "U"?
1630   09DE CA A2 09            JP      Z,KILIN         ; Yes - Get another line
1631   09E1 FE 40               CP      '@'             ; Is it "kill line"?
1632   09E3 CA 9F 09            JP      Z,OTKLN         ; Yes - Kill line
1633   09E6 FE 5F               CP      '_'             ; Is it delete?
1634   09E8 CA 97 09            JP      Z,DELCHR        ; Yes - Delete character
1635   09EB FE 08               CP      BKSP            ; Is it backspace?
1636   09ED CA 97 09            JP      Z,DELCHR        ; Yes - Delete character
1637   09F0 FE 12               CP      CTRLR           ; Is it control "R"?
1638   09F2 C2 09 0A            JP      NZ,PUTBUF       ; No - Put in buffer
1639   09F5 C5                  PUSH    BC              ; Save buffer length
1640   09F6 D5                  PUSH    DE              ; Save DE
1641   09F7 E5                  PUSH    HL              ; Save buffer address
1642   09F8 36 00               LD      (HL),0          ; Mark end of buffer
1643   09FA CD 13 20            CALL    OUTNCR          ; Output and do CRLF
1644   09FD 21 11 31            LD      HL,BUFFER       ; Point to buffer start
1645   0A00 CD 01 15            CALL    PRS             ; Output buffer
1646   0A03 E1                  POP     HL              ; Restore buffer address
1647   0A04 D1                  POP     DE              ; Restore DE
1648   0A05 C1                  POP     BC              ; Restore buffer length
1649   0A06 C3 B1 09            JP      MORINP          ; Get another character
1650   0A09             
1651   0A09 FE 20       PUTBUF: CP      ' '             ; Is it a control code?
1652   0A0B DA B1 09            JP      C,MORINP        ; Yes - Ignore
1653   0A0E 78          PUTCTL: LD      A,B             ; Get number of bytes in buffer
1654   0A0F FE 49               CP      72+1            ; Test for line overflow
1655   0A11 3E 07               LD      A,CTRLG         ; Set a bell
1656   0A13 D2 23 0A            JP      NC,OUTNBS       ; Ring bell if buffer full
1657   0A16 79                  LD      A,C             ; Get character
1658   0A17 71                  LD      (HL),C          ; Save in buffer
1659   0A18 32 7C 31            LD      (LSTBIN),A      ; Save last input byte
1660   0A1B 23                  INC     HL              ; Move up buffer
1661   0A1C 04                  INC     B               ; Increment length
1662   0A1D CD 3C 0A    OUTIT:  CALL    OUTC            ; Output the character entered
1663   0A20 C3 B1 09            JP      MORINP          ; Get another character
1664   0A23             
1665   0A23 CD 3C 0A    OUTNBS: CALL    OUTC            ; Output bell and back over it
1666   0A26 3E 08               LD      A,BKSP          ; Set back space
1667   0A28 C3 1D 0A            JP      OUTIT           ; Output it and get more
1668   0A2B             
1669   0A2B 7C          CPDEHL: LD      A,H             ; Get H
1670   0A2C 92                  SUB     D               ; Compare with D
1671   0A2D C0                  RET     NZ              ; Different - Exit
1672   0A2E 7D                  LD      A,L             ; Get L
1673   0A2F 93                  SUB     E               ; Compare with E
1674   0A30 C9                  RET                     ; Return status
1675   0A31             
1676   0A31 7E          CHKSYN: LD      A,(HL)          ; Check syntax of character
1677   0A32 E3                  EX      (SP),HL         ; Address of test byte
1678   0A33 BE                  CP      (HL)            ; Same as in code string?
1679   0A34 23                  INC     HL              ; Return address
1680   0A35 E3                  EX      (SP),HL         ; Put it back
1681   0A36 CA BB 0B            JP      Z,GETCHR        ; Yes - Get next character
1682   0A39 C3 63 07            JP      SNERR           ; Different - ?SN Error
1683   0A3C             
1684   0A3C F5          OUTC:   PUSH    AF              ; Save character
1685   0A3D 3A F5 30            LD      A,(CTLOFG)      ; Get control "O" flag
1686   0A40 B7                  OR      A               ; Is it set?
1687   0A41 C2 36 15            JP      NZ,POPAF        ; Yes - don't output
1688   0A44 F1                  POP     AF              ; Restore character
1689   0A45 C5                  PUSH    BC              ; Save buffer length
1690   0A46 F5                  PUSH    AF              ; Save character
1691   0A47 FE 20               CP      ' '             ; Is it a control code?
1692   0A49 DA 60 0A            JP      C,DINPOS        ; Yes - Don't INC POS(X)
1693   0A4C 3A F2 30            LD      A,(LWIDTH)      ; Get line width
1694   0A4F 47                  LD      B,A             ; To B
1695   0A50 3A 5B 31            LD      A,(CURPOS)      ; Get cursor position
1696   0A53 04                  INC     B               ; Width 255?
1697   0A54 CA 5C 0A            JP      Z,INCLEN        ; Yes - No width limit
1698   0A57 05                  DEC     B               ; Restore width
1699   0A58 B8                  CP      B               ; At end of line?
1700   0A59 CC 63 0E            CALL    Z,PRNTCRLF      ; Yes - output CRLF
1701   0A5C 3C          INCLEN: INC     A               ; Move on one character
1702   0A5D 32 5B 31            LD      (CURPOS),A      ; Save new position
1703   0A60 F1          DINPOS: POP     AF              ; Restore character
1704   0A61 C1                  POP     BC              ; Restore buffer length
1705   0A62 CD FC 1F            CALL    MONOUT          ; Send it
1706   0A65 C9                  RET
1707   0A66             
1708   0A66 CD C0 1E    CLOTST: CALL    GETINP          ; Get input character
1709   0A69 E6 7F               AND     01111111B       ; Strip bit 7
1710   0A6B FE 0F               CP      CTRLO           ; Is it control "O"?
1711   0A6D C0                  RET     NZ              ; No don't flip flag
1712   0A6E 3A F5 30            LD      A,(CTLOFG)      ; Get flag
1713   0A71 2F                  CPL                     ; Flip it
1714   0A72 32 F5 30            LD      (CTLOFG),A      ; Put it back
1715   0A75 AF                  XOR     A               ; Null character
1716   0A76 C9                  RET
1717   0A77             
1718   0A77 CD 87 0C    LIST:   CALL    ATOH            ; ASCII number to DE
1719   0A7A C0                  RET     NZ              ; Return if anything extra
1720   0A7B C1                  POP     BC              ; Rubbish - Not needed
1721   0A7C CD 4F 08            CALL    SRCHLN          ; Search for line number in DE
1722   0A7F C5                  PUSH    BC              ; Save address of line
1723   0A80 CD CD 0A            CALL    SETLIN          ; Set up lines counter
1724   0A83 E1          LISTLP: POP     HL              ; Restore address of line
1725   0A84 4E                  LD      C,(HL)          ; Get LSB of next line
1726   0A85 23                  INC     HL
1727   0A86 46                  LD      B,(HL)          ; Get MSB of next line
1728   0A87 23                  INC     HL
1729   0A88 78                  LD      A,B             ; BC = 0 (End of program)?
1730   0A89 B1                  OR      C
1731   0A8A CA AE 07            JP      Z,PRNTOK        ; Yes - Go to command mode
1732   0A8D CD D6 0A            CALL    COUNT           ; Count lines
1733   0A90 CD E6 0B            CALL    TSTBRK          ; Test for break key
1734   0A93 C5                  PUSH    BC              ; Save address of next line
1735   0A94 CD 63 0E            CALL    PRNTCRLF        ; Output CRLF
1736   0A97 5E                  LD      E,(HL)          ; Get LSB of line number
1737   0A98 23                  INC     HL
1738   0A99 56                  LD      D,(HL)          ; Get MSB of line number
1739   0A9A 23                  INC     HL
1740   0A9B E5                  PUSH    HL              ; Save address of line start
1741   0A9C EB                  EX      DE,HL           ; Line number to HL
1742   0A9D CD A4 1B            CALL    PRNTHL          ; Output line number in decimal
1743   0AA0 3E 20               LD      A,' '           ; Space after line number
1744   0AA2 E1                  POP     HL              ; Restore start of line address
1745   0AA3 CD 3C 0A    LSTLP2: CALL    OUTC            ; Output character in A
1746   0AA6 7E          LSTLP3: LD      A,(HL)          ; Get next byte in line
1747   0AA7 B7                  OR      A               ; End of line?
1748   0AA8 23                  INC     HL              ; To next byte in line
1749   0AA9 CA 83 0A            JP      Z,LISTLP        ; Yes - get next line
1750   0AAC F2 A3 0A            JP      P,LSTLP2        ; No token - output it
1751   0AAF D6 7F               SUB     ZEND-1          ; Find and output word
1752   0AB1 4F                  LD      C,A             ; Token offset+1 to C
1753   0AB2 11 EC 04            LD      DE,WORDS        ; Reserved word list
1754   0AB5 1A          FNDTOK: LD      A,(DE)          ; Get character in list
1755   0AB6 13                  INC     DE              ; Move on to next
1756   0AB7 B7                  OR      A               ; Is it start of word?
1757   0AB8 F2 B5 0A            JP      P,FNDTOK        ; No - Keep looking for word
1758   0ABB 0D                  DEC     C               ; Count words
1759   0ABC C2 B5 0A            JP      NZ,FNDTOK       ; Not there - keep looking
1760   0ABF E6 7F       OUTWRD: AND     01111111B       ; Strip bit 7
1761   0AC1 CD 3C 0A            CALL    OUTC            ; Output first character
1762   0AC4 1A                  LD      A,(DE)          ; Get next character
1763   0AC5 13                  INC     DE              ; Move on to next
1764   0AC6 B7                  OR      A               ; Is it end of word?
1765   0AC7 F2 BF 0A            JP      P,OUTWRD        ; No - output the rest
1766   0ACA C3 A6 0A            JP      LSTLP3          ; Next byte in line
1767   0ACD             
1768   0ACD E5          SETLIN: PUSH    HL              ; Set up LINES counter
1769   0ACE 2A F8 30            LD      HL,(LINESN)     ; Get LINES number
1770   0AD1 22 F6 30            LD      (LINESC),HL     ; Save in LINES counter
1771   0AD4 E1                  POP     HL
1772   0AD5 C9                  RET
1773   0AD6             
1774   0AD6 E5          COUNT:  PUSH    HL              ; Save code string address
1775   0AD7 D5                  PUSH    DE
1776   0AD8 2A F6 30            LD      HL,(LINESC)     ; Get LINES counter
1777   0ADB 11 FF FF            LD      DE,-1
1778   0ADE ED 5A               ADC     HL,DE           ; Decrement
1779   0AE0 22 F6 30            LD      (LINESC),HL     ; Put it back
1780   0AE3 D1                  POP     DE
1781   0AE4 E1                  POP     HL              ; Restore code string address
1782   0AE5 F0                  RET     P               ; Return if more lines to go
1783   0AE6 E5                  PUSH    HL              ; Save code string address
1784   0AE7 2A F8 30            LD      HL,(LINESN)     ; Get LINES number
1785   0AEA 22 F6 30            LD      (LINESC),HL     ; Reset LINES counter
1786   0AED CD C0 1E            CALL    GETINP          ; Get input character
1787   0AF0 FE 03               CP      CTRLC           ; Is it control "C"?
1788   0AF2 CA F9 0A            JP      Z,RSLNBK        ; Yes - Reset LINES and break
1789   0AF5 E1                  POP     HL              ; Restore code string address
1790   0AF6 C3 D6 0A            JP      COUNT           ; Keep on counting
1791   0AF9             
1792   0AF9 2A F8 30    RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1793   0AFC 22 F6 30            LD      (LINESC),HL     ; Reset LINES counter
1794   0AFF C3 5D 04            JP      BRKRET          ; Go and output "Break"
1795   0B02             
1796   0B02 3E 64       FOR:    LD      A,64H           ; Flag "FOR" assignment
1797   0B04 32 7B 31            LD      (FORFLG),A      ; Save "FOR" flag
1798   0B07 CD 69 0D            CALL    LET             ; Set up initial index
1799   0B0A C1                  POP     BC              ; Drop RETurn address
1800   0B0B E5                  PUSH    HL              ; Save code string address
1801   0B0C CD 52 0D            CALL    DATA            ; Get next statement address
1802   0B0F 22 77 31            LD      (LOOPST),HL     ; Save it for start of loop
1803   0B12 21 02 00            LD      HL,2            ; Offset for "FOR" block
1804   0B15 39                  ADD     HL,SP           ; Point to it
1805   0B16 CD 10 07    FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1806   0B19 D1                  POP     DE              ; Get code string address
1807   0B1A C2 32 0B            JP      NZ,FORFND       ; No nesting found
1808   0B1D 09                  ADD     HL,BC           ; Move into "FOR" block
1809   0B1E D5                  PUSH    DE              ; Save code string address
1810   0B1F 2B                  DEC     HL
1811   0B20 56                  LD      D,(HL)          ; Get MSB of loop statement
1812   0B21 2B                  DEC     HL
1813   0B22 5E                  LD      E,(HL)          ; Get LSB of loop statement
1814   0B23 23                  INC     HL
1815   0B24 23                  INC     HL
1816   0B25 E5                  PUSH    HL              ; Save block address
1817   0B26 2A 77 31            LD      HL,(LOOPST)     ; Get address of loop statement
1818   0B29 CD 2B 0A            CALL    CPDEHL          ; Compare the FOR loops
1819   0B2C E1                  POP     HL              ; Restore block address
1820   0B2D C2 16 0B            JP      NZ,FORSLP       ; Different FORs - Find another
1821   0B30 D1                  POP     DE              ; Restore code string address
1822   0B31 F9                  LD      SP,HL           ; Remove all nested loops
1823   0B32             
1824   0B32 EB          FORFND: EX      DE,HL           ; Code string address to HL
1825   0B33 0E 08               LD      C,8
1826   0B35 CD 40 07            CALL    CHKSTK          ; Check for 8 levels of stack
1827   0B38 E5                  PUSH    HL              ; Save code string address
1828   0B39 2A 77 31            LD      HL,(LOOPST)     ; Get first statement of loop
1829   0B3C E3                  EX      (SP),HL         ; Save and restore code string
1830   0B3D E5                  PUSH    HL              ; Re-save code string address
1831   0B3E 2A 0C 31            LD      HL,(LINEAT)     ; Get current line number
1832   0B41 E3                  EX      (SP),HL         ; Save and restore code string
1833   0B42 CD 2B 10            CALL    TSTNUM          ; Make sure it's a number
1834   0B45 CD 31 0A            CALL    CHKSYN          ; Make sure "TO" is next
1835   0B48 A6                  .BYTE   ZTO          ; "TO" token
1836   0B49 CD 28 10            CALL    GETNUM          ; Get "TO" expression value
1837   0B4C E5                  PUSH    HL              ; Save code string address
1838   0B4D CD 56 1A            CALL    BCDEFP          ; Move "TO" value to BCDE
1839   0B50 E1                  POP     HL              ; Restore code string address
1840   0B51 C5                  PUSH    BC              ; Save "TO" value in block
1841   0B52 D5                  PUSH    DE
1842   0B53 01 00 81            LD      BC,8100H        ; BCDE - 1 (default STEP)
1843   0B56 51                  LD      D,C             ; C=0
1844   0B57 5A                  LD      E,D             ; D=0
1845   0B58 7E                  LD      A,(HL)          ; Get next byte in code string
1846   0B59 FE AB               CP      ZSTEP           ; See if "STEP" is stated
1847   0B5B 3E 01               LD      A,1             ; Sign of step = 1
1848   0B5D C2 6E 0B            JP      NZ,SAVSTP       ; No STEP given - Default to 1
1849   0B60 CD BB 0B            CALL    GETCHR          ; Jump over "STEP" token
1850   0B63 CD 28 10            CALL    GETNUM          ; Get step value
1851   0B66 E5                  PUSH    HL              ; Save code string address
1852   0B67 CD 56 1A            CALL    BCDEFP          ; Move STEP to BCDE
1853   0B6A CD 0A 1A            CALL    TSTSGN          ; Test sign of FPREG
1854   0B6D E1                  POP     HL              ; Restore code string address
1855   0B6E C5          SAVSTP: PUSH    BC              ; Save the STEP value in block
1856   0B6F D5                  PUSH    DE
1857   0B70 F5                  PUSH    AF              ; Save sign of STEP
1858   0B71 33                  INC     SP              ; Don't save flags
1859   0B72 E5                  PUSH    HL              ; Save code string address
1860   0B73 2A 7E 31            LD      HL,(BRKLIN)     ; Get address of index variable
1861   0B76 E3                  EX      (SP),HL         ; Save and restore code string
1862   0B77 06 81       PUTFID: LD      B,ZFOR          ; "FOR" block marker
1863   0B79 C5                  PUSH    BC              ; Save it
1864   0B7A 33                  INC     SP              ; Don't save C
1865   0B7B             
1866   0B7B CD E6 0B    RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1867   0B7E 22 7E 31            LD      (BRKLIN),HL     ; Save code address for break
1868   0B81 7E                  LD      A,(HL)          ; Get next byte in code string
1869   0B82 FE 3A               CP      ':'             ; Multi statement line?
1870   0B84 CA 9B 0B            JP      Z,EXCUTE        ; Yes - Execute it
1871   0B87 B7                  OR      A               ; End of line?
1872   0B88 C2 63 07            JP      NZ,SNERR        ; No - Syntax error
1873   0B8B 23                  INC     HL              ; Point to address of next line
1874   0B8C 7E                  LD      A,(HL)          ; Get LSB of line pointer
1875   0B8D 23                  INC     HL
1876   0B8E B6                  OR      (HL)            ; Is it zero (End of prog)?
1877   0B8F CA 0D 0C            JP      Z,ENDPRG        ; Yes - Terminate execution
1878   0B92 23                  INC     HL              ; Point to line number
1879   0B93 5E                  LD      E,(HL)          ; Get LSB of line number
1880   0B94 23                  INC     HL
1881   0B95 56                  LD      D,(HL)          ; Get MSB of line number
1882   0B96 EB                  EX      DE,HL           ; Line number to HL
1883   0B97 22 0C 31            LD      (LINEAT),HL     ; Save as current line number
1884   0B9A EB                  EX      DE,HL           ; Line number back to DE
1885   0B9B CD BB 0B    EXCUTE: CALL    GETCHR          ; Get key word
1886   0B9E 11 7B 0B            LD      DE,RUNCNT       ; Where to RETurn to
1887   0BA1 D5                  PUSH    DE              ; Save for RETurn
1888   0BA2 C8          IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1889   0BA3 D6 80       ONJMP:  SUB     ZEND            ; Is it a token?
1890   0BA5 DA 69 0D            JP      C,LET           ; No - try to assign it
1891   0BA8 FE 25               CP      ZNEW+1-ZEND     ; END to NEW ?
1892   0BAA D2 63 07            JP      NC,SNERR        ; Not a key word - ?SN Error
1893   0BAD 07                  RLCA                    ; Double it
1894   0BAE 4F                  LD      C,A             ; BC = Offset into table
1895   0BAF 06 00               LD      B,0
1896   0BB1 EB                  EX      DE,HL           ; Save code string address
1897   0BB2 21 0B 06            LD      HL,WORDTB       ; Keyword address table
1898   0BB5 09                  ADD     HL,BC           ; Point to routine address
1899   0BB6 4E                  LD      C,(HL)          ; Get LSB of routine address
1900   0BB7 23                  INC     HL
1901   0BB8 46                  LD      B,(HL)          ; Get MSB of routine address
1902   0BB9 C5                  PUSH    BC              ; Save routine address
1903   0BBA EB                  EX      DE,HL           ; Restore code string address
1904   0BBB             
1905   0BBB 23          GETCHR: INC     HL              ; Point to next character
1906   0BBC 7E                  LD      A,(HL)          ; Get next code string byte
1907   0BBD FE 3A               CP      ':'             ; Z if ':'
1908   0BBF D0                  RET     NC              ; NC if > "9"
1909   0BC0 FE 20               CP      ' '
1910   0BC2 CA BB 0B            JP      Z,GETCHR        ; Skip over spaces
1911   0BC5 FE 30               CP      '0'
1912   0BC7 3F                  CCF                     ; NC if < '0'
1913   0BC8 3C                  INC     A               ; Test for zero - Leave carry
1914   0BC9 3D                  DEC     A               ; Z if Null
1915   0BCA C9                  RET
1916   0BCB             
1917   0BCB EB          RESTOR: EX      DE,HL           ; Save code string address
1918   0BCC 2A 0E 31            LD      HL,(BASTXT)     ; Point to start of program
1919   0BCF CA E0 0B            JP      Z,RESTNL        ; Just RESTORE - reset pointer
1920   0BD2 EB                  EX      DE,HL           ; Restore code string address
1921   0BD3 CD 87 0C            CALL    ATOH            ; Get line number to DE
1922   0BD6 E5                  PUSH    HL              ; Save code string address
1923   0BD7 CD 4F 08            CALL    SRCHLN          ; Search for line number in DE
1924   0BDA 60                  LD      H,B             ; HL = Address of line
1925   0BDB 69                  LD      L,C
1926   0BDC D1                  POP     DE              ; Restore code string address
1927   0BDD D2 28 0D            JP      NC,ULERR        ; ?UL Error if not found
1928   0BE0 2B          RESTNL: DEC     HL              ; Byte before DATA statement
1929   0BE1 22 8C 31    UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1930   0BE4 EB                  EX      DE,HL           ; Restore code string address
1931   0BE5 C9                  RET
1932   0BE6             
1933   0BE6             
1934   0BE6 DF          TSTBRK: RST     18H             ; Check input status
1935   0BE7 C8                  RET     Z               ; No key, go back
1936   0BE8 D7                  RST     10H             ; Get the key into A
1937   0BE9 FE 1B               CP      ESC             ; Escape key?
1938   0BEB 28 11               JR      Z,BRK           ; Yes, break
1939   0BED FE 03               CP      CTRLC           ; <Ctrl-C>
1940   0BEF 28 0D               JR      Z,BRK           ; Yes, break
1941   0BF1 FE 13               CP      CTRLS           ; Stop scrolling?
1942   0BF3 C0                  RET     NZ              ; Other key, ignore
1943   0BF4             
1944   0BF4             
1945   0BF4 D7          STALL:  RST     10H             ; Wait for key
1946   0BF5 FE 11               CP      CTRLQ           ; Resume scrolling?
1947   0BF7 C8                  RET      Z              ; Release the chokehold
1948   0BF8 FE 03               CP      CTRLC           ; Second break?
1949   0BFA 28 07               JR      Z,STOP          ; Break during hold exits prog
1950   0BFC 18 F6               JR      STALL           ; Loop until <Ctrl-Q> or <brk>
1951   0BFE             
1952   0BFE 3E FF       BRK     LD      A,$FF           ; Set BRKFLG
1953   0C00 32 FD 30            LD      (BRKFLG),A      ; Store it
1954   0C03             
1955   0C03             
1956   0C03 C0          STOP:   RET     NZ              ; Exit if anything else
1957   0C04 F6                  .BYTE   0F6H            ; Flag "STOP"
1958   0C05 C0          PEND:   RET     NZ              ; Exit if anything else
1959   0C06 22 7E 31            LD      (BRKLIN),HL     ; Save point of break
1960   0C09 21                  .BYTE   21H             ; Skip "OR 11111111B"
1961   0C0A F6 FF       INPBRK: OR      11111111B       ; Flag "Break" wanted
1962   0C0C C1                  POP     BC              ; Return not needed and more
1963   0C0D 2A 0C 31    ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1964   0C10 F5                  PUSH    AF              ; Save STOP / END status
1965   0C11 7D                  LD      A,L             ; Is it direct break?
1966   0C12 A4                  AND     H
1967   0C13 3C                  INC     A               ; Line is -1 if direct break
1968   0C14 CA 20 0C            JP      Z,NOLIN         ; Yes - No line number
1969   0C17 22 82 31            LD      (ERRLIN),HL     ; Save line of break
1970   0C1A 2A 7E 31            LD      HL,(BRKLIN)     ; Get point of break
1971   0C1D 22 84 31            LD      (CONTAD),HL     ; Save point to CONTinue
1972   0C20 AF          NOLIN:  XOR     A
1973   0C21 32 F5 30            LD      (CTLOFG),A      ; Enable output
1974   0C24 CD 56 0E            CALL    STTLIN          ; Start a new line
1975   0C27 F1                  POP     AF              ; Restore STOP / END status
1976   0C28 21 06 07            LD      HL,BRKMSG       ; "Break" message
1977   0C2B C2 97 07            JP      NZ,ERRIN        ; "in line" wanted?
1978   0C2E C3 AE 07            JP      PRNTOK          ; Go to command mode
1979   0C31             
1980   0C31 2A 84 31    CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1981   0C34 7C                  LD      A,H             ; Is it zero?
1982   0C35 B5                  OR      L
1983   0C36 1E 20               LD      E,CN            ; ?CN Error
1984   0C38 CA 77 07            JP      Z,ERROR         ; Yes - output "?CN Error"
1985   0C3B EB                  EX      DE,HL           ; Save code string address
1986   0C3C 2A 82 31            LD      HL,(ERRLIN)     ; Get line of last break
1987   0C3F 22 0C 31            LD      (LINEAT),HL     ; Set up current line number
1988   0C42 EB                  EX      DE,HL           ; Restore code string address
1989   0C43 C9                  RET                     ; CONTinue where left off
1990   0C44             
1991   0C44 CD 89 17    NULL:   CALL    GETINT          ; Get integer 0-255
1992   0C47 C0                  RET     NZ              ; Return if bad value
1993   0C48 32 F1 30            LD      (NULLS),A       ; Set nulls number
1994   0C4B C9                  RET
1995   0C4C             
1996   0C4C             
1997   0C4C E5          ACCSUM: PUSH    HL              ; Save address in array
1998   0C4D 2A FA 30            LD      HL,(CHKSUM)     ; Get check sum
1999   0C50 06 00               LD      B,0             ; BC - Value of byte
2000   0C52 4F                  LD      C,A
2001   0C53 09                  ADD     HL,BC           ; Add byte to check sum
2002   0C54 22 FA 30            LD      (CHKSUM),HL     ; Re-save check sum
2003   0C57 E1                  POP     HL              ; Restore address in array
2004   0C58 C9                  RET
2005   0C59             
2006   0C59 7E          CHKLTR: LD      A,(HL)          ; Get byte
2007   0C5A FE 41               CP      'A'             ; < 'a' ?
2008   0C5C D8                  RET     C               ; Carry set if not letter
2009   0C5D FE 5B               CP      'Z'+1           ; > 'z' ?
2010   0C5F 3F                  CCF
2011   0C60 C9                  RET                     ; Carry set if not letter
2012   0C61             
2013   0C61 CD BB 0B    FPSINT: CALL    GETCHR          ; Get next character
2014   0C64 CD 28 10    POSINT: CALL    GETNUM          ; Get integer 0 to 32767
2015   0C67 CD 0A 1A    DEPINT: CALL    TSTSGN          ; Test sign of FPREG
2016   0C6A FA 82 0C            JP      M,FCERR         ; Negative - ?FC Error
2017   0C6D 3A 97 31    DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
2018   0C70 FE 90               CP      80H+16          ; Exponent in range (16 bits)?
2019   0C72 DA B2 1A            JP      C,FPINT         ; Yes - convert it
2020   0C75 01 80 90            LD      BC,9080H        ; BCDE = -32768
2021   0C78 11 00 00            LD      DE,0000
2022   0C7B E5                  PUSH    HL              ; Save code string address
2023   0C7C CD 85 1A            CALL    CMPNUM          ; Compare FPREG with BCDE
2024   0C7F E1                  POP     HL              ; Restore code string address
2025   0C80 51                  LD      D,C             ; MSB to D
2026   0C81 C8                  RET     Z               ; Return if in range
2027   0C82 1E 08       FCERR:  LD      E,FC            ; ?FC Error
2028   0C84 C3 77 07            JP      ERROR           ; Output error-
2029   0C87             
2030   0C87 2B          ATOH:   DEC     HL              ; ASCII number to DE binary
2031   0C88 11 00 00    GETLN:  LD      DE,0            ; Get number to DE
2032   0C8B CD BB 0B    GTLNLP: CALL    GETCHR          ; Get next character
2033   0C8E D0                  RET     NC              ; Exit if not a digit
2034   0C8F E5                  PUSH    HL              ; Save code string address
2035   0C90 F5                  PUSH    AF              ; Save digit
2036   0C91 21 98 19            LD      HL,65529/10     ; Largest number 65529
2037   0C94 CD 2B 0A            CALL    CPDEHL          ; Number in range?
2038   0C97 DA 63 07            JP      C,SNERR         ; No - ?SN Error
2039   0C9A 62                  LD      H,D             ; HL = Number
2040   0C9B 6B                  LD      L,E
2041   0C9C 19                  ADD     HL,DE           ; Times 2
2042   0C9D 29                  ADD     HL,HL           ; Times 4
2043   0C9E 19                  ADD     HL,DE           ; Times 5
2044   0C9F 29                  ADD     HL,HL           ; Times 10
2045   0CA0 F1                  POP     AF              ; Restore digit
2046   0CA1 D6 30               SUB     '0'             ; Make it 0 to 9
2047   0CA3 5F                  LD      E,A             ; DE = Value of digit
2048   0CA4 16 00               LD      D,0
2049   0CA6 19                  ADD     HL,DE           ; Add to number
2050   0CA7 EB                  EX      DE,HL           ; Number to DE
2051   0CA8 E1                  POP     HL              ; Restore code string address
2052   0CA9 C3 8B 0C            JP      GTLNLP          ; Go to next character
2053   0CAC             
2054   0CAC CA 7F 08    CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
2055   0CAF CD 64 0C            CALL    POSINT          ; Get integer 0 to 32767 to DE
2056   0CB2 2B                  DEC     HL              ; Cancel increment
2057   0CB3 CD BB 0B            CALL    GETCHR          ; Get next character
2058   0CB6 E5                  PUSH    HL              ; Save code string address
2059   0CB7 2A 5F 31            LD      HL,(LSTRAM)     ; Get end of RAM
2060   0CBA CA CF 0C            JP      Z,STORED        ; No value given - Use stored
2061   0CBD E1                  POP     HL              ; Restore code string address
2062   0CBE CD 31 0A            CALL    CHKSYN          ; Check for comma
2063   0CC1 2C                  .BYTE      ','
2064   0CC2 D5                  PUSH    DE              ; Save number
2065   0CC3 CD 64 0C            CALL    POSINT          ; Get integer 0 to 32767
2066   0CC6 2B                  DEC     HL              ; Cancel increment
2067   0CC7 CD BB 0B            CALL    GETCHR          ; Get next character
2068   0CCA C2 63 07            JP      NZ,SNERR        ; ?SN Error if more on line
2069   0CCD E3                  EX      (SP),HL         ; Save code string address
2070   0CCE EB                  EX      DE,HL           ; Number to DE
2071   0CCF 7D          STORED: LD      A,L             ; Get LSB of new RAM top
2072   0CD0 93                  SUB     E               ; Subtract LSB of string space
2073   0CD1 5F                  LD      E,A             ; Save LSB
2074   0CD2 7C                  LD      A,H             ; Get MSB of new RAM top
2075   0CD3 9A                  SBC     A,D             ; Subtract MSB of string space
2076   0CD4 57                  LD      D,A             ; Save MSB
2077   0CD5 DA 58 07            JP      C,OMERR         ; ?OM Error if not enough mem
2078   0CD8 E5                  PUSH    HL              ; Save RAM top
2079   0CD9 2A 86 31            LD      HL,(PROGND)     ; Get program end
2080   0CDC 01 28 00            LD      BC,40           ; 40 Bytes minimum working RAM
2081   0CDF 09                  ADD     HL,BC           ; Get lowest address
2082   0CE0 CD 2B 0A            CALL    CPDEHL          ; Enough memory?
2083   0CE3 D2 58 07            JP      NC,OMERR        ; No - ?OM Error
2084   0CE6 EB                  EX      DE,HL           ; RAM top to HL
2085   0CE7 22 0A 31            LD      (STRSPC),HL     ; Set new string space
2086   0CEA E1                  POP     HL              ; End of memory to use
2087   0CEB 22 5F 31            LD      (LSTRAM),HL     ; Set new top of RAM
2088   0CEE E1                  POP     HL              ; Restore code string address
2089   0CEF C3 7F 08            JP      INTVAR          ; Initialise variables
2090   0CF2             
2091   0CF2 CA 7B 08    RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
2092   0CF5 CD 7F 08            CALL    INTVAR          ; Initialise variables
2093   0CF8 01 7B 0B            LD      BC,RUNCNT       ; Execution driver loop
2094   0CFB C3 0E 0D            JP      RUNLIN          ; RUN from line number
2095   0CFE             
2096   0CFE 0E 03       GOSUB:  LD      C,3             ; 3 Levels of stack needed
2097   0D00 CD 40 07            CALL    CHKSTK          ; Check for 3 levels of stack
2098   0D03 C1                  POP     BC              ; Get return address
2099   0D04 E5                  PUSH    HL              ; Save code string for RETURN
2100   0D05 E5                  PUSH    HL              ; And for GOSUB routine
2101   0D06 2A 0C 31            LD      HL,(LINEAT)     ; Get current line
2102   0D09 E3                  EX      (SP),HL         ; Into stack - Code string out
2103   0D0A 3E 8C               LD      A,ZGOSUB        ; "GOSUB" token
2104   0D0C F5                  PUSH    AF              ; Save token
2105   0D0D 33                  INC     SP              ; Don't save flags
2106   0D0E             
2107   0D0E C5          RUNLIN: PUSH    BC              ; Save return address
2108   0D0F CD 87 0C    GOTO:   CALL    ATOH            ; ASCII number to DE binary
2109   0D12 CD 54 0D            CALL    REM             ; Get end of line
2110   0D15 E5                  PUSH    HL              ; Save end of line
2111   0D16 2A 0C 31            LD      HL,(LINEAT)     ; Get current line
2112   0D19 CD 2B 0A            CALL    CPDEHL          ; Line after current?
2113   0D1C E1                  POP     HL              ; Restore end of line
2114   0D1D 23                  INC     HL              ; Start of next line
2115   0D1E DC 52 08            CALL    C,SRCHLP        ; Line is after current line
2116   0D21 D4 4F 08            CALL    NC,SRCHLN       ; Line is before current line
2117   0D24 60                  LD      H,B             ; Set up code string address
2118   0D25 69                  LD      L,C
2119   0D26 2B                  DEC     HL              ; Incremented after
2120   0D27 D8                  RET     C               ; Line found
2121   0D28 1E 0E       ULERR:  LD      E,UL            ; ?UL Error
2122   0D2A C3 77 07            JP      ERROR           ; Output error message
2123   0D2D             
2124   0D2D C0          RETURN: RET     NZ              ; Return if not just RETURN
2125   0D2E 16 FF               LD      D,-1            ; Flag "GOSUB" search
2126   0D30 CD 0C 07            CALL    BAKSTK          ; Look "GOSUB" block
2127   0D33 F9                  LD      SP,HL           ; Kill all FORs in subroutine
2128   0D34 FE 8C               CP      ZGOSUB          ; Test for "GOSUB" token
2129   0D36 1E 04               LD      E,RG            ; ?RG Error
2130   0D38 C2 77 07            JP      NZ,ERROR        ; Error if no "GOSUB" found
2131   0D3B E1                  POP     HL              ; Get RETURN line number
2132   0D3C 22 0C 31            LD      (LINEAT),HL     ; Save as current
2133   0D3F 23                  INC     HL              ; Was it from direct statement?
2134   0D40 7C                  LD      A,H
2135   0D41 B5                  OR      L               ; Return to line
2136   0D42 C2 4C 0D            JP      NZ,RETLIN       ; No - Return to line
2137   0D45 3A 7C 31            LD      A,(LSTBIN)      ; Any INPUT in subroutine?
2138   0D48 B7                  OR      A               ; If so buffer is corrupted
2139   0D49 C2 AD 07            JP      NZ,POPNOK       ; Yes - Go to command mode
2140   0D4C 21 7B 0B    RETLIN: LD      HL,RUNCNT       ; Execution driver loop
2141   0D4F E3                  EX      (SP),HL         ; Into stack - Code string out
2142   0D50 3E                  .BYTE      3EH             ; Skip "POP HL"
2143   0D51 E1          NXTDTA: POP     HL              ; Restore code string address
2144   0D52             
2145   0D52 01 3A       DATA:   .BYTE      01H,3AH         ; ':' End of statement
2146   0D54 0E 00       REM:    LD      C,0             ; 00  End of statement
2147   0D56 06 00               LD      B,0
2148   0D58 79          NXTSTL: LD      A,C             ; Statement and byte
2149   0D59 48                  LD      C,B
2150   0D5A 47                  LD      B,A             ; Statement end byte
2151   0D5B 7E          NXTSTT: LD      A,(HL)          ; Get byte
2152   0D5C B7                  OR      A               ; End of line?
2153   0D5D C8                  RET     Z               ; Yes - Exit
2154   0D5E B8                  CP      B               ; End of statement?
2155   0D5F C8                  RET     Z               ; Yes - Exit
2156   0D60 23                  INC     HL              ; Next byte
2157   0D61 FE 22               CP      '"'             ; Literal string?
2158   0D63 CA 58 0D            JP      Z,NXTSTL        ; Yes - Look for another '"'
2159   0D66 C3 5B 0D            JP      NXTSTT          ; Keep looking
2160   0D69             
2161   0D69 CD 1E 12    LET:    CALL    GETVAR          ; Get variable name
2162   0D6C CD 31 0A            CALL    CHKSYN          ; Make sure "=" follows
2163   0D6F B4                  .BYTE      ZEQUAL          ; "=" token
2164   0D70 D5                  PUSH    DE              ; Save address of variable
2165   0D71 3A 5D 31            LD      A,(TYPE)        ; Get data type
2166   0D74 F5                  PUSH    AF              ; Save type
2167   0D75 CD 3A 10            CALL    EVAL            ; Evaluate expression
2168   0D78 F1                  POP     AF              ; Restore type
2169   0D79 E3                  EX      (SP),HL         ; Save code - Get var addr
2170   0D7A 22 7E 31            LD      (BRKLIN),HL     ; Save address of variable
2171   0D7D 1F                  RRA                     ; Adjust type
2172   0D7E CD 2D 10            CALL    CHKTYP          ; Check types are the same
2173   0D81 CA BC 0D            JP      Z,LETNUM        ; Numeric - Move value
2174   0D84 E5          LETSTR: PUSH    HL              ; Save address of string var
2175   0D85 2A 94 31            LD      HL,(FPREG)      ; Pointer to string entry
2176   0D88 E5                  PUSH    HL              ; Save it on stack
2177   0D89 23                  INC     HL              ; Skip over length
2178   0D8A 23                  INC     HL
2179   0D8B 5E                  LD      E,(HL)          ; LSB of string address
2180   0D8C 23                  INC     HL
2181   0D8D 56                  LD      D,(HL)          ; MSB of string address
2182   0D8E 2A 0E 31            LD      HL,(BASTXT)     ; Point to start of program
2183   0D91 CD 2B 0A            CALL    CPDEHL          ; Is string before program?
2184   0D94 D2 AB 0D            JP      NC,CRESTR       ; Yes - Create string entry
2185   0D97 2A 0A 31            LD      HL,(STRSPC)     ; Point to string space
2186   0D9A CD 2B 0A            CALL    CPDEHL          ; Is string literal in program?
2187   0D9D D1                  POP     DE              ; Restore address of string
2188   0D9E D2 B3 0D            JP      NC,MVSTPT       ; Yes - Set up pointer
2189   0DA1 21 6F 31            LD      HL,TMPSTR       ; Temporary string pool
2190   0DA4 CD 2B 0A            CALL    CPDEHL          ; Is string in temporary pool?
2191   0DA7 D2 B3 0D            JP      NC,MVSTPT       ; No - Set up pointer
2192   0DAA 3E                  .BYTE   3EH             ; Skip "POP DE"
2193   0DAB D1          CRESTR: POP     DE              ; Restore address of string
2194   0DAC CD 62 16            CALL    BAKTMP          ; Back to last tmp-str entry
2195   0DAF EB                  EX      DE,HL           ; Address of string entry
2196   0DB0 CD 9B 14            CALL    SAVSTR          ; Save string in string area
2197   0DB3 CD 62 16    MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
2198   0DB6 E1                  POP     HL              ; Get string pointer
2199   0DB7 CD 65 1A            CALL    DETHL4          ; Move string pointer to var
2200   0DBA E1                  POP     HL              ; Restore code string address
2201   0DBB C9                  RET
2202   0DBC             
2203   0DBC E5          LETNUM: PUSH    HL              ; Save address of variable
2204   0DBD CD 62 1A            CALL    FPTHL           ; Move value to variable
2205   0DC0 D1                  POP     DE              ; Restore address of variable
2206   0DC1 E1                  POP     HL              ; Restore code string address
2207   0DC2 C9                  RET
2208   0DC3             
2209   0DC3 CD 89 17    ON:     CALL    GETINT          ; Get integer 0-255
2210   0DC6 7E                  LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
2211   0DC7 47                  LD      B,A             ; Save in B
2212   0DC8 FE 8C               CP      ZGOSUB          ; "GOSUB" token?
2213   0DCA CA D2 0D            JP      Z,ONGO          ; Yes - Find line number
2214   0DCD CD 31 0A            CALL    CHKSYN          ; Make sure it's "GOTO"
2215   0DD0 88                  .BYTE   ZGOTO           ; "GOTO" token
2216   0DD1 2B                  DEC     HL              ; Cancel increment
2217   0DD2 4B          ONGO:   LD      C,E             ; Integer of branch value
2218   0DD3 0D          ONGOLP: DEC     C               ; Count branches
2219   0DD4 78                  LD      A,B             ; Get "GOTO" or "GOSUB" token
2220   0DD5 CA A3 0B            JP      Z,ONJMP         ; Go to that line if right one
2221   0DD8 CD 88 0C            CALL    GETLN           ; Get line number to DE
2222   0DDB FE 2C               CP      ','             ; Another line number?
2223   0DDD C0                  RET     NZ              ; No - Drop through
2224   0DDE C3 D3 0D            JP      ONGOLP          ; Yes - loop
2225   0DE1             
2226   0DE1 CD 3A 10    IF:     CALL    EVAL            ; Evaluate expression
2227   0DE4 7E                  LD      A,(HL)          ; Get token
2228   0DE5 FE 88               CP      ZGOTO           ; "GOTO" token?
2229   0DE7 CA EF 0D            JP      Z,IFGO          ; Yes - Get line
2230   0DEA CD 31 0A            CALL    CHKSYN          ; Make sure it's "THEN"
2231   0DED A9                  .BYTE      ZTHEN           ; "THEN" token
2232   0DEE 2B                  DEC     HL              ; Cancel increment
2233   0DEF CD 2B 10    IFGO:   CALL    TSTNUM          ; Make sure it's numeric
2234   0DF2 CD 0A 1A            CALL    TSTSGN          ; Test state of expression
2235   0DF5 CA 54 0D            JP      Z,REM           ; False - Drop through
2236   0DF8 CD BB 0B            CALL    GETCHR          ; Get next character
2237   0DFB DA 0F 0D            JP      C,GOTO          ; Number - GOTO that line
2238   0DFE C3 A2 0B            JP      IFJMP           ; Otherwise do statement
2239   0E01             
2240   0E01 2B          MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
2241   0E02 CD BB 0B            CALL    GETCHR          ; Get next character
2242   0E05 CA 63 0E    PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
2243   0E08 C8          PRNTLP: RET     Z               ; End of list - Exit
2244   0E09 FE A5               CP      ZTAB            ; "TAB(" token?
2245   0E0B CA 96 0E            JP      Z,DOTAB         ; Yes - Do TAB routine
2246   0E0E FE A8               CP      ZSPC            ; "SPC(" token?
2247   0E10 CA 96 0E            JP      Z,DOTAB         ; Yes - Do SPC routine
2248   0E13 E5                  PUSH    HL              ; Save code string address
2249   0E14 FE 2C               CP      ','             ; Comma?
2250   0E16 CA 7F 0E            JP      Z,DOCOM         ; Yes - Move to next zone
2251   0E19 FE 3B               CP      59 ;";"         ; Semi-colon?
2252   0E1B CA B9 0E            JP      Z,NEXITM        ; Do semi-colon routine
2253   0E1E C1                  POP     BC              ; Code string address to BC
2254   0E1F CD 3A 10            CALL    EVAL            ; Evaluate expression
2255   0E22 E5                  PUSH    HL              ; Save code string address
2256   0E23 3A 5D 31            LD      A,(TYPE)        ; Get variable type
2257   0E26 B7                  OR      A               ; Is it a string variable?
2258   0E27 C2 4F 0E            JP      NZ,PRNTST       ; Yes - Output string contents
2259   0E2A CD AF 1B            CALL    NUMASC          ; Convert number to text
2260   0E2D CD BF 14            CALL    CRTST           ; Create temporary string
2261   0E30 36 20               LD      (HL),' '        ; Followed by a space
2262   0E32 2A 94 31            LD      HL,(FPREG)      ; Get length of output
2263   0E35 34                  INC     (HL)            ; Plus 1 for the space
2264   0E36 2A 94 31            LD      HL,(FPREG)      ; < Not needed >
2265   0E39 3A F2 30            LD      A,(LWIDTH)      ; Get width of line
2266   0E3C 47                  LD      B,A             ; To B
2267   0E3D 04                  INC     B               ; Width 255 (No limit)?
2268   0E3E CA 4B 0E            JP      Z,PRNTNB        ; Yes - Output number string
2269   0E41 04                  INC     B               ; Adjust it
2270   0E42 3A 5B 31            LD      A,(CURPOS)      ; Get cursor position
2271   0E45 86                  ADD     A,(HL)          ; Add length of string
2272   0E46 3D                  DEC     A               ; Adjust it
2273   0E47 B8                  CP      B               ; Will output fit on this line?
2274   0E48 D4 63 0E            CALL    NC,PRNTCRLF     ; No - CRLF first
2275   0E4B CD 04 15    PRNTNB: CALL    PRS1            ; Output string at (HL)
2276   0E4E AF                  XOR     A               ; Skip CALL by setting 'z' flag
2277   0E4F C4 04 15    PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
2278   0E52 E1                  POP     HL              ; Restore code string address
2279   0E53 C3 01 0E            JP      MRPRNT          ; See if more to PRINT
2280   0E56             
2281   0E56 3A 5B 31    STTLIN: LD      A,(CURPOS)      ; Make sure on new line
2282   0E59 B7                  OR      A               ; Already at start?
2283   0E5A C8                  RET     Z               ; Yes - Do nothing
2284   0E5B C3 63 0E            JP      PRNTCRLF        ; Start a new line
2285   0E5E             
2286   0E5E 36 00       ENDINP: LD      (HL),0          ; Mark end of buffer
2287   0E60 21 10 31            LD      HL,BUFFER-1     ; Point to buffer
2288   0E63 3E 0D       PRNTCRLF: LD    A,CR            ; Load a CR
2289   0E65 CD 3C 0A            CALL    OUTC            ; Output character
2290   0E68 3E 0A               LD      A,LF            ; Load a LF
2291   0E6A CD 3C 0A            CALL    OUTC            ; Output character
2292   0E6D AF          DONULL: XOR     A               ; Set to position 0
2293   0E6E 32 5B 31            LD      (CURPOS),A      ; Store it
2294   0E71 3A F1 30            LD      A,(NULLS)       ; Get number of nulls
2295   0E74 3D          NULLP:  DEC     A               ; Count them
2296   0E75 C8                  RET     Z               ; Return if done
2297   0E76 F5                  PUSH    AF              ; Save count
2298   0E77 AF                  XOR     A               ; Load a null
2299   0E78 CD 3C 0A            CALL    OUTC            ; Output it
2300   0E7B F1                  POP     AF              ; Restore count
2301   0E7C C3 74 0E            JP      NULLP           ; Keep counting
2302   0E7F             
2303   0E7F 3A F3 30    DOCOM:  LD      A,(COMMAN)      ; Get comma width
2304   0E82 47                  LD      B,A             ; Save in B
2305   0E83 3A 5B 31            LD      A,(CURPOS)      ; Get current position
2306   0E86 B8                  CP      B               ; Within the limit?
2307   0E87 D4 63 0E            CALL    NC,PRNTCRLF     ; No - output CRLF
2308   0E8A D2 B9 0E            JP      NC,NEXITM       ; Get next item
2309   0E8D D6 0E       ZONELP: SUB     14              ; Next zone of 14 characters
2310   0E8F D2 8D 0E            JP      NC,ZONELP       ; Repeat if more zones
2311   0E92 2F                  CPL                     ; Number of spaces to output
2312   0E93 C3 AE 0E            JP      ASPCS           ; Output them
2313   0E96             
2314   0E96 F5          DOTAB:  PUSH    AF              ; Save token
2315   0E97 CD 86 17            CALL    FNDNUM          ; Evaluate expression
2316   0E9A CD 31 0A            CALL    CHKSYN          ; Make sure ")" follows
2317   0E9D 29                  .BYTE   ")"
2318   0E9E 2B                  DEC     HL              ; Back space on to ")"
2319   0E9F F1                  POP     AF              ; Restore token
2320   0EA0 D6 A8               SUB     ZSPC            ; Was it "SPC(" ?
2321   0EA2 E5                  PUSH    HL              ; Save code string address
2322   0EA3 CA A9 0E            JP      Z,DOSPC         ; Yes - Do 'E' spaces
2323   0EA6 3A 5B 31            LD      A,(CURPOS)      ; Get current position
2324   0EA9 2F          DOSPC:  CPL                     ; Number of spaces to print to
2325   0EAA 83                  ADD     A,E             ; Total number to print
2326   0EAB D2 B9 0E            JP      NC,NEXITM       ; TAB < Current POS(X)
2327   0EAE 3C          ASPCS:  INC     A               ; Output A spaces
2328   0EAF 47                  LD      B,A             ; Save number to print
2329   0EB0 3E 20               LD      A,' '           ; Space
2330   0EB2 CD 3C 0A    SPCLP:  CALL    OUTC            ; Output character in A
2331   0EB5 05                  DEC     B               ; Count them
2332   0EB6 C2 B2 0E            JP      NZ,SPCLP        ; Repeat if more
2333   0EB9 E1          NEXITM: POP     HL              ; Restore code string address
2334   0EBA CD BB 0B            CALL    GETCHR          ; Get next character
2335   0EBD C3 08 0E            JP      PRNTLP          ; More to print
2336   0EC0             
2337   0EC0 3F 52 65 64 REDO:   .BYTE   "?Redo from start",CR,LF,0
2337   0EC4 6F 20 66 72 
2337   0EC8 6F 6D 20 73 
2337   0ECC 74 61 72 74 
2337   0ED0 0D 0A 00 
2338   0ED3             
2339   0ED3 3A 7D 31    BADINP: LD      A,(READFG)      ; READ or INPUT?
2340   0ED6 B7                  OR      A
2341   0ED7 C2 5D 07            JP      NZ,DATSNR       ; READ - ?SN Error
2342   0EDA C1                  POP     BC              ; Throw away code string addr
2343   0EDB 21 C0 0E            LD      HL,REDO         ; "Redo from start" message
2344   0EDE CD 01 15            CALL    PRS             ; Output string
2345   0EE1 C3 AE 08            JP      DOAGN           ; Do last INPUT again
2346   0EE4             
2347   0EE4 CD 6C 14    INPUT:  CALL    IDTEST          ; Test for illegal direct
2348   0EE7 7E                  LD      A,(HL)          ; Get character after "INPUT"
2349   0EE8 FE 22               CP      '"'             ; Is there a prompt string?
2350   0EEA 3E 00               LD      A,0             ; Clear A and leave flags
2351   0EEC 32 F5 30            LD      (CTLOFG),A      ; Enable output
2352   0EEF C2 FE 0E            JP      NZ,NOPMPT       ; No prompt - get input
2353   0EF2 CD C0 14            CALL    QTSTR           ; Get string terminated by '"'
2354   0EF5 CD 31 0A            CALL    CHKSYN          ; Check for ';' after prompt
2355   0EF8 3B                  .BYTE   ';'
2356   0EF9 E5                  PUSH    HL              ; Save code string address
2357   0EFA CD 04 15            CALL    PRS1            ; Output prompt string
2358   0EFD 3E                  .BYTE   3EH             ; Skip "PUSH HL"
2359   0EFE E5          NOPMPT: PUSH    HL              ; Save code string address
2360   0EFF CD B2 08            CALL    PROMPT          ; Get input with "? " prompt
2361   0F02 C1                  POP     BC              ; Restore code string address
2362   0F03 DA 0A 0C            JP      C,INPBRK        ; Break pressed - Exit
2363   0F06 23                  INC     HL              ; Next byte
2364   0F07 7E                  LD      A,(HL)          ; Get it
2365   0F08 B7                  OR      A               ; End of line?
2366   0F09 2B                  DEC     HL              ; Back again
2367   0F0A C5                  PUSH    BC              ; Re-save code string address
2368   0F0B CA 51 0D            JP      Z,NXTDTA        ; Yes - Find next DATA stmt
2369   0F0E 36 2C               LD      (HL),','        ; Store comma as separator
2370   0F10 C3 18 0F            JP      NXTITM          ; Get next item
2371   0F13             
2372   0F13 E5          READ:   PUSH    HL              ; Save code string address
2373   0F14 2A 8C 31            LD      HL,(NXTDAT)     ; Next DATA statement
2374   0F17 F6                  .BYTE   0F6H            ; Flag "READ"
2375   0F18 AF          NXTITM: XOR     A               ; Flag "INPUT"
2376   0F19 32 7D 31            LD      (READFG),A      ; Save "READ"/"INPUT" flag
2377   0F1C E3                  EX      (SP),HL         ; Get code str' , Save pointer
2378   0F1D C3 24 0F            JP      GTVLUS          ; Get values
2379   0F20             
2380   0F20 CD 31 0A    NEDMOR: CALL    CHKSYN          ; Check for comma between items
2381   0F23 2C                  .BYTE      ','
2382   0F24 CD 1E 12    GTVLUS: CALL    GETVAR          ; Get variable name
2383   0F27 E3                  EX      (SP),HL         ; Save code str" , Get pointer
2384   0F28 D5                  PUSH    DE              ; Save variable address
2385   0F29 7E                  LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
2386   0F2A FE 2C               CP      ','             ; Comma?
2387   0F2C CA 4C 0F            JP      Z,ANTVLU        ; Yes - Get another value
2388   0F2F 3A 7D 31            LD      A,(READFG)      ; Is it READ?
2389   0F32 B7                  OR      A
2390   0F33 C2 B9 0F            JP      NZ,FDTLP        ; Yes - Find next DATA stmt
2391   0F36 3E 3F               LD      A,'?'           ; More INPUT needed
2392   0F38 CD 3C 0A            CALL    OUTC            ; Output character
2393   0F3B CD B2 08            CALL    PROMPT          ; Get INPUT with prompt
2394   0F3E D1                  POP     DE              ; Variable address
2395   0F3F C1                  POP     BC              ; Code string address
2396   0F40 DA 0A 0C            JP      C,INPBRK        ; Break pressed
2397   0F43 23                  INC     HL              ; Point to next DATA byte
2398   0F44 7E                  LD      A,(HL)          ; Get byte
2399   0F45 B7                  OR      A               ; Is it zero (No input) ?
2400   0F46 2B                  DEC     HL              ; Back space INPUT pointer
2401   0F47 C5                  PUSH    BC              ; Save code string address
2402   0F48 CA 51 0D            JP      Z,NXTDTA        ; Find end of buffer
2403   0F4B D5                  PUSH    DE              ; Save variable address
2404   0F4C 3A 5D 31    ANTVLU: LD      A,(TYPE)        ; Check data type
2405   0F4F B7                  OR      A               ; Is it numeric?
2406   0F50 CA 76 0F            JP      Z,INPBIN        ; Yes - Convert to binary
2407   0F53 CD BB 0B            CALL    GETCHR          ; Get next character
2408   0F56 57                  LD      D,A             ; Save input character
2409   0F57 47                  LD      B,A             ; Again
2410   0F58 FE 22               CP      '"'             ; Start of literal sting?
2411   0F5A CA 6A 0F            JP      Z,STRENT        ; Yes - Create string entry
2412   0F5D 3A 7D 31            LD      A,(READFG)      ; "READ" or "INPUT" ?
2413   0F60 B7                  OR      A
2414   0F61 57                  LD      D,A             ; Save 00 if "INPUT"
2415   0F62 CA 67 0F            JP      Z,ITMSEP        ; "INPUT" - End with 00
2416   0F65 16 3A               LD      D,':'           ; "DATA" - End with 00 or ':'
2417   0F67 06 2C       ITMSEP: LD      B,','           ; Item separator
2418   0F69 2B                  DEC     HL              ; Back space for DTSTR
2419   0F6A CD C3 14    STRENT: CALL    DTSTR           ; Get string terminated by D
2420   0F6D EB                  EX      DE,HL           ; String address to DE
2421   0F6E 21 81 0F            LD      HL,LTSTND       ; Where to go after LETSTR
2422   0F71 E3                  EX      (SP),HL         ; Save HL , get input pointer
2423   0F72 D5                  PUSH    DE              ; Save address of string
2424   0F73 C3 84 0D            JP      LETSTR          ; Assign string to variable
2425   0F76             
2426   0F76 CD BB 0B    INPBIN: CALL    GETCHR          ; Get next character
2427   0F79 CD 11 1B            CALL    ASCTFP          ; Convert ASCII to FP number
2428   0F7C E3                  EX      (SP),HL         ; Save input ptr, Get var addr
2429   0F7D CD 62 1A            CALL    FPTHL           ; Move FPREG to variable
2430   0F80 E1                  POP     HL              ; Restore input pointer
2431   0F81 2B          LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
2432   0F82 CD BB 0B            CALL    GETCHR          ; Get next character
2433   0F85 CA 8D 0F            JP      Z,MORDT         ; End of line - More needed?
2434   0F88 FE 2C               CP      ','             ; Another value?
2435   0F8A C2 D3 0E            JP      NZ,BADINP       ; No - Bad input
2436   0F8D E3          MORDT:  EX      (SP),HL         ; Get code string address
2437   0F8E 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2438   0F8F CD BB 0B            CALL    GETCHR          ; Get next character
2439   0F92 C2 20 0F            JP      NZ,NEDMOR       ; More needed - Get it
2440   0F95 D1                  POP     DE              ; Restore DATA pointer
2441   0F96 3A 7D 31            LD      A,(READFG)      ; "READ" or "INPUT" ?
2442   0F99 B7                  OR      A
2443   0F9A EB                  EX      DE,HL           ; DATA pointer to HL
2444   0F9B C2 E1 0B            JP      NZ,UPDATA       ; Update DATA pointer if "READ"
2445   0F9E D5                  PUSH    DE              ; Save code string address
2446   0F9F B6                  OR      (HL)            ; More input given?
2447   0FA0 21 A8 0F            LD      HL,EXTIG        ; "?Extra ignored" message
2448   0FA3 C4 01 15            CALL    NZ,PRS          ; Output string if extra given
2449   0FA6 E1                  POP     HL              ; Restore code string address
2450   0FA7 C9                  RET
2451   0FA8             
2452   0FA8 3F 45 78 74 EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
2452   0FAC 72 61 20 69 
2452   0FB0 67 6E 6F 72 
2452   0FB4 65 64 0D 0A 
2452   0FB8 00 
2453   0FB9             
2454   0FB9 CD 52 0D    FDTLP:  CALL    DATA            ; Get next statement
2455   0FBC B7                  OR      A               ; End of line?
2456   0FBD C2 D2 0F            JP      NZ,FANDT        ; No - See if DATA statement
2457   0FC0 23                  INC     HL
2458   0FC1 7E                  LD      A,(HL)          ; End of program?
2459   0FC2 23                  INC     HL
2460   0FC3 B6                  OR      (HL)            ; 00 00 Ends program
2461   0FC4 1E 06               LD      E,OD            ; ?OD Error
2462   0FC6 CA 77 07            JP      Z,ERROR         ; Yes - Out of DATA
2463   0FC9 23                  INC     HL
2464   0FCA 5E                  LD      E,(HL)          ; LSB of line number
2465   0FCB 23                  INC     HL
2466   0FCC 56                  LD      D,(HL)          ; MSB of line number
2467   0FCD EB                  EX      DE,HL
2468   0FCE 22 79 31            LD      (DATLIN),HL     ; Set line of current DATA item
2469   0FD1 EB                  EX      DE,HL
2470   0FD2 CD BB 0B    FANDT:  CALL    GETCHR          ; Get next character
2471   0FD5 FE 83               CP      ZDATA           ; "DATA" token
2472   0FD7 C2 B9 0F            JP      NZ,FDTLP        ; No "DATA" - Keep looking
2473   0FDA C3 4C 0F            JP      ANTVLU          ; Found - Convert input
2474   0FDD             
2475   0FDD 11 00 00    NEXT:   LD      DE,0            ; In case no index given
2476   0FE0 C4 1E 12    NEXT1:  CALL    NZ,GETVAR       ; Get index address
2477   0FE3 22 7E 31            LD      (BRKLIN),HL     ; Save code string address
2478   0FE6 CD 0C 07            CALL    BAKSTK          ; Look for "FOR" block
2479   0FE9 C2 69 07            JP      NZ,NFERR        ; No "FOR" - ?NF Error
2480   0FEC F9                  LD      SP,HL           ; Clear nested loops
2481   0FED D5                  PUSH    DE              ; Save index address
2482   0FEE 7E                  LD      A,(HL)          ; Get sign of STEP
2483   0FEF 23                  INC     HL
2484   0FF0 F5                  PUSH    AF              ; Save sign of STEP
2485   0FF1 D5                  PUSH    DE              ; Save index address
2486   0FF2 CD 48 1A            CALL    PHLTFP          ; Move index value to FPREG
2487   0FF5 E3                  EX      (SP),HL         ; Save address of TO value
2488   0FF6 E5                  PUSH    HL              ; Save address of index
2489   0FF7 CD B5 17            CALL    ADDPHL          ; Add STEP to index value
2490   0FFA E1                  POP     HL              ; Restore address of index
2491   0FFB CD 62 1A            CALL    FPTHL           ; Move value to index variable
2492   0FFE E1                  POP     HL              ; Restore address of TO value
2493   0FFF CD 59 1A            CALL    LOADFP          ; Move TO value to BCDE
2494   1002 E5                  PUSH    HL              ; Save address of line of FOR
2495   1003 CD 85 1A            CALL    CMPNUM          ; Compare index with TO value
2496   1006 E1                  POP     HL              ; Restore address of line num
2497   1007 C1                  POP     BC              ; Address of sign of STEP
2498   1008 90                  SUB     B               ; Compare with expected sign
2499   1009 CD 59 1A            CALL    LOADFP          ; BC = Loop stmt,DE = Line num
2500   100C CA 18 10            JP      Z,KILFOR        ; Loop finished - Terminate it
2501   100F EB                  EX      DE,HL           ; Loop statement line number
2502   1010 22 0C 31            LD      (LINEAT),HL     ; Set loop line number
2503   1013 69                  LD      L,C             ; Set code string to loop
2504   1014 60                  LD      H,B
2505   1015 C3 77 0B            JP      PUTFID          ; Put back "FOR" and continue
2506   1018             
2507   1018 F9          KILFOR: LD      SP,HL           ; Remove "FOR" block
2508   1019 2A 7E 31            LD      HL,(BRKLIN)     ; Code string after "NEXT"
2509   101C 7E                  LD      A,(HL)          ; Get next byte in code string
2510   101D FE 2C               CP      ','             ; More NEXTs ?
2511   101F C2 7B 0B            JP      NZ,RUNCNT       ; No - Do next statement
2512   1022 CD BB 0B            CALL    GETCHR          ; Position to index name
2513   1025 CD E0 0F            CALL    NEXT1           ; Re-enter NEXT routine
2514   1028             ; < will not RETurn to here , Exit to RUNCNT or Loop >
2515   1028             
2516   1028 CD 3A 10    GETNUM: CALL    EVAL            ; Get a numeric expression
2517   102B F6          TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
2518   102C 37          TSTSTR: SCF                     ; Set carry (string)
2519   102D 3A 5D 31    CHKTYP: LD      A,(TYPE)        ; Check types match
2520   1030 8F                  ADC     A,A             ; Expected + actual
2521   1031 B7                  OR      A               ; Clear carry , set parity
2522   1032 E8                  RET     PE              ; Even parity - Types match
2523   1033 C3 75 07            JP      TMERR           ; Different types - Error
2524   1036             
2525   1036 CD 31 0A    OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
2526   1039 28                  .BYTE   "("
2527   103A 2B          EVAL:   DEC     HL              ; Evaluate expression & save
2528   103B 16 00               LD      D,0             ; Precedence value
2529   103D D5          EVAL1:  PUSH    DE              ; Save precedence
2530   103E 0E 01               LD      C,1
2531   1040 CD 40 07            CALL    CHKSTK          ; Check for 1 level of stack
2532   1043 CD B1 10            CALL    OPRND           ; Get next expression value
2533   1046 22 80 31    EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
2534   1049 2A 80 31    EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
2535   104C C1                  POP     BC              ; Precedence value and operator
2536   104D 78                  LD      A,B             ; Get precedence value
2537   104E FE 78               CP      78H             ; "AND" or "OR" ?
2538   1050 D4 2B 10            CALL    NC,TSTNUM       ; No - Make sure it's a number
2539   1053 7E                  LD      A,(HL)          ; Get next operator / function
2540   1054 16 00               LD      D,0             ; Clear Last relation
2541   1056 D6 B3       RLTLP:  SUB     ZGTR            ; ">" Token
2542   1058 DA 72 10            JP      C,FOPRND        ; + - * / ^ AND OR - Test it
2543   105B FE 03               CP      ZLTH+1-ZGTR     ; < = >
2544   105D D2 72 10            JP      NC,FOPRND       ; Function - Call it
2545   1060 FE 01               CP      ZEQUAL-ZGTR     ; "="
2546   1062 17                  RLA                     ; <- Test for legal
2547   1063 AA                  XOR     D               ; <- combinations of < = >
2548   1064 BA                  CP      D               ; <- by combining last token
2549   1065 57                  LD      D,A             ; <- with current one
2550   1066 DA 63 07            JP      C,SNERR         ; Error if "<<' '==" or ">>"
2551   1069 22 75 31            LD      (CUROPR),HL     ; Save address of current token
2552   106C CD BB 0B            CALL    GETCHR          ; Get next character
2553   106F C3 56 10            JP      RLTLP           ; Treat the two as one
2554   1072             
2555   1072 7A          FOPRND: LD      A,D             ; < = > found ?
2556   1073 B7                  OR      A
2557   1074 C2 99 11            JP      NZ,TSTRED       ; Yes - Test for reduction
2558   1077 7E                  LD      A,(HL)          ; Get operator token
2559   1078 22 75 31            LD      (CUROPR),HL     ; Save operator address
2560   107B D6 AC               SUB     ZPLUS           ; Operator or function?
2561   107D D8                  RET     C               ; Neither - Exit
2562   107E FE 07               CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
2563   1080 D0                  RET     NC              ; No - Exit
2564   1081 5F                  LD      E,A             ; Coded operator
2565   1082 3A 5D 31            LD      A,(TYPE)        ; Get data type
2566   1085 3D                  DEC     A               ; FF = numeric , 00 = string
2567   1086 B3                  OR      E               ; Combine with coded operator
2568   1087 7B                  LD      A,E             ; Get coded operator
2569   1088 CA F7 15            JP      Z,CONCAT        ; String concatenation
2570   108B 07                  RLCA                    ; Times 2
2571   108C 83                  ADD     A,E             ; Times 3
2572   108D 5F                  LD      E,A             ; To DE (D is 0)
2573   108E 21 55 06            LD      HL,PRITAB       ; Precedence table
2574   1091 19                  ADD     HL,DE           ; To the operator concerned
2575   1092 78                  LD      A,B             ; Last operator precedence
2576   1093 56                  LD      D,(HL)          ; Get evaluation precedence
2577   1094 BA                  CP      D               ; Compare with eval precedence
2578   1095 D0                  RET     NC              ; Exit if higher precedence
2579   1096 23                  INC     HL              ; Point to routine address
2580   1097 CD 2B 10            CALL    TSTNUM          ; Make sure it's a number
2581   109A             
2582   109A C5          STKTHS: PUSH    BC              ; Save last precedence & token
2583   109B 01 49 10            LD      BC,EVAL3        ; Where to go on prec' break
2584   109E C5                  PUSH    BC              ; Save on stack for return
2585   109F 43                  LD      B,E             ; Save operator
2586   10A0 4A                  LD      C,D             ; Save precedence
2587   10A1 CD 3B 1A            CALL    STAKFP          ; Move value to stack
2588   10A4 58                  LD      E,B             ; Restore operator
2589   10A5 51                  LD      D,C             ; Restore precedence
2590   10A6 4E                  LD      C,(HL)          ; Get LSB of routine address
2591   10A7 23                  INC     HL
2592   10A8 46                  LD      B,(HL)          ; Get MSB of routine address
2593   10A9 23                  INC     HL
2594   10AA C5                  PUSH    BC              ; Save routine address
2595   10AB 2A 75 31            LD      HL,(CUROPR)     ; Address of current operator
2596   10AE C3 3D 10            JP      EVAL1           ; Loop until prec' break
2597   10B1             
2598   10B1 AF          OPRND:  XOR     A               ; Get operand routine
2599   10B2 32 5D 31            LD      (TYPE),A        ; Set numeric expected
2600   10B5 CD BB 0B            CALL    GETCHR          ; Get next character
2601   10B8 1E 24               LD      E,MO            ; ?MO Error
2602   10BA CA 77 07            JP      Z,ERROR         ; No operand - Error
2603   10BD DA 11 1B            JP      C,ASCTFP        ; Number - Get value
2604   10C0 CD 59 0C            CALL    CHKLTR          ; See if a letter
2605   10C3 D2 18 11            JP      NC,CONVAR       ; Letter - Find variable
2606   10C6 FE 26               CP		'&'				; &H = HEX, &B = BINARY
2607   10C8 20 12               JR		NZ, NOTAMP
2608   10CA CD BB 0B            CALL    GETCHR          ; Get next character
2609   10CD FE 48               CP      'H'             ; Hex number indicated? [function added]
2610   10CF CA 55 1F            JP      Z,HEXTFP        ; Convert Hex to FPREG
2611   10D2 FE 42               CP      'B'             ; Binary number indicated? [function added]
2612   10D4 CA C5 1F            JP      Z,BINTFP        ; Convert Bin to FPREG
2613   10D7 1E 02               LD      E,SN            ; If neither then a ?SN Error
2614   10D9 CA 77 07            JP      Z,ERROR         ; 
2615   10DC FE AC       NOTAMP: CP      ZPLUS           ; '+' Token ?
2616   10DE CA B1 10            JP      Z,OPRND         ; Yes - Look for operand
2617   10E1 FE 2E               CP      '.'             ; '.' ?
2618   10E3 CA 11 1B            JP      Z,ASCTFP        ; Yes - Create FP number
2619   10E6 FE AD               CP      ZMINUS          ; '-' Token ?
2620   10E8 CA 07 11            JP      Z,MINUS         ; Yes - Do minus
2621   10EB FE 22               CP      '"'             ; Literal string ?
2622   10ED CA C0 14            JP      Z,QTSTR         ; Get string terminated by '"'
2623   10F0 FE AA               CP      ZNOT            ; "NOT" Token ?
2624   10F2 CA F9 11            JP      Z,EVNOT         ; Yes - Eval NOT expression
2625   10F5 FE A7               CP      ZFN             ; "FN" Token ?
2626   10F7 CA 24 14            JP      Z,DOFN          ; Yes - Do FN routine
2627   10FA D6 B6               SUB     ZSGN            ; Is it a function?
2628   10FC D2 29 11            JP      NC,FNOFST       ; Yes - Evaluate function
2629   10FF CD 36 10    EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
2630   1102 CD 31 0A            CALL    CHKSYN          ; Make sure ")" follows
2631   1105 29                  .BYTE   ")"
2632   1106 C9                  RET
2633   1107             
2634   1107 16 7D       MINUS:  LD      D,7DH           ; '-' precedence
2635   1109 CD 3D 10            CALL    EVAL1           ; Evaluate until prec' break
2636   110C 2A 80 31            LD      HL,(NXTOPR)     ; Get next operator address
2637   110F E5                  PUSH    HL              ; Save next operator address
2638   1110 CD 33 1A            CALL    INVSGN          ; Negate value
2639   1113 CD 2B 10    RETNUM: CALL    TSTNUM          ; Make sure it's a number
2640   1116 E1                  POP     HL              ; Restore next operator address
2641   1117 C9                  RET
2642   1118             
2643   1118 CD 1E 12    CONVAR: CALL    GETVAR          ; Get variable address to DE
2644   111B E5          FRMEVL: PUSH    HL              ; Save code string address
2645   111C EB                  EX      DE,HL           ; Variable address to HL
2646   111D 22 94 31            LD      (FPREG),HL      ; Save address of variable
2647   1120 3A 5D 31            LD      A,(TYPE)        ; Get type
2648   1123 B7                  OR      A               ; Numeric?
2649   1124 CC 48 1A            CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
2650   1127 E1                  POP     HL              ; Restore code string address
2651   1128 C9                  RET
2652   1129             
2653   1129 06 00       FNOFST: LD      B,0             ; Get address of function
2654   112B 07                  RLCA                    ; Double function offset
2655   112C 4F                  LD      C,A             ; BC = Offset in function table
2656   112D C5                  PUSH    BC              ; Save adjusted token value
2657   112E CD BB 0B            CALL    GETCHR          ; Get next character
2658   1131 79                  LD      A,C             ; Get adjusted token value
2659   1132 FE 31               CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
2660   1134 DA 50 11            JP      C,FNVAL         ; No - Do function
2661   1137 CD 36 10            CALL    OPNPAR          ; Evaluate expression  (X,...
2662   113A CD 31 0A            CALL    CHKSYN          ; Make sure ',' follows
2663   113D 2C                  .BYTE      ','
2664   113E CD 2C 10            CALL    TSTSTR          ; Make sure it's a string
2665   1141 EB                  EX      DE,HL           ; Save code string address
2666   1142 2A 94 31            LD      HL,(FPREG)      ; Get address of string
2667   1145 E3                  EX      (SP),HL         ; Save address of string
2668   1146 E5                  PUSH    HL              ; Save adjusted token value
2669   1147 EB                  EX      DE,HL           ; Restore code string address
2670   1148 CD 89 17            CALL    GETINT          ; Get integer 0-255
2671   114B EB                  EX      DE,HL           ; Save code string address
2672   114C E3                  EX      (SP),HL         ; Save integer,HL = adj' token
2673   114D C3 58 11            JP      GOFUNC          ; Jump to string function
2674   1150             
2675   1150 CD FF 10    FNVAL:  CALL    EVLPAR          ; Evaluate expression
2676   1153 E3                  EX      (SP),HL         ; HL = Adjusted token value
2677   1154 11 13 11            LD      DE,RETNUM       ; Return number from function
2678   1157 D5                  PUSH    DE              ; Save on stack
2679   1158 01 B4 04    GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
2680   115B 09                  ADD     HL,BC           ; Point to right address
2681   115C 4E                  LD      C,(HL)          ; Get LSB of address
2682   115D 23                  INC     HL              ;
2683   115E 66                  LD      H,(HL)          ; Get MSB of address
2684   115F 69                  LD      L,C             ; Address to HL
2685   1160 E9                  JP      (HL)            ; Jump to function
2686   1161             
2687   1161 15          SGNEXP: DEC     D               ; Dee to flag negative exponent
2688   1162 FE AD               CP      ZMINUS          ; '-' token ?
2689   1164 C8                  RET     Z               ; Yes - Return
2690   1165 FE 2D               CP      '-'             ; '-' ASCII ?
2691   1167 C8                  RET     Z               ; Yes - Return
2692   1168 14                  INC     D               ; Inc to flag positive exponent
2693   1169 FE 2B               CP      '+'             ; '+' ASCII ?
2694   116B C8                  RET     Z               ; Yes - Return
2695   116C FE AC               CP      ZPLUS           ; '+' token ?
2696   116E C8                  RET     Z               ; Yes - Return
2697   116F 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2698   1170 C9                  RET                     ; Return "NZ"
2699   1171             
2700   1171 F6          POR:    .BYTE      0F6H            ; Flag "OR"
2701   1172 AF          PAND:   XOR     A               ; Flag "AND"
2702   1173 F5                  PUSH    AF              ; Save "AND" / "OR" flag
2703   1174 CD 2B 10            CALL    TSTNUM          ; Make sure it's a number
2704   1177 CD 6D 0C            CALL    DEINT           ; Get integer -32768 to 32767
2705   117A F1                  POP     AF              ; Restore "AND" / "OR" flag
2706   117B EB                  EX      DE,HL           ; <- Get last
2707   117C C1                  POP     BC              ; <-  value
2708   117D E3                  EX      (SP),HL         ; <-  from
2709   117E EB                  EX      DE,HL           ; <-  stack
2710   117F CD 4B 1A            CALL    FPBCDE          ; Move last value to FPREG
2711   1182 F5                  PUSH    AF              ; Save "AND" / "OR" flag
2712   1183 CD 6D 0C            CALL    DEINT           ; Get integer -32768 to 32767
2713   1186 F1                  POP     AF              ; Restore "AND" / "OR" flag
2714   1187 C1                  POP     BC              ; Get value
2715   1188 79                  LD      A,C             ; Get LSB
2716   1189 21 E2 13            LD      HL,ACPASS       ; Address of save AC as current
2717   118C C2 94 11            JP      NZ,POR1         ; Jump if OR
2718   118F A3                  AND     E               ; "AND" LSBs
2719   1190 4F                  LD      C,A             ; Save LSB
2720   1191 78                  LD      A,B             ; Get MBS
2721   1192 A2                  AND     D               ; "AND" MSBs
2722   1193 E9                  JP      (HL)            ; Save AC as current (ACPASS)
2723   1194             
2724   1194 B3          POR1:   OR      E               ; "OR" LSBs
2725   1195 4F                  LD      C,A             ; Save LSB
2726   1196 78                  LD      A,B             ; Get MSB
2727   1197 B2                  OR      D               ; "OR" MSBs
2728   1198 E9                  JP      (HL)            ; Save AC as current (ACPASS)
2729   1199             
2730   1199 21 AB 11    TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2731   119C 3A 5D 31            LD      A,(TYPE)        ; Get data type
2732   119F 1F                  RRA                     ; Carry set = string
2733   11A0 7A                  LD      A,D             ; Get last precedence value
2734   11A1 17                  RLA                     ; Times 2 plus carry
2735   11A2 5F                  LD      E,A             ; To E
2736   11A3 16 64               LD      D,64H           ; Relational precedence
2737   11A5 78                  LD      A,B             ; Get current precedence
2738   11A6 BA                  CP      D               ; Compare with last
2739   11A7 D0                  RET     NC              ; Eval if last was rel' or log'
2740   11A8 C3 9A 10            JP      STKTHS          ; Stack this one and get next
2741   11AB             
2742   11AB AD 11       CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
2743   11AD 79          CMPLG1: LD      A,C             ; Get data type
2744   11AE B7                  OR      A
2745   11AF 1F                  RRA
2746   11B0 C1                  POP     BC              ; Get last expression to BCDE
2747   11B1 D1                  POP     DE
2748   11B2 F5                  PUSH    AF              ; Save status
2749   11B3 CD 2D 10            CALL    CHKTYP          ; Check that types match
2750   11B6 21 EF 11            LD      HL,CMPRES       ; Result to comparison
2751   11B9 E5                  PUSH    HL              ; Save for RETurn
2752   11BA CA 85 1A            JP      Z,CMPNUM        ; Compare values if numeric
2753   11BD AF                  XOR     A               ; Compare two strings
2754   11BE 32 5D 31            LD      (TYPE),A        ; Set type to numeric
2755   11C1 D5                  PUSH    DE              ; Save string name
2756   11C2 CD 44 16            CALL    GSTRCU          ; Get current string
2757   11C5 7E                  LD      A,(HL)          ; Get length of string
2758   11C6 23                  INC     HL
2759   11C7 23                  INC     HL
2760   11C8 4E                  LD      C,(HL)          ; Get LSB of address
2761   11C9 23                  INC     HL
2762   11CA 46                  LD      B,(HL)          ; Get MSB of address
2763   11CB D1                  POP     DE              ; Restore string name
2764   11CC C5                  PUSH    BC              ; Save address of string
2765   11CD F5                  PUSH    AF              ; Save length of string
2766   11CE CD 48 16            CALL    GSTRDE          ; Get second string
2767   11D1 CD 59 1A            CALL    LOADFP          ; Get address of second string
2768   11D4 F1                  POP     AF              ; Restore length of string 1
2769   11D5 57                  LD      D,A             ; Length to D
2770   11D6 E1                  POP     HL              ; Restore address of string 1
2771   11D7 7B          CMPSTR: LD      A,E             ; Bytes of string 2 to do
2772   11D8 B2                  OR      D               ; Bytes of string 1 to do
2773   11D9 C8                  RET     Z               ; Exit if all bytes compared
2774   11DA 7A                  LD      A,D             ; Get bytes of string 1 to do
2775   11DB D6 01               SUB     1
2776   11DD D8                  RET     C               ; Exit if end of string 1
2777   11DE AF                  XOR     A
2778   11DF BB                  CP      E               ; Bytes of string 2 to do
2779   11E0 3C                  INC     A
2780   11E1 D0                  RET     NC              ; Exit if end of string 2
2781   11E2 15                  DEC     D               ; Count bytes in string 1
2782   11E3 1D                  DEC     E               ; Count bytes in string 2
2783   11E4 0A                  LD      A,(BC)          ; Byte in string 2
2784   11E5 BE                  CP      (HL)            ; Compare to byte in string 1
2785   11E6 23                  INC     HL              ; Move up string 1
2786   11E7 03                  INC     BC              ; Move up string 2
2787   11E8 CA D7 11            JP      Z,CMPSTR        ; Same - Try next bytes
2788   11EB 3F                  CCF                     ; Flag difference (">" or "<")
2789   11EC C3 15 1A            JP      FLGDIF          ; "<" gives -1 , ">" gives +1
2790   11EF             
2791   11EF 3C          CMPRES: INC     A               ; Increment current value
2792   11F0 8F                  ADC     A,A             ; Double plus carry
2793   11F1 C1                  POP     BC              ; Get other value
2794   11F2 A0                  AND     B               ; Combine them
2795   11F3 C6 FF               ADD     A,-1            ; Carry set if different
2796   11F5 9F                  SBC     A,A             ; 00 - Equal , FF - Different
2797   11F6 C3 1C 1A            JP      FLGREL          ; Set current value & continue
2798   11F9             
2799   11F9 16 5A       EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2800   11FB CD 3D 10            CALL    EVAL1           ; Eval until precedence break
2801   11FE CD 2B 10            CALL    TSTNUM          ; Make sure it's a number
2802   1201 CD 6D 0C            CALL    DEINT           ; Get integer -32768 - 32767
2803   1204 7B                  LD      A,E             ; Get LSB
2804   1205 2F                  CPL                     ; Invert LSB
2805   1206 4F                  LD      C,A             ; Save "NOT" of LSB
2806   1207 7A                  LD      A,D             ; Get MSB
2807   1208 2F                  CPL                     ; Invert MSB
2808   1209 CD E2 13            CALL    ACPASS          ; Save AC as current
2809   120C C1                  POP     BC              ; Clean up stack
2810   120D C3 49 10            JP      EVAL3           ; Continue evaluation
2811   1210             
2812   1210 2B          DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2813   1211 CD BB 0B            CALL    GETCHR          ; Get next character
2814   1214 C8                  RET     Z               ; End of DIM statement
2815   1215 CD 31 0A            CALL    CHKSYN          ; Make sure ',' follows
2816   1218 2C                  .BYTE      ','
2817   1219 01 10 12    DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2818   121C C5                  PUSH    BC              ; Save on stack
2819   121D F6                  .BYTE      0F6H            ; Flag "Create" variable
2820   121E AF          GETVAR: XOR     A               ; Find variable address,to DE
2821   121F 32 5C 31            LD      (LCRFLG),A      ; Set locate / create flag
2822   1222 46                  LD      B,(HL)          ; Get First byte of name
2823   1223 CD 59 0C    GTFNAM: CALL    CHKLTR          ; See if a letter
2824   1226 DA 63 07            JP      C,SNERR         ; ?SN Error if not a letter
2825   1229 AF                  XOR     A
2826   122A 4F                  LD      C,A             ; Clear second byte of name
2827   122B 32 5D 31            LD      (TYPE),A        ; Set type to numeric
2828   122E CD BB 0B            CALL    GETCHR          ; Get next character
2829   1231 DA 3A 12            JP      C,SVNAM2        ; Numeric - Save in name
2830   1234 CD 59 0C            CALL    CHKLTR          ; See if a letter
2831   1237 DA 47 12            JP      C,CHARTY        ; Not a letter - Check type
2832   123A 4F          SVNAM2: LD      C,A             ; Save second byte of name
2833   123B CD BB 0B    ENDNAM: CALL    GETCHR          ; Get next character
2834   123E DA 3B 12            JP      C,ENDNAM        ; Numeric - Get another
2835   1241 CD 59 0C            CALL    CHKLTR          ; See if a letter
2836   1244 D2 3B 12            JP      NC,ENDNAM       ; Letter - Get another
2837   1247 D6 24       CHARTY: SUB     '$'             ; String variable?
2838   1249 C2 56 12            JP      NZ,NOTSTR       ; No - Numeric variable
2839   124C 3C                  INC     A               ; A = 1 (string type)
2840   124D 32 5D 31            LD      (TYPE),A        ; Set type to string
2841   1250 0F                  RRCA                    ; A = 80H , Flag for string
2842   1251 81                  ADD     A,C             ; 2nd byte of name has bit 7 on
2843   1252 4F                  LD      C,A             ; Resave second byte on name
2844   1253 CD BB 0B            CALL    GETCHR          ; Get next character
2845   1256 3A 7B 31    NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2846   1259 3D                  DEC     A
2847   125A CA 03 13            JP      Z,ARLDSV        ; Yes - Get array name
2848   125D F2 66 12            JP      P,NSCFOR        ; No array with "FOR" or "FN"
2849   1260 7E                  LD      A,(HL)          ; Get byte again
2850   1261 D6 28               SUB     '('             ; Subscripted variable?
2851   1263 CA DB 12            JP      Z,SBSCPT        ; Yes - Sort out subscript
2852   1266             
2853   1266 AF          NSCFOR: XOR     A               ; Simple variable
2854   1267 32 7B 31            LD      (FORFLG),A      ; Clear "FOR" flag
2855   126A E5                  PUSH    HL              ; Save code string address
2856   126B 50                  LD      D,B             ; DE = Variable name to find
2857   126C 59                  LD      E,C
2858   126D 2A 8E 31            LD      HL,(FNRGNM)     ; FN argument name
2859   1270 CD 2B 0A            CALL    CPDEHL          ; Is it the FN argument?
2860   1273 11 90 31            LD      DE,FNARG        ; Point to argument value
2861   1276 CA 4B 19            JP      Z,POPHRT        ; Yes - Return FN argument value
2862   1279 2A 88 31            LD      HL,(VAREND)     ; End of variables
2863   127C EB                  EX      DE,HL           ; Address of end of search
2864   127D 2A 86 31            LD      HL,(PROGND)     ; Start of variables address
2865   1280 CD 2B 0A    FNDVAR: CALL    CPDEHL          ; End of variable list table?
2866   1283 CA 99 12            JP      Z,CFEVAL        ; Yes - Called from EVAL?
2867   1286 79                  LD      A,C             ; Get second byte of name
2868   1287 96                  SUB     (HL)            ; Compare with name in list
2869   1288 23                  INC     HL              ; Move on to first byte
2870   1289 C2 8E 12            JP      NZ,FNTHR        ; Different - Find another
2871   128C 78                  LD      A,B             ; Get first byte of name
2872   128D 96                  SUB     (HL)            ; Compare with name in list
2873   128E 23          FNTHR:  INC     HL              ; Move on to LSB of value
2874   128F CA CD 12            JP      Z,RETADR        ; Found - Return address
2875   1292 23                  INC     HL              ; <- Skip
2876   1293 23                  INC     HL              ; <- over
2877   1294 23                  INC     HL              ; <- F.P.
2878   1295 23                  INC     HL              ; <- value
2879   1296 C3 80 12            JP      FNDVAR          ; Keep looking
2880   1299             
2881   1299 E1          CFEVAL: POP     HL              ; Restore code string address
2882   129A E3                  EX      (SP),HL         ; Get return address
2883   129B D5                  PUSH    DE              ; Save address of variable
2884   129C 11 1B 11            LD      DE,FRMEVL       ; Return address in EVAL
2885   129F CD 2B 0A            CALL    CPDEHL          ; Called from EVAL ?
2886   12A2 D1                  POP     DE              ; Restore address of variable
2887   12A3 CA D0 12            JP      Z,RETNUL        ; Yes - Return null variable
2888   12A6 E3                  EX      (SP),HL         ; Put back return
2889   12A7 E5                  PUSH    HL              ; Save code string address
2890   12A8 C5                  PUSH    BC              ; Save variable name
2891   12A9 01 06 00            LD      BC,6            ; 2 byte name plus 4 byte data
2892   12AC 2A 8A 31            LD      HL,(ARREND)     ; End of arrays
2893   12AF E5                  PUSH    HL              ; Save end of arrays
2894   12B0 09                  ADD     HL,BC           ; Move up 6 bytes
2895   12B1 C1                  POP     BC              ; Source address in BC
2896   12B2 E5                  PUSH    HL              ; Save new end address
2897   12B3 CD 2F 07            CALL    MOVUP           ; Move arrays up
2898   12B6 E1                  POP     HL              ; Restore new end address
2899   12B7 22 8A 31            LD      (ARREND),HL     ; Set new end address
2900   12BA 60                  LD      H,B             ; End of variables to HL
2901   12BB 69                  LD      L,C
2902   12BC 22 88 31            LD      (VAREND),HL     ; Set new end address
2903   12BF             
2904   12BF 2B          ZEROLP: DEC     HL              ; Back through to zero variable
2905   12C0 36 00               LD      (HL),0          ; Zero byte in variable
2906   12C2 CD 2B 0A            CALL    CPDEHL          ; Done them all?
2907   12C5 C2 BF 12            JP      NZ,ZEROLP       ; No - Keep on going
2908   12C8 D1                  POP     DE              ; Get variable name
2909   12C9 73                  LD      (HL),E          ; Store second character
2910   12CA 23                  INC     HL
2911   12CB 72                  LD      (HL),D          ; Store first character
2912   12CC 23                  INC     HL
2913   12CD EB          RETADR: EX      DE,HL           ; Address of variable in DE
2914   12CE E1                  POP     HL              ; Restore code string address
2915   12CF C9                  RET
2916   12D0             
2917   12D0 32 97 31    RETNUL: LD      (FPEXP),A       ; Set result to zero
2918   12D3 21 FF 06            LD      HL,ZERBYT       ; Also set a null string
2919   12D6 22 94 31            LD      (FPREG),HL      ; Save for EVAL
2920   12D9 E1                  POP     HL              ; Restore code string address
2921   12DA C9                  RET
2922   12DB             
2923   12DB E5          SBSCPT: PUSH    HL              ; Save code string address
2924   12DC 2A 5C 31            LD      HL,(LCRFLG)     ; Locate/Create and Type
2925   12DF E3                  EX      (SP),HL         ; Save and get code string
2926   12E0 57                  LD      D,A             ; Zero number of dimensions
2927   12E1 D5          SCPTLP: PUSH    DE              ; Save number of dimensions
2928   12E2 C5                  PUSH    BC              ; Save array name
2929   12E3 CD 61 0C            CALL    FPSINT          ; Get subscript (0-32767)
2930   12E6 C1                  POP     BC              ; Restore array name
2931   12E7 F1                  POP     AF              ; Get number of dimensions
2932   12E8 EB                  EX      DE,HL
2933   12E9 E3                  EX      (SP),HL         ; Save subscript value
2934   12EA E5                  PUSH    HL              ; Save LCRFLG and TYPE
2935   12EB EB                  EX      DE,HL
2936   12EC 3C                  INC     A               ; Count dimensions
2937   12ED 57                  LD      D,A             ; Save in D
2938   12EE 7E                  LD      A,(HL)          ; Get next byte in code string
2939   12EF FE 2C               CP      ','             ; Comma (more to come)?
2940   12F1 CA E1 12            JP      Z,SCPTLP        ; Yes - More subscripts
2941   12F4 CD 31 0A            CALL    CHKSYN          ; Make sure ")" follows
2942   12F7 29                  .BYTE      ")"
2943   12F8 22 80 31            LD      (NXTOPR),HL     ; Save code string address
2944   12FB E1                  POP     HL              ; Get LCRFLG and TYPE
2945   12FC 22 5C 31            LD      (LCRFLG),HL     ; Restore Locate/create & type
2946   12FF 1E 00               LD      E,0             ; Flag not CSAVE* or CLOAD*
2947   1301 D5                  PUSH    DE              ; Save number of dimensions (D)
2948   1302 11                  .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
2949   1303             
2950   1303 E5          ARLDSV: PUSH    HL              ; Save code string address
2951   1304 F5                  PUSH    AF              ; A = 00 , Flags set = Z,N
2952   1305 2A 88 31            LD      HL,(VAREND)     ; Start of arrays
2953   1308 3E                  .BYTE      3EH             ; Skip "ADD HL,DE"
2954   1309 19          FNDARY: ADD     HL,DE           ; Move to next array start
2955   130A EB                  EX      DE,HL
2956   130B 2A 8A 31            LD      HL,(ARREND)     ; End of arrays
2957   130E EB                  EX      DE,HL           ; Current array pointer
2958   130F CD 2B 0A            CALL    CPDEHL          ; End of arrays found?
2959   1312 CA 3B 13            JP      Z,CREARY        ; Yes - Create array
2960   1315 7E                  LD      A,(HL)          ; Get second byte of name
2961   1316 B9                  CP      C               ; Compare with name given
2962   1317 23                  INC     HL              ; Move on
2963   1318 C2 1D 13            JP      NZ,NXTARY       ; Different - Find next array
2964   131B 7E                  LD      A,(HL)          ; Get first byte of name
2965   131C B8                  CP      B               ; Compare with name given
2966   131D 23          NXTARY: INC     HL              ; Move on
2967   131E 5E                  LD      E,(HL)          ; Get LSB of next array address
2968   131F 23                  INC     HL
2969   1320 56                  LD      D,(HL)          ; Get MSB of next array address
2970   1321 23                  INC     HL
2971   1322 C2 09 13            JP      NZ,FNDARY       ; Not found - Keep looking
2972   1325 3A 5C 31            LD      A,(LCRFLG)      ; Found Locate or Create it?
2973   1328 B7                  OR      A
2974   1329 C2 6C 07            JP      NZ,DDERR        ; Create - ?DD Error
2975   132C F1                  POP     AF              ; Locate - Get number of dim'ns
2976   132D 44                  LD      B,H             ; BC Points to array dim'ns
2977   132E 4D                  LD      C,L
2978   132F CA 4B 19            JP      Z,POPHRT        ; Jump if array load/save
2979   1332 96                  SUB     (HL)            ; Same number of dimensions?
2980   1333 CA 99 13            JP      Z,FINDEL        ; Yes - Find element
2981   1336 1E 10       BSERR:  LD      E,BS            ; ?BS Error
2982   1338 C3 77 07            JP      ERROR           ; Output error
2983   133B             
2984   133B 11 04 00    CREARY: LD      DE,4            ; 4 Bytes per entry
2985   133E F1                  POP     AF              ; Array to save or 0 dim'ns?
2986   133F CA 82 0C            JP      Z,FCERR         ; Yes - ?FC Error
2987   1342 71                  LD      (HL),C          ; Save second byte of name
2988   1343 23                  INC     HL
2989   1344 70                  LD      (HL),B          ; Save first byte of name
2990   1345 23                  INC     HL
2991   1346 4F                  LD      C,A             ; Number of dimensions to C
2992   1347 CD 40 07            CALL    CHKSTK          ; Check if enough memory
2993   134A 23                  INC     HL              ; Point to number of dimensions
2994   134B 23                  INC     HL
2995   134C 22 75 31            LD      (CUROPR),HL     ; Save address of pointer
2996   134F 71                  LD      (HL),C          ; Set number of dimensions
2997   1350 23                  INC     HL
2998   1351 3A 5C 31            LD      A,(LCRFLG)      ; Locate of Create?
2999   1354 17                  RLA                     ; Carry set = Create
3000   1355 79                  LD      A,C             ; Get number of dimensions
3001   1356 01 0B 00    CRARLP: LD      BC,10+1         ; Default dimension size 10
3002   1359 D2 5E 13            JP      NC,DEFSIZ       ; Locate - Set default size
3003   135C C1                  POP     BC              ; Get specified dimension size
3004   135D 03                  INC     BC              ; Include zero element
3005   135E 71          DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
3006   135F 23                  INC     HL
3007   1360 70                  LD      (HL),B          ; Save MSB of dimension size
3008   1361 23                  INC     HL
3009   1362 F5                  PUSH    AF              ; Save num' of dim'ns an status
3010   1363 E5                  PUSH    HL              ; Save address of dim'n size
3011   1364 CD F6 1A            CALL    MLDEBC          ; Multiply DE by BC to find
3012   1367 EB                  EX      DE,HL           ; amount of mem needed (to DE)
3013   1368 E1                  POP     HL              ; Restore address of dimension
3014   1369 F1                  POP     AF              ; Restore number of dimensions
3015   136A 3D                  DEC     A               ; Count them
3016   136B C2 56 13            JP      NZ,CRARLP       ; Do next dimension if more
3017   136E F5                  PUSH    AF              ; Save locate/create flag
3018   136F 42                  LD      B,D             ; MSB of memory needed
3019   1370 4B                  LD      C,E             ; LSB of memory needed
3020   1371 EB                  EX      DE,HL
3021   1372 19                  ADD     HL,DE           ; Add bytes to array start
3022   1373 DA 58 07            JP      C,OMERR         ; Too big - Error
3023   1376 CD 49 07            CALL    ENFMEM          ; See if enough memory
3024   1379 22 8A 31            LD      (ARREND),HL     ; Save new end of array
3025   137C             
3026   137C 2B          ZERARY: DEC     HL              ; Back through array data
3027   137D 36 00               LD      (HL),0          ; Set array element to zero
3028   137F CD 2B 0A            CALL    CPDEHL          ; All elements zeroed?
3029   1382 C2 7C 13            JP      NZ,ZERARY       ; No - Keep on going
3030   1385 03                  INC     BC              ; Number of bytes + 1
3031   1386 57                  LD      D,A             ; A=0
3032   1387 2A 75 31            LD      HL,(CUROPR)     ; Get address of array
3033   138A 5E                  LD      E,(HL)          ; Number of dimensions
3034   138B EB                  EX      DE,HL           ; To HL
3035   138C 29                  ADD     HL,HL           ; Two bytes per dimension size
3036   138D 09                  ADD     HL,BC           ; Add number of bytes
3037   138E EB                  EX      DE,HL           ; Bytes needed to DE
3038   138F 2B                  DEC     HL
3039   1390 2B                  DEC     HL
3040   1391 73                  LD      (HL),E          ; Save LSB of bytes needed
3041   1392 23                  INC     HL
3042   1393 72                  LD      (HL),D          ; Save MSB of bytes needed
3043   1394 23                  INC     HL
3044   1395 F1                  POP     AF              ; Locate / Create?
3045   1396 DA BD 13            JP      C,ENDDIM        ; A is 0 , End if create
3046   1399 47          FINDEL: LD      B,A             ; Find array element
3047   139A 4F                  LD      C,A
3048   139B 7E                  LD      A,(HL)          ; Number of dimensions
3049   139C 23                  INC     HL
3050   139D 16                  .BYTE      16H             ; Skip "POP HL"
3051   139E E1          FNDELP: POP     HL              ; Address of next dim' size
3052   139F 5E                  LD      E,(HL)          ; Get LSB of dim'n size
3053   13A0 23                  INC     HL
3054   13A1 56                  LD      D,(HL)          ; Get MSB of dim'n size
3055   13A2 23                  INC     HL
3056   13A3 E3                  EX      (SP),HL         ; Save address - Get index
3057   13A4 F5                  PUSH    AF              ; Save number of dim'ns
3058   13A5 CD 2B 0A            CALL    CPDEHL          ; Dimension too large?
3059   13A8 D2 36 13            JP      NC,BSERR        ; Yes - ?BS Error
3060   13AB E5                  PUSH    HL              ; Save index
3061   13AC CD F6 1A            CALL    MLDEBC          ; Multiply previous by size
3062   13AF D1                  POP     DE              ; Index supplied to DE
3063   13B0 19                  ADD     HL,DE           ; Add index to pointer
3064   13B1 F1                  POP     AF              ; Number of dimensions
3065   13B2 3D                  DEC     A               ; Count them
3066   13B3 44                  LD      B,H             ; MSB of pointer
3067   13B4 4D                  LD      C,L             ; LSB of pointer
3068   13B5 C2 9E 13            JP      NZ,FNDELP       ; More - Keep going
3069   13B8 29                  ADD     HL,HL           ; 4 Bytes per element
3070   13B9 29                  ADD     HL,HL
3071   13BA C1                  POP     BC              ; Start of array
3072   13BB 09                  ADD     HL,BC           ; Point to element
3073   13BC EB                  EX      DE,HL           ; Address of element to DE
3074   13BD 2A 80 31    ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
3075   13C0 C9                  RET
3076   13C1             
3077   13C1 2A 8A 31    FRE:    LD      HL,(ARREND)     ; Start of free memory
3078   13C4 EB                  EX      DE,HL           ; To DE
3079   13C5 21 00 00            LD      HL,0            ; End of free memory
3080   13C8 39                  ADD     HL,SP           ; Current stack value
3081   13C9 3A 5D 31            LD      A,(TYPE)        ; Dummy argument type
3082   13CC B7                  OR      A
3083   13CD CA DD 13            JP      Z,FRENUM        ; Numeric - Free variable space
3084   13D0 CD 44 16            CALL    GSTRCU          ; Current string to pool
3085   13D3 CD 44 15            CALL    GARBGE          ; Garbage collection
3086   13D6 2A 0A 31            LD      HL,(STRSPC)     ; Bottom of string space in use
3087   13D9 EB                  EX      DE,HL           ; To DE
3088   13DA 2A 73 31            LD      HL,(STRBOT)     ; Bottom of string space
3089   13DD 7D          FRENUM: LD      A,L             ; Get LSB of end
3090   13DE 93                  SUB     E               ; Subtract LSB of beginning
3091   13DF 4F                  LD      C,A             ; Save difference if C
3092   13E0 7C                  LD      A,H             ; Get MSB of end
3093   13E1 9A                  SBC     A,D             ; Subtract MSB of beginning
3094   13E2 41          ACPASS: LD      B,C             ; Return integer AC
3095   13E3 50          ABPASS: LD      D,B             ; Return integer AB
3096   13E4 1E 00               LD      E,0
3097   13E6 21 5D 31            LD      HL,TYPE         ; Point to type
3098   13E9 73                  LD      (HL),E          ; Set type to numeric
3099   13EA 06 90               LD      B,80H+16        ; 16 bit integer
3100   13EC C3 21 1A            JP      RETINT          ; Return the integr
3101   13EF             
3102   13EF 3A 5B 31    POS:    LD      A,(CURPOS)      ; Get cursor position
3103   13F2 47          PASSA:  LD      B,A             ; Put A into AB
3104   13F3 AF                  XOR     A               ; Zero A
3105   13F4 C3 E3 13            JP      ABPASS          ; Return integer AB
3106   13F7             
3107   13F7 CD 7A 14    DEF:    CALL    CHEKFN          ; Get "FN" and name
3108   13FA CD 6C 14            CALL    IDTEST          ; Test for illegal direct
3109   13FD 01 52 0D            LD      BC,DATA         ; To get next statement
3110   1400 C5                  PUSH    BC              ; Save address for RETurn
3111   1401 D5                  PUSH    DE              ; Save address of function ptr
3112   1402 CD 31 0A            CALL    CHKSYN          ; Make sure "(" follows
3113   1405 28                  .BYTE      "("
3114   1406 CD 1E 12            CALL    GETVAR          ; Get argument variable name
3115   1409 E5                  PUSH    HL              ; Save code string address
3116   140A EB                  EX      DE,HL           ; Argument address to HL
3117   140B 2B                  DEC     HL
3118   140C 56                  LD      D,(HL)          ; Get first byte of arg name
3119   140D 2B                  DEC     HL
3120   140E 5E                  LD      E,(HL)          ; Get second byte of arg name
3121   140F E1                  POP     HL              ; Restore code string address
3122   1410 CD 2B 10            CALL    TSTNUM          ; Make sure numeric argument
3123   1413 CD 31 0A            CALL    CHKSYN          ; Make sure ")" follows
3124   1416 29                  .BYTE      ")"
3125   1417 CD 31 0A            CALL    CHKSYN          ; Make sure "=" follows
3126   141A B4                  .BYTE      ZEQUAL          ; "=" token
3127   141B 44                  LD      B,H             ; Code string address to BC
3128   141C 4D                  LD      C,L
3129   141D E3                  EX      (SP),HL         ; Save code str , Get FN ptr
3130   141E 71                  LD      (HL),C          ; Save LSB of FN code string
3131   141F 23                  INC     HL
3132   1420 70                  LD      (HL),B          ; Save MSB of FN code string
3133   1421 C3 B9 14            JP      SVSTAD          ; Save address and do function
3134   1424             
3135   1424 CD 7A 14    DOFN:   CALL    CHEKFN          ; Make sure FN follows
3136   1427 D5                  PUSH    DE              ; Save function pointer address
3137   1428 CD FF 10            CALL    EVLPAR          ; Evaluate expression in "()"
3138   142B CD 2B 10            CALL    TSTNUM          ; Make sure numeric result
3139   142E E3                  EX      (SP),HL         ; Save code str , Get FN ptr
3140   142F 5E                  LD      E,(HL)          ; Get LSB of FN code string
3141   1430 23                  INC     HL
3142   1431 56                  LD      D,(HL)          ; Get MSB of FN code string
3143   1432 23                  INC     HL
3144   1433 7A                  LD      A,D             ; And function DEFined?
3145   1434 B3                  OR      E
3146   1435 CA 6F 07            JP      Z,UFERR         ; No - ?UF Error
3147   1438 7E                  LD      A,(HL)          ; Get LSB of argument address
3148   1439 23                  INC     HL
3149   143A 66                  LD      H,(HL)          ; Get MSB of argument address
3150   143B 6F                  LD      L,A             ; HL = Arg variable address
3151   143C E5                  PUSH    HL              ; Save it
3152   143D 2A 8E 31            LD      HL,(FNRGNM)     ; Get old argument name
3153   1440 E3                  EX      (SP),HL ;       ; Save old , Get new
3154   1441 22 8E 31            LD      (FNRGNM),HL     ; Set new argument name
3155   1444 2A 92 31            LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
3156   1447 E5                  PUSH    HL              ; Save it
3157   1448 2A 90 31            LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
3158   144B E5                  PUSH    HL              ; Save it
3159   144C 21 90 31            LD      HL,FNARG        ; HL = Value of argument
3160   144F D5                  PUSH    DE              ; Save FN code string address
3161   1450 CD 62 1A            CALL    FPTHL           ; Move FPREG to argument
3162   1453 E1                  POP     HL              ; Get FN code string address
3163   1454 CD 28 10            CALL    GETNUM          ; Get value from function
3164   1457 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
3165   1458 CD BB 0B            CALL    GETCHR          ; Get next character
3166   145B C2 63 07            JP      NZ,SNERR        ; Bad character in FN - Error
3167   145E E1                  POP     HL              ; Get MSB,EXP of old arg
3168   145F 22 90 31            LD      (FNARG),HL      ; Restore it
3169   1462 E1                  POP     HL              ; Get LSB,NLSB of old arg
3170   1463 22 92 31            LD      (FNARG+2),HL    ; Restore it
3171   1466 E1                  POP     HL              ; Get name of old arg
3172   1467 22 8E 31            LD      (FNRGNM),HL     ; Restore it
3173   146A E1                  POP     HL              ; Restore code string address
3174   146B C9                  RET
3175   146C             
3176   146C E5          IDTEST: PUSH    HL              ; Save code string address
3177   146D 2A 0C 31            LD      HL,(LINEAT)     ; Get current line number
3178   1470 23                  INC     HL              ; -1 means direct statement
3179   1471 7C                  LD      A,H
3180   1472 B5                  OR      L
3181   1473 E1                  POP     HL              ; Restore code string address
3182   1474 C0                  RET     NZ              ; Return if in program
3183   1475 1E 16               LD      E,ID            ; ?ID Error
3184   1477 C3 77 07            JP      ERROR
3185   147A             
3186   147A CD 31 0A    CHEKFN: CALL    CHKSYN          ; Make sure FN follows
3187   147D A7                  .BYTE      ZFN             ; "FN" token
3188   147E 3E 80               LD      A,80H
3189   1480 32 7B 31            LD      (FORFLG),A      ; Flag FN name to find
3190   1483 B6                  OR      (HL)            ; FN name has bit 7 set
3191   1484 47                  LD      B,A             ; in first byte of name
3192   1485 CD 23 12            CALL    GTFNAM          ; Get FN name
3193   1488 C3 2B 10            JP      TSTNUM          ; Make sure numeric function
3194   148B             
3195   148B CD 2B 10    STR:    CALL    TSTNUM          ; Make sure it's a number
3196   148E CD AF 1B            CALL    NUMASC          ; Turn number into text
3197   1491 CD BF 14    STR1:   CALL    CRTST           ; Create string entry for it
3198   1494 CD 44 16            CALL    GSTRCU          ; Current string to pool
3199   1497 01 9F 16            LD      BC,TOPOOL       ; Save in string pool
3200   149A C5                  PUSH    BC              ; Save address on stack
3201   149B             
3202   149B 7E          SAVSTR: LD      A,(HL)          ; Get string length
3203   149C 23                  INC     HL
3204   149D 23                  INC     HL
3205   149E E5                  PUSH    HL              ; Save pointer to string
3206   149F CD 1A 15            CALL    TESTR           ; See if enough string space
3207   14A2 E1                  POP     HL              ; Restore pointer to string
3208   14A3 4E                  LD      C,(HL)          ; Get LSB of address
3209   14A4 23                  INC     HL
3210   14A5 46                  LD      B,(HL)          ; Get MSB of address
3211   14A6 CD B3 14            CALL    CRTMST          ; Create string entry
3212   14A9 E5                  PUSH    HL              ; Save pointer to MSB of addr
3213   14AA 6F                  LD      L,A             ; Length of string
3214   14AB CD 37 16            CALL    TOSTRA          ; Move to string area
3215   14AE D1                  POP     DE              ; Restore pointer to MSB
3216   14AF C9                  RET
3217   14B0             
3218   14B0 CD 1A 15    MKTMST: CALL    TESTR           ; See if enough string space
3219   14B3 21 6F 31    CRTMST: LD      HL,TMPSTR       ; Temporary string
3220   14B6 E5                  PUSH    HL              ; Save it
3221   14B7 77                  LD      (HL),A          ; Save length of string
3222   14B8 23                  INC     HL
3223   14B9 23          SVSTAD: INC     HL
3224   14BA 73                  LD      (HL),E          ; Save LSB of address
3225   14BB 23                  INC     HL
3226   14BC 72                  LD      (HL),D          ; Save MSB of address
3227   14BD E1                  POP     HL              ; Restore pointer
3228   14BE C9                  RET
3229   14BF             
3230   14BF 2B          CRTST:  DEC     HL              ; DEC - INCed after
3231   14C0 06 22       QTSTR:  LD      B,'"'           ; Terminating quote
3232   14C2 50                  LD      D,B             ; Quote to D
3233   14C3 E5          DTSTR:  PUSH    HL              ; Save start
3234   14C4 0E FF               LD      C,-1            ; Set counter to -1
3235   14C6 23          QTSTLP: INC     HL              ; Move on
3236   14C7 7E                  LD      A,(HL)          ; Get byte
3237   14C8 0C                  INC     C               ; Count bytes
3238   14C9 B7                  OR      A               ; End of line?
3239   14CA CA D5 14            JP      Z,CRTSTE        ; Yes - Create string entry
3240   14CD BA                  CP      D               ; Terminator D found?
3241   14CE CA D5 14            JP      Z,CRTSTE        ; Yes - Create string entry
3242   14D1 B8                  CP      B               ; Terminator B found?
3243   14D2 C2 C6 14            JP      NZ,QTSTLP       ; No - Keep looking
3244   14D5 FE 22       CRTSTE: CP      '"'             ; End with '"'?
3245   14D7 CC BB 0B            CALL    Z,GETCHR        ; Yes - Get next character
3246   14DA E3                  EX      (SP),HL         ; Starting quote
3247   14DB 23                  INC     HL              ; First byte of string
3248   14DC EB                  EX      DE,HL           ; To DE
3249   14DD 79                  LD      A,C             ; Get length
3250   14DE CD B3 14            CALL    CRTMST          ; Create string entry
3251   14E1 11 6F 31    TSTOPL: LD      DE,TMPSTR       ; Temporary string
3252   14E4 2A 61 31            LD      HL,(TMSTPT)     ; Temporary string pool pointer
3253   14E7 22 94 31            LD      (FPREG),HL      ; Save address of string ptr
3254   14EA 3E 01               LD      A,1
3255   14EC 32 5D 31            LD      (TYPE),A        ; Set type to string
3256   14EF CD 65 1A            CALL    DETHL4          ; Move string to pool
3257   14F2 CD 2B 0A            CALL    CPDEHL          ; Out of string pool?
3258   14F5 22 61 31            LD      (TMSTPT),HL     ; Save new pointer
3259   14F8 E1                  POP     HL              ; Restore code string address
3260   14F9 7E                  LD      A,(HL)          ; Get next code byte
3261   14FA C0                  RET     NZ              ; Return if pool OK
3262   14FB 1E 1E               LD      E,ST            ; ?ST Error
3263   14FD C3 77 07            JP      ERROR           ; String pool overflow
3264   1500             
3265   1500 23          PRNUMS: INC     HL              ; Skip leading space
3266   1501 CD BF 14    PRS:    CALL    CRTST           ; Create string entry for it
3267   1504 CD 44 16    PRS1:   CALL    GSTRCU          ; Current string to pool
3268   1507 CD 59 1A            CALL    LOADFP          ; Move string block to BCDE
3269   150A 1C                  INC     E               ; Length + 1
3270   150B 1D          PRSLP:  DEC     E               ; Count characters
3271   150C C8                  RET     Z               ; End of string
3272   150D 0A                  LD      A,(BC)          ; Get byte to output
3273   150E CD 3C 0A            CALL    OUTC            ; Output character in A
3274   1511 FE 0D               CP      CR              ; Return?
3275   1513 CC 6D 0E            CALL    Z,DONULL        ; Yes - Do nulls
3276   1516 03                  INC     BC              ; Next byte in string
3277   1517 C3 0B 15            JP      PRSLP           ; More characters to output
3278   151A             
3279   151A B7          TESTR:  OR      A               ; Test if enough room
3280   151B 0E                  .BYTE      0EH             ; No garbage collection done
3281   151C F1          GRBDON: POP     AF              ; Garbage collection done
3282   151D F5                  PUSH    AF              ; Save status
3283   151E 2A 0A 31            LD      HL,(STRSPC)     ; Bottom of string space in use
3284   1521 EB                  EX      DE,HL           ; To DE
3285   1522 2A 73 31            LD      HL,(STRBOT)     ; Bottom of string area
3286   1525 2F                  CPL                     ; Negate length (Top down)
3287   1526 4F                  LD      C,A             ; -Length to BC
3288   1527 06 FF               LD      B,-1            ; BC = -ve length of string
3289   1529 09                  ADD     HL,BC           ; Add to bottom of space in use
3290   152A 23                  INC     HL              ; Plus one for 2's complement
3291   152B CD 2B 0A            CALL    CPDEHL          ; Below string RAM area?
3292   152E DA 38 15            JP      C,TESTOS        ; Tidy up if not done else err
3293   1531 22 73 31            LD      (STRBOT),HL     ; Save new bottom of area
3294   1534 23                  INC     HL              ; Point to first byte of string
3295   1535 EB                  EX      DE,HL           ; Address to DE
3296   1536 F1          POPAF:  POP     AF              ; Throw away status push
3297   1537 C9                  RET
3298   1538             
3299   1538 F1          TESTOS: POP     AF              ; Garbage collect been done?
3300   1539 1E 1A               LD      E,OS            ; ?OS Error
3301   153B CA 77 07            JP      Z,ERROR         ; Yes - Not enough string apace
3302   153E BF                  CP      A               ; Flag garbage collect done
3303   153F F5                  PUSH    AF              ; Save status
3304   1540 01 1C 15            LD      BC,GRBDON       ; Garbage collection done
3305   1543 C5                  PUSH    BC              ; Save for RETurn
3306   1544 2A 5F 31    GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
3307   1547 22 73 31    GARBLP: LD      (STRBOT),HL     ; Reset string pointer
3308   154A 21 00 00            LD      HL,0
3309   154D E5                  PUSH    HL              ; Flag no string found
3310   154E 2A 0A 31            LD      HL,(STRSPC)     ; Get bottom of string space
3311   1551 E5                  PUSH    HL              ; Save bottom of string space
3312   1552 21 63 31            LD      HL,TMSTPL       ; Temporary string pool
3313   1555 EB          GRBLP:  EX      DE,HL
3314   1556 2A 61 31            LD      HL,(TMSTPT)     ; Temporary string pool pointer
3315   1559 EB                  EX      DE,HL
3316   155A CD 2B 0A            CALL    CPDEHL          ; Temporary string pool done?
3317   155D 01 55 15            LD      BC,GRBLP        ; Loop until string pool done
3318   1560 C2 A9 15            JP      NZ,STPOOL       ; No - See if in string area
3319   1563 2A 86 31            LD      HL,(PROGND)     ; Start of simple variables
3320   1566 EB          SMPVAR: EX      DE,HL
3321   1567 2A 88 31            LD      HL,(VAREND)     ; End of simple variables
3322   156A EB                  EX      DE,HL
3323   156B CD 2B 0A            CALL    CPDEHL          ; All simple strings done?
3324   156E CA 7C 15            JP      Z,ARRLP         ; Yes - Do string arrays
3325   1571 7E                  LD      A,(HL)          ; Get type of variable
3326   1572 23                  INC     HL
3327   1573 23                  INC     HL
3328   1574 B7                  OR      A               ; "S" flag set if string
3329   1575 CD AC 15            CALL    STRADD          ; See if string in string area
3330   1578 C3 66 15            JP      SMPVAR          ; Loop until simple ones done
3331   157B             
3332   157B C1          GNXARY: POP     BC              ; Scrap address of this array
3333   157C EB          ARRLP:  EX      DE,HL
3334   157D 2A 8A 31            LD      HL,(ARREND)     ; End of string arrays
3335   1580 EB                  EX      DE,HL
3336   1581 CD 2B 0A            CALL    CPDEHL          ; All string arrays done?
3337   1584 CA D2 15            JP      Z,SCNEND        ; Yes - Move string if found
3338   1587 CD 59 1A            CALL    LOADFP          ; Get array name to BCDE
3339   158A 7B                  LD      A,E             ; Get type of array     
3340   158B E5                  PUSH    HL              ; Save address of num of dim'ns
3341   158C 09                  ADD     HL,BC           ; Start of next array
3342   158D B7                  OR      A               ; Test type of array
3343   158E F2 7B 15            JP      P,GNXARY        ; Numeric array - Ignore it
3344   1591 22 75 31            LD      (CUROPR),HL     ; Save address of next array
3345   1594 E1                  POP     HL              ; Get address of num of dim'ns
3346   1595 4E                  LD      C,(HL)          ; BC = Number of dimensions
3347   1596 06 00               LD      B,0
3348   1598 09                  ADD     HL,BC           ; Two bytes per dimension size
3349   1599 09                  ADD     HL,BC
3350   159A 23                  INC     HL              ; Plus one for number of dim'ns
3351   159B EB          GRBARY: EX      DE,HL
3352   159C 2A 75 31            LD      HL,(CUROPR)     ; Get address of next array
3353   159F EB                  EX      DE,HL
3354   15A0 CD 2B 0A            CALL    CPDEHL          ; Is this array finished?
3355   15A3 CA 7C 15            JP      Z,ARRLP         ; Yes - Get next one
3356   15A6 01 9B 15            LD      BC,GRBARY       ; Loop until array all done
3357   15A9 C5          STPOOL: PUSH    BC              ; Save return address
3358   15AA F6 80               OR      80H             ; Flag string type
3359   15AC 7E          STRADD: LD      A,(HL)          ; Get string length
3360   15AD 23                  INC     HL
3361   15AE 23                  INC     HL
3362   15AF 5E                  LD      E,(HL)          ; Get LSB of string address
3363   15B0 23                  INC     HL
3364   15B1 56                  LD      D,(HL)          ; Get MSB of string address
3365   15B2 23                  INC     HL
3366   15B3 F0                  RET     P               ; Not a string - Return
3367   15B4 B7                  OR      A               ; Set flags on string length
3368   15B5 C8                  RET     Z               ; Null string - Return
3369   15B6 44                  LD      B,H             ; Save variable pointer
3370   15B7 4D                  LD      C,L
3371   15B8 2A 73 31            LD      HL,(STRBOT)     ; Bottom of new area
3372   15BB CD 2B 0A            CALL    CPDEHL          ; String been done?
3373   15BE 60                  LD      H,B             ; Restore variable pointer
3374   15BF 69                  LD      L,C
3375   15C0 D8                  RET     C               ; String done - Ignore
3376   15C1 E1                  POP     HL              ; Return address
3377   15C2 E3                  EX      (SP),HL         ; Lowest available string area
3378   15C3 CD 2B 0A            CALL    CPDEHL          ; String within string area?
3379   15C6 E3                  EX      (SP),HL         ; Lowest available string area
3380   15C7 E5                  PUSH    HL              ; Re-save return address
3381   15C8 60                  LD      H,B             ; Restore variable pointer
3382   15C9 69                  LD      L,C
3383   15CA D0                  RET     NC              ; Outside string area - Ignore
3384   15CB C1                  POP     BC              ; Get return , Throw 2 away
3385   15CC F1                  POP     AF              ; 
3386   15CD F1                  POP     AF              ; 
3387   15CE E5                  PUSH    HL              ; Save variable pointer
3388   15CF D5                  PUSH    DE              ; Save address of current
3389   15D0 C5                  PUSH    BC              ; Put back return address
3390   15D1 C9                  RET                     ; Go to it
3391   15D2             
3392   15D2 D1          SCNEND: POP     DE              ; Addresses of strings
3393   15D3 E1                  POP     HL              ; 
3394   15D4 7D                  LD      A,L             ; HL = 0 if no more to do
3395   15D5 B4                  OR      H
3396   15D6 C8                  RET     Z               ; No more to do - Return
3397   15D7 2B                  DEC     HL
3398   15D8 46                  LD      B,(HL)          ; MSB of address of string
3399   15D9 2B                  DEC     HL
3400   15DA 4E                  LD      C,(HL)          ; LSB of address of string
3401   15DB E5                  PUSH    HL              ; Save variable address
3402   15DC 2B                  DEC     HL
3403   15DD 2B                  DEC     HL
3404   15DE 6E                  LD      L,(HL)          ; HL = Length of string
3405   15DF 26 00               LD      H,0
3406   15E1 09                  ADD     HL,BC           ; Address of end of string+1
3407   15E2 50                  LD      D,B             ; String address to DE
3408   15E3 59                  LD      E,C
3409   15E4 2B                  DEC     HL              ; Last byte in string
3410   15E5 44                  LD      B,H             ; Address to BC
3411   15E6 4D                  LD      C,L
3412   15E7 2A 73 31            LD      HL,(STRBOT)     ; Current bottom of string area
3413   15EA CD 32 07            CALL    MOVSTR          ; Move string to new address
3414   15ED E1                  POP     HL              ; Restore variable address
3415   15EE 71                  LD      (HL),C          ; Save new LSB of address
3416   15EF 23                  INC     HL
3417   15F0 70                  LD      (HL),B          ; Save new MSB of address
3418   15F1 69                  LD      L,C             ; Next string area+1 to HL
3419   15F2 60                  LD      H,B
3420   15F3 2B                  DEC     HL              ; Next string area address
3421   15F4 C3 47 15            JP      GARBLP          ; Look for more strings
3422   15F7             
3423   15F7 C5          CONCAT: PUSH    BC              ; Save prec' opr & code string
3424   15F8 E5                  PUSH    HL              ; 
3425   15F9 2A 94 31            LD      HL,(FPREG)      ; Get first string
3426   15FC E3                  EX      (SP),HL         ; Save first string
3427   15FD CD B1 10            CALL    OPRND           ; Get second string
3428   1600 E3                  EX      (SP),HL         ; Restore first string
3429   1601 CD 2C 10            CALL    TSTSTR          ; Make sure it's a string
3430   1604 7E                  LD      A,(HL)          ; Get length of second string
3431   1605 E5                  PUSH    HL              ; Save first string
3432   1606 2A 94 31            LD      HL,(FPREG)      ; Get second string
3433   1609 E5                  PUSH    HL              ; Save second string
3434   160A 86                  ADD     A,(HL)          ; Add length of second string
3435   160B 1E 1C               LD      E,LS            ; ?LS Error
3436   160D DA 77 07            JP      C,ERROR         ; String too long - Error
3437   1610 CD B0 14            CALL    MKTMST          ; Make temporary string
3438   1613 D1                  POP     DE              ; Get second string to DE
3439   1614 CD 48 16            CALL    GSTRDE          ; Move to string pool if needed
3440   1617 E3                  EX      (SP),HL         ; Get first string
3441   1618 CD 47 16            CALL    GSTRHL          ; Move to string pool if needed
3442   161B E5                  PUSH    HL              ; Save first string
3443   161C 2A 71 31            LD      HL,(TMPSTR+2)   ; Temporary string address
3444   161F EB                  EX      DE,HL           ; To DE
3445   1620 CD 2E 16            CALL    SSTSA           ; First string to string area
3446   1623 CD 2E 16            CALL    SSTSA           ; Second string to string area
3447   1626 21 46 10            LD      HL,EVAL2        ; Return to evaluation loop
3448   1629 E3                  EX      (SP),HL         ; Save return,get code string
3449   162A E5                  PUSH    HL              ; Save code string address
3450   162B C3 E1 14            JP      TSTOPL          ; To temporary string to pool
3451   162E             
3452   162E E1          SSTSA:  POP     HL              ; Return address
3453   162F E3                  EX      (SP),HL         ; Get string block,save return
3454   1630 7E                  LD      A,(HL)          ; Get length of string
3455   1631 23                  INC     HL
3456   1632 23                  INC     HL
3457   1633 4E                  LD      C,(HL)          ; Get LSB of string address
3458   1634 23                  INC     HL
3459   1635 46                  LD      B,(HL)          ; Get MSB of string address
3460   1636 6F                  LD      L,A             ; Length to L
3461   1637 2C          TOSTRA: INC     L               ; INC - DECed after
3462   1638 2D          TSALP:  DEC     L               ; Count bytes moved
3463   1639 C8                  RET     Z               ; End of string - Return
3464   163A 0A                  LD      A,(BC)          ; Get source
3465   163B 12                  LD      (DE),A          ; Save destination
3466   163C 03                  INC     BC              ; Next source
3467   163D 13                  INC     DE              ; Next destination
3468   163E C3 38 16            JP      TSALP           ; Loop until string moved
3469   1641             
3470   1641 CD 2C 10    GETSTR: CALL    TSTSTR          ; Make sure it's a string
3471   1644 2A 94 31    GSTRCU: LD      HL,(FPREG)      ; Get current string
3472   1647 EB          GSTRHL: EX      DE,HL           ; Save DE
3473   1648 CD 62 16    GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
3474   164B EB                  EX      DE,HL           ; Restore DE
3475   164C C0                  RET     NZ              ; No - Return
3476   164D D5                  PUSH    DE              ; Save string
3477   164E 50                  LD      D,B             ; String block address to DE
3478   164F 59                  LD      E,C
3479   1650 1B                  DEC     DE              ; Point to length
3480   1651 4E                  LD      C,(HL)          ; Get string length
3481   1652 2A 73 31            LD      HL,(STRBOT)     ; Current bottom of string area
3482   1655 CD 2B 0A            CALL    CPDEHL          ; Last one in string area?
3483   1658 C2 60 16            JP      NZ,POPHL        ; No - Return
3484   165B 47                  LD      B,A             ; Clear B (A=0)
3485   165C 09                  ADD     HL,BC           ; Remove string from str' area
3486   165D 22 73 31            LD      (STRBOT),HL     ; Save new bottom of str' area
3487   1660 E1          POPHL:  POP     HL              ; Restore string
3488   1661 C9                  RET
3489   1662             
3490   1662 2A 61 31    BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
3491   1665 2B                  DEC     HL              ; Back
3492   1666 46                  LD      B,(HL)          ; Get MSB of address
3493   1667 2B                  DEC     HL              ; Back
3494   1668 4E                  LD      C,(HL)          ; Get LSB of address
3495   1669 2B                  DEC     HL              ; Back
3496   166A 2B                  DEC     HL              ; Back
3497   166B CD 2B 0A            CALL    CPDEHL          ; String last in string pool?
3498   166E C0                  RET     NZ              ; Yes - Leave it
3499   166F 22 61 31            LD      (TMSTPT),HL     ; Save new string pool top
3500   1672 C9                  RET
3501   1673             
3502   1673 01 F2 13    LEN:    LD      BC,PASSA        ; To return integer A
3503   1676 C5                  PUSH    BC              ; Save address
3504   1677 CD 41 16    GETLEN: CALL    GETSTR          ; Get string and its length
3505   167A AF                  XOR     A
3506   167B 57                  LD      D,A             ; Clear D
3507   167C 32 5D 31            LD      (TYPE),A        ; Set type to numeric
3508   167F 7E                  LD      A,(HL)          ; Get length of string
3509   1680 B7                  OR      A               ; Set status flags
3510   1681 C9                  RET
3511   1682             
3512   1682 01 F2 13    ASC:    LD      BC,PASSA        ; To return integer A
3513   1685 C5                  PUSH    BC              ; Save address
3514   1686 CD 77 16    GTFLNM: CALL    GETLEN          ; Get length of string
3515   1689 CA 82 0C            JP      Z,FCERR         ; Null string - Error
3516   168C 23                  INC     HL
3517   168D 23                  INC     HL
3518   168E 5E                  LD      E,(HL)          ; Get LSB of address
3519   168F 23                  INC     HL
3520   1690 56                  LD      D,(HL)          ; Get MSB of address
3521   1691 1A                  LD      A,(DE)          ; Get first byte of string
3522   1692 C9                  RET
3523   1693             
3524   1693 3E 01       CHR:    LD      A,1             ; One character string
3525   1695 CD B0 14            CALL    MKTMST          ; Make a temporary string
3526   1698 CD 8C 17            CALL    MAKINT          ; Make it integer A
3527   169B 2A 71 31            LD      HL,(TMPSTR+2)   ; Get address of string
3528   169E 73                  LD      (HL),E          ; Save character
3529   169F C1          TOPOOL: POP     BC              ; Clean up stack
3530   16A0 C3 E1 14            JP      TSTOPL          ; Temporary string to pool
3531   16A3             
3532   16A3 CD 3C 17    LEFT:   CALL    LFRGNM          ; Get number and ending ")"
3533   16A6 AF                  XOR     A               ; Start at first byte in string
3534   16A7 E3          RIGHT1: EX      (SP),HL         ; Save code string,Get string
3535   16A8 4F                  LD      C,A             ; Starting position in string
3536   16A9 E5          MID1:   PUSH    HL              ; Save string block address
3537   16AA 7E                  LD      A,(HL)          ; Get length of string
3538   16AB B8                  CP      B               ; Compare with number given
3539   16AC DA B1 16            JP      C,ALLFOL        ; All following bytes required
3540   16AF 78                  LD      A,B             ; Get new length
3541   16B0 11                  .BYTE      11H             ; Skip "LD C,0"
3542   16B1 0E 00       ALLFOL: LD      C,0             ; First byte of string
3543   16B3 C5                  PUSH    BC              ; Save position in string
3544   16B4 CD 1A 15            CALL    TESTR           ; See if enough string space
3545   16B7 C1                  POP     BC              ; Get position in string
3546   16B8 E1                  POP     HL              ; Restore string block address
3547   16B9 E5                  PUSH    HL              ; And re-save it
3548   16BA 23                  INC     HL
3549   16BB 23                  INC     HL
3550   16BC 46                  LD      B,(HL)          ; Get LSB of address
3551   16BD 23                  INC     HL
3552   16BE 66                  LD      H,(HL)          ; Get MSB of address
3553   16BF 68                  LD      L,B             ; HL = address of string
3554   16C0 06 00               LD      B,0             ; BC = starting address
3555   16C2 09                  ADD     HL,BC           ; Point to that byte
3556   16C3 44                  LD      B,H             ; BC = source string
3557   16C4 4D                  LD      C,L
3558   16C5 CD B3 14            CALL    CRTMST          ; Create a string entry
3559   16C8 6F                  LD      L,A             ; Length of new string
3560   16C9 CD 37 16            CALL    TOSTRA          ; Move string to string area
3561   16CC D1                  POP     DE              ; Clear stack
3562   16CD CD 48 16            CALL    GSTRDE          ; Move to string pool if needed
3563   16D0 C3 E1 14            JP      TSTOPL          ; Temporary string to pool
3564   16D3             
3565   16D3 CD 3C 17    RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
3566   16D6 D1                  POP     DE              ; Get string length
3567   16D7 D5                  PUSH    DE              ; And re-save
3568   16D8 1A                  LD      A,(DE)          ; Get length
3569   16D9 90                  SUB     B               ; Move back N bytes
3570   16DA C3 A7 16            JP      RIGHT1          ; Go and get sub-string
3571   16DD             
3572   16DD EB          MID:    EX      DE,HL           ; Get code string address
3573   16DE 7E                  LD      A,(HL)          ; Get next byte ',' or ")"
3574   16DF CD 41 17            CALL    MIDNUM          ; Get number supplied
3575   16E2 04                  INC     B               ; Is it character zero?
3576   16E3 05                  DEC     B
3577   16E4 CA 82 0C            JP      Z,FCERR         ; Yes - Error
3578   16E7 C5                  PUSH    BC              ; Save starting position
3579   16E8 1E FF               LD      E,255           ; All of string
3580   16EA FE 29               CP      ')'             ; Any length given?
3581   16EC CA F6 16            JP      Z,RSTSTR        ; No - Rest of string
3582   16EF CD 31 0A            CALL    CHKSYN          ; Make sure ',' follows
3583   16F2 2C                  .BYTE      ','
3584   16F3 CD 89 17            CALL    GETINT          ; Get integer 0-255
3585   16F6 CD 31 0A    RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
3586   16F9 29                  .BYTE      ")"
3587   16FA F1                  POP     AF              ; Restore starting position
3588   16FB E3                  EX      (SP),HL         ; Get string,8ave code string
3589   16FC 01 A9 16            LD      BC,MID1         ; Continuation of MID$ routine
3590   16FF C5                  PUSH    BC              ; Save for return
3591   1700 3D                  DEC     A               ; Starting position-1
3592   1701 BE                  CP      (HL)            ; Compare with length
3593   1702 06 00               LD      B,0             ; Zero bytes length
3594   1704 D0                  RET     NC              ; Null string if start past end
3595   1705 4F                  LD      C,A             ; Save starting position-1
3596   1706 7E                  LD      A,(HL)          ; Get length of string
3597   1707 91                  SUB     C               ; Subtract start
3598   1708 BB                  CP      E               ; Enough string for it?
3599   1709 47                  LD      B,A             ; Save maximum length available
3600   170A D8                  RET     C               ; Truncate string if needed
3601   170B 43                  LD      B,E             ; Set specified length
3602   170C C9                  RET                     ; Go and create string
3603   170D             
3604   170D CD 77 16    VAL:    CALL    GETLEN          ; Get length of string
3605   1710 CA 2A 18            JP      Z,RESZER        ; Result zero
3606   1713 5F                  LD      E,A             ; Save length
3607   1714 23                  INC     HL
3608   1715 23                  INC     HL
3609   1716 7E                  LD      A,(HL)          ; Get LSB of address
3610   1717 23                  INC     HL
3611   1718 66                  LD      H,(HL)          ; Get MSB of address
3612   1719 6F                  LD      L,A             ; HL = String address
3613   171A E5                  PUSH    HL              ; Save string address
3614   171B 19                  ADD     HL,DE
3615   171C 46                  LD      B,(HL)          ; Get end of string+1 byte
3616   171D 72                  LD      (HL),D          ; Zero it to terminate
3617   171E E3                  EX      (SP),HL         ; Save string end,get start
3618   171F C5                  PUSH    BC              ; Save end+1 byte
3619   1720 7E                  LD      A,(HL)          ; Get starting byte
3620   1721 FE 24           CP	'$'		; Hex number indicated? [function added]
3621   1723 C2 2B 17        JP	NZ,VAL1
3622   1726 CD 55 1F        CALL	HEXTFP		; Convert Hex to FPREG
3623   1729 18 0D           JR	VAL3
3624   172B FE 25       VAL1:	CP	'%'		; Binary number indicated? [function added]
3625   172D C2 35 17        JP	NZ,VAL2
3626   1730 CD C5 1F        CALL	BINTFP		; Convert Bin to FPREG
3627   1733 18 03           JR	VAL3
3628   1735 CD 11 1B    VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
3629   1738 C1          VAL3:   POP     BC              ; Restore end+1 byte
3630   1739 E1                  POP     HL              ; Restore end+1 address
3631   173A 70                  LD      (HL),B          ; Put back original byte
3632   173B C9                  RET
3633   173C             
3634   173C EB          LFRGNM: EX      DE,HL           ; Code string address to HL
3635   173D CD 31 0A            CALL    CHKSYN          ; Make sure ")" follows
3636   1740 29                  .BYTE      ")"
3637   1741 C1          MIDNUM: POP     BC              ; Get return address
3638   1742 D1                  POP     DE              ; Get number supplied
3639   1743 C5                  PUSH    BC              ; Re-save return address
3640   1744 43                  LD      B,E             ; Number to B
3641   1745 C9                  RET
3642   1746             
3643   1746 CD 8C 17    INP:    CALL    MAKINT          ; Make it integer A
3644   1749 32 EF 30            LD      (INPORT),A      ; Set input port
3645   174C CD EE 30            CALL    INPSUB          ; Get input from port
3646   174F C3 F2 13            JP      PASSA           ; Return integer A
3647   1752             
3648   1752 CD 76 17    POUT:   CALL    SETIO           ; Set up port number
3649   1755 C3 B6 30            JP      OUTSUB          ; Output data and return
3650   1758             
3651   1758 CD 76 17    WAIT:   CALL    SETIO           ; Set up port number
3652   175B F5                  PUSH    AF              ; Save AND mask
3653   175C 1E 00               LD      E,0             ; Assume zero if none given
3654   175E 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
3655   175F CD BB 0B            CALL    GETCHR          ; Get next character
3656   1762 CA 6C 17            JP      Z,NOXOR         ; No XOR byte given
3657   1765 CD 31 0A            CALL    CHKSYN          ; Make sure ',' follows
3658   1768 2C                  .BYTE      ','
3659   1769 CD 89 17            CALL    GETINT          ; Get integer 0-255 to XOR with
3660   176C C1          NOXOR:  POP     BC              ; Restore AND mask
3661   176D CD EE 30    WAITLP: CALL    INPSUB          ; Get input
3662   1770 AB                  XOR     E               ; Flip selected bits
3663   1771 A0                  AND     B               ; Result non-zero?
3664   1772 CA 6D 17            JP      Z,WAITLP        ; No = keep waiting
3665   1775 C9                  RET
3666   1776             
3667   1776 CD 89 17    SETIO:  CALL    GETINT          ; Get integer 0-255
3668   1779 32 EF 30            LD      (INPORT),A      ; Set input port
3669   177C 32 B7 30            LD      (OTPORT),A      ; Set output port
3670   177F CD 31 0A            CALL    CHKSYN          ; Make sure ',' follows
3671   1782 2C                  .BYTE      ','
3672   1783 C3 89 17            JP      GETINT          ; Get integer 0-255 and return
3673   1786             
3674   1786 CD BB 0B    FNDNUM: CALL    GETCHR          ; Get next character
3675   1789 CD 28 10    GETINT: CALL    GETNUM          ; Get a number from 0 to 255
3676   178C CD 67 0C    MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
3677   178F 7A                  LD      A,D             ; Get MSB of number
3678   1790 B7                  OR      A               ; Zero?
3679   1791 C2 82 0C            JP      NZ,FCERR        ; No - Error
3680   1794 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
3681   1795 CD BB 0B            CALL    GETCHR          ; Get next character
3682   1798 7B                  LD      A,E             ; Get number to A
3683   1799 C9                  RET
3684   179A             
3685   179A CD 6D 0C    PEEK:   CALL    DEINT           ; Get memory address
3686   179D 1A                  LD      A,(DE)          ; Get byte in memory
3687   179E C3 F2 13            JP      PASSA           ; Return integer A
3688   17A1             
3689   17A1 CD 28 10    POKE:   CALL    GETNUM          ; Get memory address
3690   17A4 CD 6D 0C            CALL    DEINT           ; Get integer -32768 to 3276
3691   17A7 D5                  PUSH    DE              ; Save memory address
3692   17A8 CD 31 0A            CALL    CHKSYN          ; Make sure ',' follows
3693   17AB 2C                  .BYTE      ','
3694   17AC CD 89 17            CALL    GETINT          ; Get integer 0-255
3695   17AF D1                  POP     DE              ; Restore memory address
3696   17B0 12                  LD      (DE),A          ; Load it into memory
3697   17B1 C9                  RET
3698   17B2             
3699   17B2 21 88 1C    ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
3700   17B5 CD 59 1A    ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
3701   17B8 C3 C4 17            JP      FPADD           ; Add BCDE to FPREG
3702   17BB             
3703   17BB CD 59 1A    SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3704   17BE 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3705   17BF C1          PSUB:   POP     BC              ; Get FP number from stack
3706   17C0 D1                  POP     DE
3707   17C1 CD 33 1A    SUBCDE: CALL    INVSGN          ; Negate FPREG
3708   17C4 78          FPADD:  LD      A,B             ; Get FP exponent
3709   17C5 B7                  OR      A               ; Is number zero?
3710   17C6 C8                  RET     Z               ; Yes - Nothing to add
3711   17C7 3A 97 31            LD      A,(FPEXP)       ; Get FPREG exponent
3712   17CA B7                  OR      A               ; Is this number zero?
3713   17CB CA 4B 1A            JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3714   17CE 90                  SUB     B               ; BCDE number larger?
3715   17CF D2 DE 17            JP      NC,NOSWAP       ; No - Don't swap them
3716   17D2 2F                  CPL                     ; Two's complement
3717   17D3 3C                  INC     A               ;  FP exponent
3718   17D4 EB                  EX      DE,HL
3719   17D5 CD 3B 1A            CALL    STAKFP          ; Put FPREG on stack
3720   17D8 EB                  EX      DE,HL
3721   17D9 CD 4B 1A            CALL    FPBCDE          ; Move BCDE to FPREG
3722   17DC C1                  POP     BC              ; Restore number from stack
3723   17DD D1                  POP     DE
3724   17DE FE 19       NOSWAP: CP      24+1            ; Second number insignificant?
3725   17E0 D0                  RET     NC              ; Yes - First number is result
3726   17E1 F5                  PUSH    AF              ; Save number of bits to scale
3727   17E2 CD 70 1A            CALL    SIGNS           ; Set MSBs & sign of result
3728   17E5 67                  LD      H,A             ; Save sign of result
3729   17E6 F1                  POP     AF              ; Restore scaling factor
3730   17E7 CD 89 18            CALL    SCALE           ; Scale BCDE to same exponent
3731   17EA B4                  OR      H               ; Result to be positive?
3732   17EB 21 94 31            LD      HL,FPREG        ; Point to FPREG
3733   17EE F2 04 18            JP      P,MINCDE        ; No - Subtract FPREG from CDE
3734   17F1 CD 69 18            CALL    PLUCDE          ; Add FPREG to CDE
3735   17F4 D2 4A 18            JP      NC,RONDUP       ; No overflow - Round it up
3736   17F7 23                  INC     HL              ; Point to exponent
3737   17F8 34                  INC     (HL)            ; Increment it
3738   17F9 CA 72 07            JP      Z,OVERR         ; Number overflowed - Error
3739   17FC 2E 01               LD      L,1             ; 1 bit to shift right
3740   17FE CD 9F 18            CALL    SHRT1           ; Shift result right
3741   1801 C3 4A 18            JP      RONDUP          ; Round it up
3742   1804             
3743   1804 AF          MINCDE: XOR     A               ; Clear A and carry
3744   1805 90                  SUB     B               ; Negate exponent
3745   1806 47                  LD      B,A             ; Re-save exponent
3746   1807 7E                  LD      A,(HL)          ; Get LSB of FPREG
3747   1808 9B                  SBC     A, E            ; Subtract LSB of BCDE
3748   1809 5F                  LD      E,A             ; Save LSB of BCDE
3749   180A 23                  INC     HL
3750   180B 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3751   180C 9A                  SBC     A,D             ; Subtract NMSB of BCDE
3752   180D 57                  LD      D,A             ; Save NMSB of BCDE
3753   180E 23                  INC     HL
3754   180F 7E                  LD      A,(HL)          ; Get MSB of FPREG
3755   1810 99                  SBC     A,C             ; Subtract MSB of BCDE
3756   1811 4F                  LD      C,A             ; Save MSB of BCDE
3757   1812 DC 75 18    CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
3758   1815             
3759   1815 68          BNORM:  LD      L,B             ; L = Exponent
3760   1816 63                  LD      H,E             ; H = LSB
3761   1817 AF                  XOR     A
3762   1818 47          BNRMLP: LD      B,A             ; Save bit count
3763   1819 79                  LD      A,C             ; Get MSB
3764   181A B7                  OR      A               ; Is it zero?
3765   181B C2 37 18            JP      NZ,PNORM        ; No - Do it bit at a time
3766   181E 4A                  LD      C,D             ; MSB = NMSB
3767   181F 54                  LD      D,H             ; NMSB= LSB
3768   1820 65                  LD      H,L             ; LSB = VLSB
3769   1821 6F                  LD      L,A             ; VLSB= 0
3770   1822 78                  LD      A,B             ; Get exponent
3771   1823 D6 08               SUB     8               ; Count 8 bits
3772   1825 FE E0               CP      -24-8           ; Was number zero?
3773   1827 C2 18 18            JP      NZ,BNRMLP       ; No - Keep normalising
3774   182A AF          RESZER: XOR     A               ; Result is zero
3775   182B 32 97 31    SAVEXP: LD      (FPEXP),A       ; Save result as zero
3776   182E C9                  RET
3777   182F             
3778   182F 05          NORMAL: DEC     B               ; Count bits
3779   1830 29                  ADD     HL,HL           ; Shift HL left
3780   1831 7A                  LD      A,D             ; Get NMSB
3781   1832 17                  RLA                     ; Shift left with last bit
3782   1833 57                  LD      D,A             ; Save NMSB
3783   1834 79                  LD      A,C             ; Get MSB
3784   1835 8F                  ADC     A,A             ; Shift left with last bit
3785   1836 4F                  LD      C,A             ; Save MSB
3786   1837 F2 2F 18    PNORM:  JP      P,NORMAL        ; Not done - Keep going
3787   183A 78                  LD      A,B             ; Number of bits shifted
3788   183B 5C                  LD      E,H             ; Save HL in EB
3789   183C 45                  LD      B,L
3790   183D B7                  OR      A               ; Any shifting done?
3791   183E CA 4A 18            JP      Z,RONDUP        ; No - Round it up
3792   1841 21 97 31            LD      HL,FPEXP        ; Point to exponent
3793   1844 86                  ADD     A,(HL)          ; Add shifted bits
3794   1845 77                  LD      (HL),A          ; Re-save exponent
3795   1846 D2 2A 18            JP      NC,RESZER       ; Underflow - Result is zero
3796   1849 C8                  RET     Z               ; Result is zero
3797   184A 78          RONDUP: LD      A,B             ; Get VLSB of number
3798   184B 21 97 31    RONDB:  LD      HL,FPEXP        ; Point to exponent
3799   184E B7                  OR      A               ; Any rounding?
3800   184F FC 5C 18            CALL    M,FPROND        ; Yes - Round number up
3801   1852 46                  LD      B,(HL)          ; B = Exponent
3802   1853 23                  INC     HL
3803   1854 7E                  LD      A,(HL)          ; Get sign of result
3804   1855 E6 80               AND     10000000B       ; Only bit 7 needed
3805   1857 A9                  XOR     C               ; Set correct sign
3806   1858 4F                  LD      C,A             ; Save correct sign in number
3807   1859 C3 4B 1A            JP      FPBCDE          ; Move BCDE to FPREG
3808   185C             
3809   185C 1C          FPROND: INC     E               ; Round LSB
3810   185D C0                  RET     NZ              ; Return if ok
3811   185E 14                  INC     D               ; Round NMSB
3812   185F C0                  RET     NZ              ; Return if ok
3813   1860 0C                  INC     C               ; Round MSB
3814   1861 C0                  RET     NZ              ; Return if ok
3815   1862 0E 80               LD      C,80H           ; Set normal value
3816   1864 34                  INC     (HL)            ; Increment exponent
3817   1865 C0                  RET     NZ              ; Return if ok
3818   1866 C3 72 07            JP      OVERR           ; Overflow error
3819   1869             
3820   1869 7E          PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
3821   186A 83                  ADD     A,E             ; Add LSB of BCDE
3822   186B 5F                  LD      E,A             ; Save LSB of BCDE
3823   186C 23                  INC     HL
3824   186D 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3825   186E 8A                  ADC     A,D             ; Add NMSB of BCDE
3826   186F 57                  LD      D,A             ; Save NMSB of BCDE
3827   1870 23                  INC     HL
3828   1871 7E                  LD      A,(HL)          ; Get MSB of FPREG
3829   1872 89                  ADC     A,C             ; Add MSB of BCDE
3830   1873 4F                  LD      C,A             ; Save MSB of BCDE
3831   1874 C9                  RET
3832   1875             
3833   1875 21 98 31    COMPL:  LD      HL,SGNRES       ; Sign of result
3834   1878 7E                  LD      A,(HL)          ; Get sign of result
3835   1879 2F                  CPL                     ; Negate it
3836   187A 77                  LD      (HL),A          ; Put it back
3837   187B AF                  XOR     A
3838   187C 6F                  LD      L,A             ; Set L to zero
3839   187D 90                  SUB     B               ; Negate exponent,set carry
3840   187E 47                  LD      B,A             ; Re-save exponent
3841   187F 7D                  LD      A,L             ; Load zero
3842   1880 9B                  SBC     A,E             ; Negate LSB
3843   1881 5F                  LD      E,A             ; Re-save LSB
3844   1882 7D                  LD      A,L             ; Load zero
3845   1883 9A                  SBC     A,D             ; Negate NMSB
3846   1884 57                  LD      D,A             ; Re-save NMSB
3847   1885 7D                  LD      A,L             ; Load zero
3848   1886 99                  SBC     A,C             ; Negate MSB
3849   1887 4F                  LD      C,A             ; Re-save MSB
3850   1888 C9                  RET
3851   1889             
3852   1889 06 00       SCALE:  LD      B,0             ; Clear underflow
3853   188B D6 08       SCALLP: SUB     8               ; 8 bits (a whole byte)?
3854   188D DA 98 18            JP      C,SHRITE        ; No - Shift right A bits
3855   1890 43                  LD      B,E             ; <- Shift
3856   1891 5A                  LD      E,D             ; <- right
3857   1892 51                  LD      D,C             ; <- eight
3858   1893 0E 00               LD      C,0             ; <- bits
3859   1895 C3 8B 18            JP      SCALLP          ; More bits to shift
3860   1898             
3861   1898 C6 09       SHRITE: ADD     A,8+1           ; Adjust count
3862   189A 6F                  LD      L,A             ; Save bits to shift
3863   189B AF          SHRLP:  XOR     A               ; Flag for all done
3864   189C 2D                  DEC     L               ; All shifting done?
3865   189D C8                  RET     Z               ; Yes - Return
3866   189E 79                  LD      A,C             ; Get MSB
3867   189F 1F          SHRT1:  RRA                     ; Shift it right
3868   18A0 4F                  LD      C,A             ; Re-save
3869   18A1 7A                  LD      A,D             ; Get NMSB
3870   18A2 1F                  RRA                     ; Shift right with last bit
3871   18A3 57                  LD      D,A             ; Re-save it
3872   18A4 7B                  LD      A,E             ; Get LSB
3873   18A5 1F                  RRA                     ; Shift right with last bit
3874   18A6 5F                  LD      E,A             ; Re-save it
3875   18A7 78                  LD      A,B             ; Get underflow
3876   18A8 1F                  RRA                     ; Shift right with last bit
3877   18A9 47                  LD      B,A             ; Re-save underflow
3878   18AA C3 9B 18            JP      SHRLP           ; More bits to do
3879   18AD             
3880   18AD 00 00 00 81 UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
3881   18B1             
3882   18B1 03          LOGTAB: .BYTE      3                       ; Table used by LOG
3883   18B2 AA 56 19 80         .BYTE      0AAH,056H,019H,080H     ; 0.59898
3884   18B6 F1 22 76 80         .BYTE      0F1H,022H,076H,080H     ; 0.96147
3885   18BA 45 AA 38 82         .BYTE      045H,0AAH,038H,082H     ; 2.88539
3886   18BE             
3887   18BE CD 0A 1A    LOG:    CALL    TSTSGN          ; Test sign of value
3888   18C1 B7                  OR      A
3889   18C2 EA 82 0C            JP      PE,FCERR        ; ?FC Error if <= zero
3890   18C5 21 97 31            LD      HL,FPEXP        ; Point to exponent
3891   18C8 7E                  LD      A,(HL)          ; Get exponent
3892   18C9 01 35 80            LD      BC,8035H        ; BCDE = SQR(1/2)
3893   18CC 11 F3 04            LD      DE,04F3H
3894   18CF 90                  SUB     B               ; Scale value to be < 1
3895   18D0 F5                  PUSH    AF              ; Save scale factor
3896   18D1 70                  LD      (HL),B          ; Save new exponent
3897   18D2 D5                  PUSH    DE              ; Save SQR(1/2)
3898   18D3 C5                  PUSH    BC
3899   18D4 CD C4 17            CALL    FPADD           ; Add SQR(1/2) to value
3900   18D7 C1                  POP     BC              ; Restore SQR(1/2)
3901   18D8 D1                  POP     DE
3902   18D9 04                  INC     B               ; Make it SQR(2)
3903   18DA CD 60 19            CALL    DVBCDE          ; Divide by SQR(2)
3904   18DD 21 AD 18            LD      HL,UNITY        ; Point to 1.
3905   18E0 CD BB 17            CALL    SUBPHL          ; Subtract FPREG from 1
3906   18E3 21 B1 18            LD      HL,LOGTAB       ; Coefficient table
3907   18E6 CD 52 1D            CALL    SUMSER          ; Evaluate sum of series
3908   18E9 01 80 80            LD      BC,8080H        ; BCDE = -0.5
3909   18EC 11 00 00            LD      DE,0000H
3910   18EF CD C4 17            CALL    FPADD           ; Subtract 0.5 from FPREG
3911   18F2 F1                  POP     AF              ; Restore scale factor
3912   18F3 CD 85 1B            CALL    RSCALE          ; Re-scale number
3913   18F6 01 31 80    MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3914   18F9 11 18 72            LD      DE,7218H
3915   18FC 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3916   18FD             
3917   18FD C1          MULT:   POP     BC              ; Get number from stack
3918   18FE D1                  POP     DE
3919   18FF CD 0A 1A    FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3920   1902 C8                  RET     Z               ; Return zero if zero
3921   1903 2E 00               LD      L,0             ; Flag add exponents
3922   1905 CD C8 19            CALL    ADDEXP          ; Add exponents
3923   1908 79                  LD      A,C             ; Get MSB of multiplier
3924   1909 32 A6 31            LD      (MULVAL),A      ; Save MSB of multiplier
3925   190C EB                  EX      DE,HL
3926   190D 22 A7 31            LD      (MULVAL+1),HL   ; Save rest of multiplier
3927   1910 01 00 00            LD      BC,0            ; Partial product (BCDE) = zero
3928   1913 50                  LD      D,B
3929   1914 58                  LD      E,B
3930   1915 21 15 18            LD      HL,BNORM        ; Address of normalise
3931   1918 E5                  PUSH    HL              ; Save for return
3932   1919 21 21 19            LD      HL,MULT8        ; Address of 8 bit multiply
3933   191C E5                  PUSH    HL              ; Save for NMSB,MSB
3934   191D E5                  PUSH    HL              ; 
3935   191E 21 94 31            LD      HL,FPREG        ; Point to number
3936   1921 7E          MULT8:  LD      A,(HL)          ; Get LSB of number
3937   1922 23                  INC     HL              ; Point to NMSB
3938   1923 B7                  OR      A               ; Test LSB
3939   1924 CA 4D 19            JP      Z,BYTSFT        ; Zero - shift to next byte
3940   1927 E5                  PUSH    HL              ; Save address of number
3941   1928 2E 08               LD      L,8             ; 8 bits to multiply by
3942   192A 1F          MUL8LP: RRA                     ; Shift LSB right
3943   192B 67                  LD      H,A             ; Save LSB
3944   192C 79                  LD      A,C             ; Get MSB
3945   192D D2 3B 19            JP      NC,NOMADD       ; Bit was zero - Don't add
3946   1930 E5                  PUSH    HL              ; Save LSB and count
3947   1931 2A A7 31            LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3948   1934 19                  ADD     HL,DE           ; Add NMSB and LSB
3949   1935 EB                  EX      DE,HL           ; Leave sum in DE
3950   1936 E1                  POP     HL              ; Restore MSB and count
3951   1937 3A A6 31            LD      A,(MULVAL)      ; Get MSB of multiplier
3952   193A 89                  ADC     A,C             ; Add MSB
3953   193B 1F          NOMADD: RRA                     ; Shift MSB right
3954   193C 4F                  LD      C,A             ; Re-save MSB
3955   193D 7A                  LD      A,D             ; Get NMSB
3956   193E 1F                  RRA                     ; Shift NMSB right
3957   193F 57                  LD      D,A             ; Re-save NMSB
3958   1940 7B                  LD      A,E             ; Get LSB
3959   1941 1F                  RRA                     ; Shift LSB right
3960   1942 5F                  LD      E,A             ; Re-save LSB
3961   1943 78                  LD      A,B             ; Get VLSB
3962   1944 1F                  RRA                     ; Shift VLSB right
3963   1945 47                  LD      B,A             ; Re-save VLSB
3964   1946 2D                  DEC     L               ; Count bits multiplied
3965   1947 7C                  LD      A,H             ; Get LSB of multiplier
3966   1948 C2 2A 19            JP      NZ,MUL8LP       ; More - Do it
3967   194B E1          POPHRT: POP     HL              ; Restore address of number
3968   194C C9                  RET
3969   194D             
3970   194D 43          BYTSFT: LD      B,E             ; Shift partial product left
3971   194E 5A                  LD      E,D
3972   194F 51                  LD      D,C
3973   1950 4F                  LD      C,A
3974   1951 C9                  RET
3975   1952             
3976   1952 CD 3B 1A    DIV10:  CALL    STAKFP          ; Save FPREG on stack
3977   1955 01 20 84            LD      BC,8420H        ; BCDE = 10.
3978   1958 11 00 00            LD      DE,0000H
3979   195B CD 4B 1A            CALL    FPBCDE          ; Move 10 to FPREG
3980   195E             
3981   195E C1          DIV:    POP     BC              ; Get number from stack
3982   195F D1                  POP     DE
3983   1960 CD 0A 1A    DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
3984   1963 CA 66 07            JP      Z,DZERR         ; Error if division by zero
3985   1966 2E FF               LD      L,-1            ; Flag subtract exponents
3986   1968 CD C8 19            CALL    ADDEXP          ; Subtract exponents
3987   196B 34                  INC     (HL)            ; Add 2 to exponent to adjust
3988   196C 34                  INC     (HL)
3989   196D 2B                  DEC     HL              ; Point to MSB
3990   196E 7E                  LD      A,(HL)          ; Get MSB of dividend
3991   196F 32 C2 30            LD      (DIV3),A        ; Save for subtraction
3992   1972 2B                  DEC     HL
3993   1973 7E                  LD      A,(HL)          ; Get NMSB of dividend
3994   1974 32 BE 30            LD      (DIV2),A        ; Save for subtraction
3995   1977 2B                  DEC     HL
3996   1978 7E                  LD      A,(HL)          ; Get MSB of dividend
3997   1979 32 BA 30            LD      (DIV1),A        ; Save for subtraction
3998   197C 41                  LD      B,C             ; Get MSB
3999   197D EB                  EX      DE,HL           ; NMSB,LSB to HL
4000   197E AF                  XOR     A
4001   197F 4F                  LD      C,A             ; Clear MSB of quotient
4002   1980 57                  LD      D,A             ; Clear NMSB of quotient
4003   1981 5F                  LD      E,A             ; Clear LSB of quotient
4004   1982 32 C5 30            LD      (DIV4),A        ; Clear overflow count
4005   1985 E5          DIVLP:  PUSH    HL              ; Save divisor
4006   1986 C5                  PUSH    BC
4007   1987 7D                  LD      A,L             ; Get LSB of number
4008   1988 CD B9 30            CALL    DIVSUP          ; Subt' divisor from dividend
4009   198B DE 00               SBC     A,0             ; Count for overflows
4010   198D 3F                  CCF
4011   198E D2 98 19            JP      NC,RESDIV       ; Restore divisor if borrow
4012   1991 32 C5 30            LD      (DIV4),A        ; Re-save overflow count
4013   1994 F1                  POP     AF              ; Scrap divisor
4014   1995 F1                  POP     AF
4015   1996 37                  SCF                     ; Set carry to
4016   1997 D2                  .BYTE      0D2H            ; Skip "POP BC" and "POP HL"
4017   1998             
4018   1998 C1          RESDIV: POP     BC              ; Restore divisor
4019   1999 E1                  POP     HL
4020   199A 79                  LD      A,C             ; Get MSB of quotient
4021   199B 3C                  INC     A
4022   199C 3D                  DEC     A
4023   199D 1F                  RRA                     ; Bit 0 to bit 7
4024   199E FA 4B 18            JP      M,RONDB         ; Done - Normalise result
4025   19A1 17                  RLA                     ; Restore carry
4026   19A2 7B                  LD      A,E             ; Get LSB of quotient
4027   19A3 17                  RLA                     ; Double it
4028   19A4 5F                  LD      E,A             ; Put it back
4029   19A5 7A                  LD      A,D             ; Get NMSB of quotient
4030   19A6 17                  RLA                     ; Double it
4031   19A7 57                  LD      D,A             ; Put it back
4032   19A8 79                  LD      A,C             ; Get MSB of quotient
4033   19A9 17                  RLA                     ; Double it
4034   19AA 4F                  LD      C,A             ; Put it back
4035   19AB 29                  ADD     HL,HL           ; Double NMSB,LSB of divisor
4036   19AC 78                  LD      A,B             ; Get MSB of divisor
4037   19AD 17                  RLA                     ; Double it
4038   19AE 47                  LD      B,A             ; Put it back
4039   19AF 3A C5 30            LD      A,(DIV4)        ; Get VLSB of quotient
4040   19B2 17                  RLA                     ; Double it
4041   19B3 32 C5 30            LD      (DIV4),A        ; Put it back
4042   19B6 79                  LD      A,C             ; Get MSB of quotient
4043   19B7 B2                  OR      D               ; Merge NMSB
4044   19B8 B3                  OR      E               ; Merge LSB
4045   19B9 C2 85 19            JP      NZ,DIVLP        ; Not done - Keep dividing
4046   19BC E5                  PUSH    HL              ; Save divisor
4047   19BD 21 97 31            LD      HL,FPEXP        ; Point to exponent
4048   19C0 35                  DEC     (HL)            ; Divide by 2
4049   19C1 E1                  POP     HL              ; Restore divisor
4050   19C2 C2 85 19            JP      NZ,DIVLP        ; Ok - Keep going
4051   19C5 C3 72 07            JP      OVERR           ; Overflow error
4052   19C8             
4053   19C8 78          ADDEXP: LD      A,B             ; Get exponent of dividend
4054   19C9 B7                  OR      A               ; Test it
4055   19CA CA EC 19            JP      Z,OVTST3        ; Zero - Result zero
4056   19CD 7D                  LD      A,L             ; Get add/subtract flag
4057   19CE 21 97 31            LD      HL,FPEXP        ; Point to exponent
4058   19D1 AE                  XOR     (HL)            ; Add or subtract it
4059   19D2 80                  ADD     A,B             ; Add the other exponent
4060   19D3 47                  LD      B,A             ; Save new exponent
4061   19D4 1F                  RRA                     ; Test exponent for overflow
4062   19D5 A8                  XOR     B
4063   19D6 78                  LD      A,B             ; Get exponent
4064   19D7 F2 EB 19            JP      P,OVTST2        ; Positive - Test for overflow
4065   19DA C6 80               ADD     A,80H           ; Add excess 128
4066   19DC 77                  LD      (HL),A          ; Save new exponent
4067   19DD CA 4B 19            JP      Z,POPHRT        ; Zero - Result zero
4068   19E0 CD 70 1A            CALL    SIGNS           ; Set MSBs and sign of result
4069   19E3 77                  LD      (HL),A          ; Save new exponent
4070   19E4 2B                  DEC     HL              ; Point to MSB
4071   19E5 C9                  RET
4072   19E6             
4073   19E6 CD 0A 1A    OVTST1: CALL    TSTSGN          ; Test sign of FPREG
4074   19E9 2F                  CPL                     ; Invert sign
4075   19EA E1                  POP     HL              ; Clean up stack
4076   19EB B7          OVTST2: OR      A               ; Test if new exponent zero
4077   19EC E1          OVTST3: POP     HL              ; Clear off return address
4078   19ED F2 2A 18            JP      P,RESZER        ; Result zero
4079   19F0 C3 72 07            JP      OVERR           ; Overflow error
4080   19F3             
4081   19F3 CD 56 1A    MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
4082   19F6 78                  LD      A,B             ; Get exponent
4083   19F7 B7                  OR      A               ; Is it zero?
4084   19F8 C8                  RET     Z               ; Yes - Result is zero
4085   19F9 C6 02               ADD     A,2             ; Multiply by 4
4086   19FB DA 72 07            JP      C,OVERR         ; Overflow - ?OV Error
4087   19FE 47                  LD      B,A             ; Re-save exponent
4088   19FF CD C4 17            CALL    FPADD           ; Add BCDE to FPREG (Times 5)
4089   1A02 21 97 31            LD      HL,FPEXP        ; Point to exponent
4090   1A05 34                  INC     (HL)            ; Double number (Times 10)
4091   1A06 C0                  RET     NZ              ; Ok - Return
4092   1A07 C3 72 07            JP      OVERR           ; Overflow error
4093   1A0A             
4094   1A0A 3A 97 31    TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
4095   1A0D B7                  OR      A
4096   1A0E C8                  RET     Z               ; RETurn if number is zero
4097   1A0F 3A 96 31            LD      A,(FPREG+2)     ; Get MSB of FPREG
4098   1A12 FE                  .BYTE      0FEH            ; Test sign
4099   1A13 2F          RETREL: CPL                     ; Invert sign
4100   1A14 17                  RLA                     ; Sign bit to carry
4101   1A15 9F          FLGDIF: SBC     A,A             ; Carry to all bits of A
4102   1A16 C0                  RET     NZ              ; Return -1 if negative
4103   1A17 3C                  INC     A               ; Bump to +1
4104   1A18 C9                  RET                     ; Positive - Return +1
4105   1A19             
4106   1A19 CD 0A 1A    SGN:    CALL    TSTSGN          ; Test sign of FPREG
4107   1A1C 06 88       FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
4108   1A1E 11 00 00            LD      DE,0            ; Zero NMSB and LSB
4109   1A21 21 97 31    RETINT: LD      HL,FPEXP        ; Point to exponent
4110   1A24 4F                  LD      C,A             ; CDE = MSB,NMSB and LSB
4111   1A25 70                  LD      (HL),B          ; Save exponent
4112   1A26 06 00               LD      B,0             ; CDE = integer to normalise
4113   1A28 23                  INC     HL              ; Point to sign of result
4114   1A29 36 80               LD      (HL),80H        ; Set sign of result
4115   1A2B 17                  RLA                     ; Carry = sign of integer
4116   1A2C C3 12 18            JP      CONPOS          ; Set sign of result
4117   1A2F             
4118   1A2F CD 0A 1A    ABS:    CALL    TSTSGN          ; Test sign of FPREG
4119   1A32 F0                  RET     P               ; Return if positive
4120   1A33 21 96 31    INVSGN: LD      HL,FPREG+2      ; Point to MSB
4121   1A36 7E                  LD      A,(HL)          ; Get sign of mantissa
4122   1A37 EE 80               XOR     80H             ; Invert sign of mantissa
4123   1A39 77                  LD      (HL),A          ; Re-save sign of mantissa
4124   1A3A C9                  RET
4125   1A3B             
4126   1A3B EB          STAKFP: EX      DE,HL           ; Save code string address
4127   1A3C 2A 94 31            LD      HL,(FPREG)      ; LSB,NLSB of FPREG
4128   1A3F E3                  EX      (SP),HL         ; Stack them,get return
4129   1A40 E5                  PUSH    HL              ; Re-save return
4130   1A41 2A 96 31            LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
4131   1A44 E3                  EX      (SP),HL         ; Stack them,get return
4132   1A45 E5                  PUSH    HL              ; Re-save return
4133   1A46 EB                  EX      DE,HL           ; Restore code string address
4134   1A47 C9                  RET
4135   1A48             
4136   1A48 CD 59 1A    PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
4137   1A4B EB          FPBCDE: EX      DE,HL           ; Save code string address
4138   1A4C 22 94 31            LD      (FPREG),HL      ; Save LSB,NLSB of number
4139   1A4F 60                  LD      H,B             ; Exponent of number
4140   1A50 69                  LD      L,C             ; MSB of number
4141   1A51 22 96 31            LD      (FPREG+2),HL    ; Save MSB and exponent
4142   1A54 EB                  EX      DE,HL           ; Restore code string address
4143   1A55 C9                  RET
4144   1A56             
4145   1A56 21 94 31    BCDEFP: LD      HL,FPREG        ; Point to FPREG
4146   1A59 5E          LOADFP: LD      E,(HL)          ; Get LSB of number
4147   1A5A 23                  INC     HL
4148   1A5B 56                  LD      D,(HL)          ; Get NMSB of number
4149   1A5C 23                  INC     HL
4150   1A5D 4E                  LD      C,(HL)          ; Get MSB of number
4151   1A5E 23                  INC     HL
4152   1A5F 46                  LD      B,(HL)          ; Get exponent of number
4153   1A60 23          INCHL:  INC     HL              ; Used for conditional "INC HL"
4154   1A61 C9                  RET
4155   1A62             
4156   1A62 11 94 31    FPTHL:  LD      DE,FPREG        ; Point to FPREG
4157   1A65 06 04       DETHL4: LD      B,4             ; 4 bytes to move
4158   1A67 1A          DETHLB: LD      A,(DE)          ; Get source
4159   1A68 77                  LD      (HL),A          ; Save destination
4160   1A69 13                  INC     DE              ; Next source
4161   1A6A 23                  INC     HL              ; Next destination
4162   1A6B 05                  DEC     B               ; Count bytes
4163   1A6C C2 67 1A            JP      NZ,DETHLB       ; Loop if more
4164   1A6F C9                  RET
4165   1A70             
4166   1A70 21 96 31    SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
4167   1A73 7E                  LD      A,(HL)          ; Get MSB
4168   1A74 07                  RLCA                    ; Old sign to carry
4169   1A75 37                  SCF                     ; Set MSBit
4170   1A76 1F                  RRA                     ; Set MSBit of MSB
4171   1A77 77                  LD      (HL),A          ; Save new MSB
4172   1A78 3F                  CCF                     ; Complement sign
4173   1A79 1F                  RRA                     ; Old sign to carry
4174   1A7A 23                  INC     HL
4175   1A7B 23                  INC     HL
4176   1A7C 77                  LD      (HL),A          ; Set sign of result
4177   1A7D 79                  LD      A,C             ; Get MSB
4178   1A7E 07                  RLCA                    ; Old sign to carry
4179   1A7F 37                  SCF                     ; Set MSBit
4180   1A80 1F                  RRA                     ; Set MSBit of MSB
4181   1A81 4F                  LD      C,A             ; Save MSB
4182   1A82 1F                  RRA
4183   1A83 AE                  XOR     (HL)            ; New sign of result
4184   1A84 C9                  RET
4185   1A85             
4186   1A85 78          CMPNUM: LD      A,B             ; Get exponent of number
4187   1A86 B7                  OR      A
4188   1A87 CA 0A 1A            JP      Z,TSTSGN        ; Zero - Test sign of FPREG
4189   1A8A 21 13 1A            LD      HL,RETREL       ; Return relation routine
4190   1A8D E5                  PUSH    HL              ; Save for return
4191   1A8E CD 0A 1A            CALL    TSTSGN          ; Test sign of FPREG
4192   1A91 79                  LD      A,C             ; Get MSB of number
4193   1A92 C8                  RET     Z               ; FPREG zero - Number's MSB
4194   1A93 21 96 31            LD      HL,FPREG+2      ; MSB of FPREG
4195   1A96 AE                  XOR     (HL)            ; Combine signs
4196   1A97 79                  LD      A,C             ; Get MSB of number
4197   1A98 F8                  RET     M               ; Exit if signs different
4198   1A99 CD 9F 1A            CALL    CMPFP           ; Compare FP numbers
4199   1A9C 1F                  RRA                     ; Get carry to sign
4200   1A9D A9                  XOR     C               ; Combine with MSB of number
4201   1A9E C9                  RET
4202   1A9F             
4203   1A9F 23          CMPFP:  INC     HL              ; Point to exponent
4204   1AA0 78                  LD      A,B             ; Get exponent
4205   1AA1 BE                  CP      (HL)            ; Compare exponents
4206   1AA2 C0                  RET     NZ              ; Different
4207   1AA3 2B                  DEC     HL              ; Point to MBS
4208   1AA4 79                  LD      A,C             ; Get MSB
4209   1AA5 BE                  CP      (HL)            ; Compare MSBs
4210   1AA6 C0                  RET     NZ              ; Different
4211   1AA7 2B                  DEC     HL              ; Point to NMSB
4212   1AA8 7A                  LD      A,D             ; Get NMSB
4213   1AA9 BE                  CP      (HL)            ; Compare NMSBs
4214   1AAA C0                  RET     NZ              ; Different
4215   1AAB 2B                  DEC     HL              ; Point to LSB
4216   1AAC 7B                  LD      A,E             ; Get LSB
4217   1AAD 96                  SUB     (HL)            ; Compare LSBs
4218   1AAE C0                  RET     NZ              ; Different
4219   1AAF E1                  POP     HL              ; Drop RETurn
4220   1AB0 E1                  POP     HL              ; Drop another RETurn
4221   1AB1 C9                  RET
4222   1AB2             
4223   1AB2 47          FPINT:  LD      B,A             ; <- Move
4224   1AB3 4F                  LD      C,A             ; <- exponent
4225   1AB4 57                  LD      D,A             ; <- to all
4226   1AB5 5F                  LD      E,A             ; <- bits
4227   1AB6 B7                  OR      A               ; Test exponent
4228   1AB7 C8                  RET     Z               ; Zero - Return zero
4229   1AB8 E5                  PUSH    HL              ; Save pointer to number
4230   1AB9 CD 56 1A            CALL    BCDEFP          ; Move FPREG to BCDE
4231   1ABC CD 70 1A            CALL    SIGNS           ; Set MSBs & sign of result
4232   1ABF AE                  XOR     (HL)            ; Combine with sign of FPREG
4233   1AC0 67                  LD      H,A             ; Save combined signs
4234   1AC1 FC D6 1A            CALL    M,DCBCDE        ; Negative - Decrement BCDE
4235   1AC4 3E 98               LD      A,80H+24        ; 24 bits
4236   1AC6 90                  SUB     B               ; Bits to shift
4237   1AC7 CD 89 18            CALL    SCALE           ; Shift BCDE
4238   1ACA 7C                  LD      A,H             ; Get combined sign
4239   1ACB 17                  RLA                     ; Sign to carry
4240   1ACC DC 5C 18            CALL    C,FPROND        ; Negative - Round number up
4241   1ACF 06 00               LD      B,0             ; Zero exponent
4242   1AD1 DC 75 18            CALL    C,COMPL         ; If negative make positive
4243   1AD4 E1                  POP     HL              ; Restore pointer to number
4244   1AD5 C9                  RET
4245   1AD6             
4246   1AD6 1B          DCBCDE: DEC     DE              ; Decrement BCDE
4247   1AD7 7A                  LD      A,D             ; Test LSBs
4248   1AD8 A3                  AND     E
4249   1AD9 3C                  INC     A
4250   1ADA C0                  RET     NZ              ; Exit if LSBs not FFFF
4251   1ADB 0B                  DEC     BC              ; Decrement MSBs
4252   1ADC C9                  RET
4253   1ADD             
4254   1ADD 21 97 31    INT:    LD      HL,FPEXP        ; Point to exponent
4255   1AE0 7E                  LD      A,(HL)          ; Get exponent
4256   1AE1 FE 98               CP      80H+24          ; Integer accuracy only?
4257   1AE3 3A 94 31            LD      A,(FPREG)       ; Get LSB
4258   1AE6 D0                  RET     NC              ; Yes - Already integer
4259   1AE7 7E                  LD      A,(HL)          ; Get exponent
4260   1AE8 CD B2 1A            CALL    FPINT           ; F.P to integer
4261   1AEB 36 98               LD      (HL),80H+24     ; Save 24 bit integer
4262   1AED 7B                  LD      A,E             ; Get LSB of number
4263   1AEE F5                  PUSH    AF              ; Save LSB
4264   1AEF 79                  LD      A,C             ; Get MSB of number
4265   1AF0 17                  RLA                     ; Sign to carry
4266   1AF1 CD 12 18            CALL    CONPOS          ; Set sign of result
4267   1AF4 F1                  POP     AF              ; Restore LSB of number
4268   1AF5 C9                  RET
4269   1AF6             
4270   1AF6 21 00 00    MLDEBC: LD      HL,0            ; Clear partial product
4271   1AF9 78                  LD      A,B             ; Test multiplier
4272   1AFA B1                  OR      C
4273   1AFB C8                  RET     Z               ; Return zero if zero
4274   1AFC 3E 10               LD      A,16            ; 16 bits
4275   1AFE 29          MLDBLP: ADD     HL,HL           ; Shift P.P left
4276   1AFF DA 36 13            JP      C,BSERR         ; ?BS Error if overflow
4277   1B02 EB                  EX      DE,HL
4278   1B03 29                  ADD     HL,HL           ; Shift multiplier left
4279   1B04 EB                  EX      DE,HL
4280   1B05 D2 0C 1B            JP      NC,NOMLAD       ; Bit was zero - No add
4281   1B08 09                  ADD     HL,BC           ; Add multiplicand
4282   1B09 DA 36 13            JP      C,BSERR         ; ?BS Error if overflow
4283   1B0C 3D          NOMLAD: DEC     A               ; Count bits
4284   1B0D C2 FE 1A            JP      NZ,MLDBLP       ; More
4285   1B10 C9                  RET
4286   1B11             
4287   1B11 FE 2D       ASCTFP: CP      '-'             ; Negative?
4288   1B13 F5                  PUSH    AF              ; Save it and flags
4289   1B14 CA 1D 1B            JP      Z,CNVNUM        ; Yes - Convert number
4290   1B17 FE 2B               CP      '+'             ; Positive?
4291   1B19 CA 1D 1B            JP      Z,CNVNUM        ; Yes - Convert number
4292   1B1C 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
4293   1B1D CD 2A 18    CNVNUM: CALL    RESZER          ; Set result to zero
4294   1B20 47                  LD      B,A             ; Digits after point counter
4295   1B21 57                  LD      D,A             ; Sign of exponent
4296   1B22 5F                  LD      E,A             ; Exponent of ten
4297   1B23 2F                  CPL
4298   1B24 4F                  LD      C,A             ; Before or after point flag
4299   1B25 CD BB 0B    MANLP:  CALL    GETCHR          ; Get next character
4300   1B28 DA 6E 1B            JP      C,ADDIG         ; Digit - Add to number
4301   1B2B FE 2E               CP      '.'
4302   1B2D CA 49 1B            JP      Z,DPOINT        ; '.' - Flag point
4303   1B30 FE 45               CP      'E'
4304   1B32 C2 4D 1B            JP      NZ,CONEXP       ; Not 'E' - Scale number
4305   1B35 CD BB 0B            CALL    GETCHR          ; Get next character
4306   1B38 CD 61 11            CALL    SGNEXP          ; Get sign of exponent
4307   1B3B CD BB 0B    EXPLP:  CALL    GETCHR          ; Get next character
4308   1B3E DA 90 1B            JP      C,EDIGIT        ; Digit - Add to exponent
4309   1B41 14                  INC     D               ; Is sign negative?
4310   1B42 C2 4D 1B            JP      NZ,CONEXP       ; No - Scale number
4311   1B45 AF                  XOR     A
4312   1B46 93                  SUB     E               ; Negate exponent
4313   1B47 5F                  LD      E,A             ; And re-save it
4314   1B48 0C                  INC     C               ; Flag end of number
4315   1B49 0C          DPOINT: INC     C               ; Flag point passed
4316   1B4A CA 25 1B            JP      Z,MANLP         ; Zero - Get another digit
4317   1B4D E5          CONEXP: PUSH    HL              ; Save code string address
4318   1B4E 7B                  LD      A,E             ; Get exponent
4319   1B4F 90                  SUB     B               ; Subtract digits after point
4320   1B50 F4 66 1B    SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
4321   1B53 F2 5C 1B            JP      P,ENDCON        ; Positive - All done
4322   1B56 F5                  PUSH    AF              ; Save number of times to /10
4323   1B57 CD 52 19            CALL    DIV10           ; Divide by 10
4324   1B5A F1                  POP     AF              ; Restore count
4325   1B5B 3C                  INC     A               ; Count divides
4326   1B5C             
4327   1B5C C2 50 1B    ENDCON: JP      NZ,SCALMI       ; More to do
4328   1B5F D1                  POP     DE              ; Restore code string address
4329   1B60 F1                  POP     AF              ; Restore sign of number
4330   1B61 CC 33 1A            CALL    Z,INVSGN        ; Negative - Negate number
4331   1B64 EB                  EX      DE,HL           ; Code string address to HL
4332   1B65 C9                  RET
4333   1B66             
4334   1B66 C8          SCALPL: RET     Z               ; Exit if no scaling needed
4335   1B67 F5          MULTEN: PUSH    AF              ; Save count
4336   1B68 CD F3 19            CALL    MLSP10          ; Multiply number by 10
4337   1B6B F1                  POP     AF              ; Restore count
4338   1B6C 3D                  DEC     A               ; Count multiplies
4339   1B6D C9                  RET
4340   1B6E             
4341   1B6E D5          ADDIG:  PUSH    DE              ; Save sign of exponent
4342   1B6F 57                  LD      D,A             ; Save digit
4343   1B70 78                  LD      A,B             ; Get digits after point
4344   1B71 89                  ADC     A,C             ; Add one if after point
4345   1B72 47                  LD      B,A             ; Re-save counter
4346   1B73 C5                  PUSH    BC              ; Save point flags
4347   1B74 E5                  PUSH    HL              ; Save code string address
4348   1B75 D5                  PUSH    DE              ; Save digit
4349   1B76 CD F3 19            CALL    MLSP10          ; Multiply number by 10
4350   1B79 F1                  POP     AF              ; Restore digit
4351   1B7A D6 30               SUB     '0'             ; Make it absolute
4352   1B7C CD 85 1B            CALL    RSCALE          ; Re-scale number
4353   1B7F E1                  POP     HL              ; Restore code string address
4354   1B80 C1                  POP     BC              ; Restore point flags
4355   1B81 D1                  POP     DE              ; Restore sign of exponent
4356   1B82 C3 25 1B            JP      MANLP           ; Get another digit
4357   1B85             
4358   1B85 CD 3B 1A    RSCALE: CALL    STAKFP          ; Put number on stack
4359   1B88 CD 1C 1A            CALL    FLGREL          ; Digit to add to FPREG
4360   1B8B C1          PADD:   POP     BC              ; Restore number
4361   1B8C D1                  POP     DE
4362   1B8D C3 C4 17            JP      FPADD           ; Add BCDE to FPREG and return
4363   1B90             
4364   1B90 7B          EDIGIT: LD      A,E             ; Get digit
4365   1B91 07                  RLCA                    ; Times 2
4366   1B92 07                  RLCA                    ; Times 4
4367   1B93 83                  ADD     A,E             ; Times 5
4368   1B94 07                  RLCA                    ; Times 10
4369   1B95 86                  ADD     A,(HL)          ; Add next digit
4370   1B96 D6 30               SUB     '0'             ; Make it absolute
4371   1B98 5F                  LD      E,A             ; Save new digit
4372   1B99 C3 3B 1B            JP      EXPLP           ; Look for another digit
4373   1B9C             
4374   1B9C E5          LINEIN: PUSH    HL              ; Save code string address
4375   1B9D 21 FB 06            LD      HL,INMSG        ; Output " in "
4376   1BA0 CD 01 15            CALL    PRS             ; Output string at HL
4377   1BA3 E1                  POP     HL              ; Restore code string address
4378   1BA4 EB          PRNTHL: EX      DE,HL           ; Code string address to DE
4379   1BA5 AF                  XOR     A
4380   1BA6 06 98               LD      B,80H+24        ; 24 bits
4381   1BA8 CD 21 1A            CALL    RETINT          ; Return the integer
4382   1BAB 21 00 15            LD      HL,PRNUMS       ; Print number string
4383   1BAE E5                  PUSH    HL              ; Save for return
4384   1BAF 21 99 31    NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
4385   1BB2 E5                  PUSH    HL              ; Save for return
4386   1BB3 CD 0A 1A            CALL    TSTSGN          ; Test sign of FPREG
4387   1BB6 36 20               LD      (HL),' '        ; Space at start
4388   1BB8 F2 BD 1B            JP      P,SPCFST        ; Positive - Space to start
4389   1BBB 36 2D               LD      (HL),'-'        ; '-' sign at start
4390   1BBD 23          SPCFST: INC     HL              ; First byte of number
4391   1BBE 36 30               LD      (HL),'0'        ; '0' if zero
4392   1BC0 CA 73 1C            JP      Z,JSTZER        ; Return '0' if zero
4393   1BC3 E5                  PUSH    HL              ; Save buffer address
4394   1BC4 FC 33 1A            CALL    M,INVSGN        ; Negate FPREG if negative
4395   1BC7 AF                  XOR     A               ; Zero A
4396   1BC8 F5                  PUSH    AF              ; Save it
4397   1BC9 CD 79 1C            CALL    RNGTST          ; Test number is in range
4398   1BCC 01 43 91    SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
4399   1BCF 11 F8 4F            LD      DE,4FF8H
4400   1BD2 CD 85 1A            CALL    CMPNUM          ; Compare numbers
4401   1BD5 B7                  OR      A
4402   1BD6 E2 EA 1B            JP      PO,INRNG        ; > 99999.9 - Sort it out
4403   1BD9 F1                  POP     AF              ; Restore count
4404   1BDA CD 67 1B            CALL    MULTEN          ; Multiply by ten
4405   1BDD F5                  PUSH    AF              ; Re-save count
4406   1BDE C3 CC 1B            JP      SIXDIG          ; Test it again
4407   1BE1             
4408   1BE1 CD 52 19    GTSIXD: CALL    DIV10           ; Divide by 10
4409   1BE4 F1                  POP     AF              ; Get count
4410   1BE5 3C                  INC     A               ; Count divides
4411   1BE6 F5                  PUSH    AF              ; Re-save count
4412   1BE7 CD 79 1C            CALL    RNGTST          ; Test number is in range
4413   1BEA CD B2 17    INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
4414   1BED 3C                  INC     A
4415   1BEE CD B2 1A            CALL    FPINT           ; F.P to integer
4416   1BF1 CD 4B 1A            CALL    FPBCDE          ; Move BCDE to FPREG
4417   1BF4 01 06 03            LD      BC,0306H        ; 1E+06 to 1E-03 range
4418   1BF7 F1                  POP     AF              ; Restore count
4419   1BF8 81                  ADD     A,C             ; 6 digits before point
4420   1BF9 3C                  INC     A               ; Add one
4421   1BFA FA 06 1C            JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
4422   1BFD FE 08               CP      6+1+1           ; More than 999999 ?
4423   1BFF D2 06 1C            JP      NC,MAKNUM       ; Yes - Do it in 'E' form
4424   1C02 3C                  INC     A               ; Adjust for exponent
4425   1C03 47                  LD      B,A             ; Exponent of number
4426   1C04 3E 02               LD      A,2             ; Make it zero after
4427   1C06             
4428   1C06 3D          MAKNUM: DEC     A               ; Adjust for digits to do
4429   1C07 3D                  DEC     A
4430   1C08 E1                  POP     HL              ; Restore buffer address
4431   1C09 F5                  PUSH    AF              ; Save count
4432   1C0A 11 8C 1C            LD      DE,POWERS       ; Powers of ten
4433   1C0D 05                  DEC     B               ; Count digits before point
4434   1C0E C2 17 1C            JP      NZ,DIGTXT       ; Not zero - Do number
4435   1C11 36 2E               LD      (HL),'.'        ; Save point
4436   1C13 23                  INC     HL              ; Move on
4437   1C14 36 30               LD      (HL),'0'        ; Save zero
4438   1C16 23                  INC     HL              ; Move on
4439   1C17 05          DIGTXT: DEC     B               ; Count digits before point
4440   1C18 36 2E               LD      (HL),'.'        ; Save point in case
4441   1C1A CC 60 1A            CALL    Z,INCHL         ; Last digit - move on
4442   1C1D C5                  PUSH    BC              ; Save digits before point
4443   1C1E E5                  PUSH    HL              ; Save buffer address
4444   1C1F D5                  PUSH    DE              ; Save powers of ten
4445   1C20 CD 56 1A            CALL    BCDEFP          ; Move FPREG to BCDE
4446   1C23 E1                  POP     HL              ; Powers of ten table
4447   1C24 06 2F               LD      B, '0'-1        ; ASCII '0' - 1
4448   1C26 04          TRYAGN: INC     B               ; Count subtractions
4449   1C27 7B                  LD      A,E             ; Get LSB
4450   1C28 96                  SUB     (HL)            ; Subtract LSB
4451   1C29 5F                  LD      E,A             ; Save LSB
4452   1C2A 23                  INC     HL
4453   1C2B 7A                  LD      A,D             ; Get NMSB
4454   1C2C 9E                  SBC     A,(HL)          ; Subtract NMSB
4455   1C2D 57                  LD      D,A             ; Save NMSB
4456   1C2E 23                  INC     HL
4457   1C2F 79                  LD      A,C             ; Get MSB
4458   1C30 9E                  SBC     A,(HL)          ; Subtract MSB
4459   1C31 4F                  LD      C,A             ; Save MSB
4460   1C32 2B                  DEC     HL              ; Point back to start
4461   1C33 2B                  DEC     HL
4462   1C34 D2 26 1C            JP      NC,TRYAGN       ; No overflow - Try again
4463   1C37 CD 69 18            CALL    PLUCDE          ; Restore number
4464   1C3A 23                  INC     HL              ; Start of next number
4465   1C3B CD 4B 1A            CALL    FPBCDE          ; Move BCDE to FPREG
4466   1C3E EB                  EX      DE,HL           ; Save point in table
4467   1C3F E1                  POP     HL              ; Restore buffer address
4468   1C40 70                  LD      (HL),B          ; Save digit in buffer
4469   1C41 23                  INC     HL              ; And move on
4470   1C42 C1                  POP     BC              ; Restore digit count
4471   1C43 0D                  DEC     C               ; Count digits
4472   1C44 C2 17 1C            JP      NZ,DIGTXT       ; More - Do them
4473   1C47 05                  DEC     B               ; Any decimal part?
4474   1C48 CA 57 1C            JP      Z,DOEBIT        ; No - Do 'E' bit
4475   1C4B 2B          SUPTLZ: DEC     HL              ; Move back through buffer
4476   1C4C 7E                  LD      A,(HL)          ; Get character
4477   1C4D FE 30               CP      '0'             ; '0' character?
4478   1C4F CA 4B 1C            JP      Z,SUPTLZ        ; Yes - Look back for more
4479   1C52 FE 2E               CP      '.'             ; A decimal point?
4480   1C54 C4 60 1A            CALL    NZ,INCHL        ; Move back over digit
4481   1C57             
4482   1C57 F1          DOEBIT: POP     AF              ; Get 'E' flag
4483   1C58 CA 76 1C            JP      Z,NOENED        ; No 'E' needed - End buffer
4484   1C5B 36 45               LD      (HL),'E'        ; Put 'E' in buffer
4485   1C5D 23                  INC     HL              ; And move on
4486   1C5E 36 2B               LD      (HL),'+'        ; Put '+' in buffer
4487   1C60 F2 67 1C            JP      P,OUTEXP        ; Positive - Output exponent
4488   1C63 36 2D               LD      (HL),'-'        ; Put '-' in buffer
4489   1C65 2F                  CPL                     ; Negate exponent
4490   1C66 3C                  INC     A
4491   1C67 06 2F       OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
4492   1C69 04          EXPTEN: INC     B               ; Count subtractions
4493   1C6A D6 0A               SUB     10              ; Tens digit
4494   1C6C D2 69 1C            JP      NC,EXPTEN       ; More to do
4495   1C6F C6 3A               ADD     A,'0'+10        ; Restore and make ASCII
4496   1C71 23                  INC     HL              ; Move on
4497   1C72 70                  LD      (HL),B          ; Save MSB of exponent
4498   1C73 23          JSTZER: INC     HL              ;
4499   1C74 77                  LD      (HL),A          ; Save LSB of exponent
4500   1C75 23                  INC     HL
4501   1C76 71          NOENED: LD      (HL),C          ; Mark end of buffer
4502   1C77 E1                  POP     HL              ; Restore code string address
4503   1C78 C9                  RET
4504   1C79             
4505   1C79 01 74 94    RNGTST: LD      BC,9474H        ; BCDE = 999999.
4506   1C7C 11 F7 23            LD      DE,23F7H
4507   1C7F CD 85 1A            CALL    CMPNUM          ; Compare numbers
4508   1C82 B7                  OR      A
4509   1C83 E1                  POP     HL              ; Return address to HL
4510   1C84 E2 E1 1B            JP      PO,GTSIXD       ; Too big - Divide by ten
4511   1C87 E9                  JP      (HL)            ; Otherwise return to caller
4512   1C88             
4513   1C88 00 00 00 80 HALF:   .BYTE      00H,00H,00H,80H ; 0.5
4514   1C8C             
4515   1C8C A0 86 01    POWERS: .BYTE      0A0H,086H,001H  ; 100000
4516   1C8F 10 27 00            .BYTE      010H,027H,000H  ;  10000
4517   1C92 E8 03 00            .BYTE      0E8H,003H,000H  ;   1000
4518   1C95 64 00 00            .BYTE      064H,000H,000H  ;    100
4519   1C98 0A 00 00            .BYTE      00AH,000H,000H  ;     10
4520   1C9B 01 00 00            .BYTE      001H,000H,000H  ;      1
4521   1C9E             
4522   1C9E 21 33 1A    NEGAFT: LD  HL,INVSGN           ; Negate result
4523   1CA1 E3                  EX      (SP),HL         ; To be done after caller
4524   1CA2 E9                  JP      (HL)            ; Return to caller
4525   1CA3             
4526   1CA3 CD 3B 1A    SQR:    CALL    STAKFP          ; Put value on stack
4527   1CA6 21 88 1C            LD      HL,HALF         ; Set power to 1/2
4528   1CA9 CD 48 1A            CALL    PHLTFP          ; Move 1/2 to FPREG
4529   1CAC             
4530   1CAC C1          POWER:  POP     BC              ; Get base
4531   1CAD D1                  POP     DE
4532   1CAE CD 0A 1A            CALL    TSTSGN          ; Test sign of power
4533   1CB1 78                  LD      A,B             ; Get exponent of base
4534   1CB2 CA F1 1C            JP      Z,EXP           ; Make result 1 if zero
4535   1CB5 F2 BC 1C            JP      P,POWER1        ; Positive base - Ok
4536   1CB8 B7                  OR      A               ; Zero to negative power?
4537   1CB9 CA 66 07            JP      Z,DZERR         ; Yes - ?/0 Error
4538   1CBC B7          POWER1: OR      A               ; Base zero?
4539   1CBD CA 2B 18            JP      Z,SAVEXP        ; Yes - Return zero
4540   1CC0 D5                  PUSH    DE              ; Save base
4541   1CC1 C5                  PUSH    BC
4542   1CC2 79                  LD      A,C             ; Get MSB of base
4543   1CC3 F6 7F               OR      01111111B       ; Get sign status
4544   1CC5 CD 56 1A            CALL    BCDEFP          ; Move power to BCDE
4545   1CC8 F2 D9 1C            JP      P,POWER2        ; Positive base - Ok
4546   1CCB D5                  PUSH    DE              ; Save power
4547   1CCC C5                  PUSH    BC
4548   1CCD CD DD 1A            CALL    INT             ; Get integer of power
4549   1CD0 C1                  POP     BC              ; Restore power
4550   1CD1 D1                  POP     DE
4551   1CD2 F5                  PUSH    AF              ; MSB of base
4552   1CD3 CD 85 1A            CALL    CMPNUM          ; Power an integer?
4553   1CD6 E1                  POP     HL              ; Restore MSB of base
4554   1CD7 7C                  LD      A,H             ; but don't affect flags
4555   1CD8 1F                  RRA                     ; Exponent odd or even?
4556   1CD9 E1          POWER2: POP     HL              ; Restore MSB and exponent
4557   1CDA 22 96 31            LD      (FPREG+2),HL    ; Save base in FPREG
4558   1CDD E1                  POP     HL              ; LSBs of base
4559   1CDE 22 94 31            LD      (FPREG),HL      ; Save in FPREG
4560   1CE1 DC 9E 1C            CALL    C,NEGAFT        ; Odd power - Negate result
4561   1CE4 CC 33 1A            CALL    Z,INVSGN        ; Negative base - Negate it
4562   1CE7 D5                  PUSH    DE              ; Save power
4563   1CE8 C5                  PUSH    BC
4564   1CE9 CD BE 18            CALL    LOG             ; Get LOG of base
4565   1CEC C1                  POP     BC              ; Restore power
4566   1CED D1                  POP     DE
4567   1CEE CD FF 18            CALL    FPMULT          ; Multiply LOG by power
4568   1CF1             
4569   1CF1 CD 3B 1A    EXP:    CALL    STAKFP          ; Put value on stack
4570   1CF4 01 38 81            LD      BC,08138H       ; BCDE = 1/Ln(2)
4571   1CF7 11 3B AA            LD      DE,0AA3BH
4572   1CFA CD FF 18            CALL    FPMULT          ; Multiply value by 1/LN(2)
4573   1CFD 3A 97 31            LD      A,(FPEXP)       ; Get exponent
4574   1D00 FE 88               CP      80H+8           ; Is it in range?
4575   1D02 D2 E6 19            JP      NC,OVTST1       ; No - Test for overflow
4576   1D05 CD DD 1A            CALL    INT             ; Get INT of FPREG
4577   1D08 C6 80               ADD     A,80H           ; For excess 128
4578   1D0A C6 02               ADD     A,2             ; Exponent > 126?
4579   1D0C DA E6 19            JP      C,OVTST1        ; Yes - Test for overflow
4580   1D0F F5                  PUSH    AF              ; Save scaling factor
4581   1D10 21 AD 18            LD      HL,UNITY        ; Point to 1.
4582   1D13 CD B5 17            CALL    ADDPHL          ; Add 1 to FPREG
4583   1D16 CD F6 18            CALL    MULLN2          ; Multiply by LN(2)
4584   1D19 F1                  POP     AF              ; Restore scaling factor
4585   1D1A C1                  POP     BC              ; Restore exponent
4586   1D1B D1                  POP     DE
4587   1D1C F5                  PUSH    AF              ; Save scaling factor
4588   1D1D CD C1 17            CALL    SUBCDE          ; Subtract exponent from FPREG
4589   1D20 CD 33 1A            CALL    INVSGN          ; Negate result
4590   1D23 21 31 1D            LD      HL,EXPTAB       ; Coefficient table
4591   1D26 CD 61 1D            CALL    SMSER1          ; Sum the series
4592   1D29 11 00 00            LD      DE,0            ; Zero LSBs
4593   1D2C C1                  POP     BC              ; Scaling factor
4594   1D2D 4A                  LD      C,D             ; Zero MSB
4595   1D2E C3 FF 18            JP      FPMULT          ; Scale result to correct value
4596   1D31             
4597   1D31 08          EXPTAB: .BYTE      8                       ; Table used by EXP
4598   1D32 40 2E 94 74         .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
4599   1D36 70 4F 2E 77         .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
4600   1D3A 6E 02 88 7A         .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
4601   1D3E E6 A0 2A 7C         .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
4602   1D42 50 AA AA 7E         .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
4603   1D46 FF FF 7F 7F         .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
4604   1D4A 00 00 80 81         .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
4605   1D4E 00 00 00 81         .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
4606   1D52             
4607   1D52 CD 3B 1A    SUMSER: CALL    STAKFP          ; Put FPREG on stack
4608   1D55 11 FD 18            LD      DE,MULT         ; Multiply by "X"
4609   1D58 D5                  PUSH    DE              ; To be done after
4610   1D59 E5                  PUSH    HL              ; Save address of table
4611   1D5A CD 56 1A            CALL    BCDEFP          ; Move FPREG to BCDE
4612   1D5D CD FF 18            CALL    FPMULT          ; Square the value
4613   1D60 E1                  POP     HL              ; Restore address of table
4614   1D61 CD 3B 1A    SMSER1: CALL    STAKFP          ; Put value on stack
4615   1D64 7E                  LD      A,(HL)          ; Get number of coefficients
4616   1D65 23                  INC     HL              ; Point to start of table
4617   1D66 CD 48 1A            CALL    PHLTFP          ; Move coefficient to FPREG
4618   1D69 06                  .BYTE      06H             ; Skip "POP AF"
4619   1D6A F1          SUMLP:  POP     AF              ; Restore count
4620   1D6B C1                  POP     BC              ; Restore number
4621   1D6C D1                  POP     DE
4622   1D6D 3D                  DEC     A               ; Cont coefficients
4623   1D6E C8                  RET     Z               ; All done
4624   1D6F D5                  PUSH    DE              ; Save number
4625   1D70 C5                  PUSH    BC
4626   1D71 F5                  PUSH    AF              ; Save count
4627   1D72 E5                  PUSH    HL              ; Save address in table
4628   1D73 CD FF 18            CALL    FPMULT          ; Multiply FPREG by BCDE
4629   1D76 E1                  POP     HL              ; Restore address in table
4630   1D77 CD 59 1A            CALL    LOADFP          ; Number at HL to BCDE
4631   1D7A E5                  PUSH    HL              ; Save address in table
4632   1D7B CD C4 17            CALL    FPADD           ; Add coefficient to FPREG
4633   1D7E E1                  POP     HL              ; Restore address in table
4634   1D7F C3 6A 1D            JP      SUMLP           ; More coefficients
4635   1D82             
4636   1D82 CD 0A 1A    RND:    CALL    TSTSGN          ; Test sign of FPREG
4637   1D85 21 C9 30            LD      HL,SEED+2       ; Random number seed
4638   1D88 FA E3 1D            JP      M,RESEED        ; Negative - Re-seed
4639   1D8B 21 EA 30            LD      HL,LSTRND       ; Last random number
4640   1D8E CD 48 1A            CALL    PHLTFP          ; Move last RND to FPREG
4641   1D91 21 C9 30            LD      HL,SEED+2       ; Random number seed
4642   1D94 C8                  RET     Z               ; Return if RND(0)
4643   1D95 86                  ADD     A,(HL)          ; Add (SEED)+2)
4644   1D96 E6 07               AND     00000111B       ; 0 to 7
4645   1D98 06 00               LD      B,0
4646   1D9A 77                  LD      (HL),A          ; Re-save seed
4647   1D9B 23                  INC     HL              ; Move to coefficient table
4648   1D9C 87                  ADD     A,A             ; 4 bytes
4649   1D9D 87                  ADD     A,A             ; per entry
4650   1D9E 4F                  LD      C,A             ; BC = Offset into table
4651   1D9F 09                  ADD     HL,BC           ; Point to coefficient
4652   1DA0 CD 59 1A            CALL    LOADFP          ; Coefficient to BCDE
4653   1DA3 CD FF 18            CALL    FPMULT  ;       ; Multiply FPREG by coefficient
4654   1DA6 3A C8 30            LD      A,(SEED+1)      ; Get (SEED+1)
4655   1DA9 3C                  INC     A               ; Add 1
4656   1DAA E6 03               AND     00000011B       ; 0 to 3
4657   1DAC 06 00               LD      B,0
4658   1DAE FE 01               CP      1               ; Is it zero?
4659   1DB0 88                  ADC     A,B             ; Yes - Make it 1
4660   1DB1 32 C8 30            LD      (SEED+1),A      ; Re-save seed
4661   1DB4 21 E7 1D            LD      HL,RNDTAB-4     ; Addition table
4662   1DB7 87                  ADD     A,A             ; 4 bytes
4663   1DB8 87                  ADD     A,A             ; per entry
4664   1DB9 4F                  LD      C,A             ; BC = Offset into table
4665   1DBA 09                  ADD     HL,BC           ; Point to value
4666   1DBB CD B5 17            CALL    ADDPHL          ; Add value to FPREG
4667   1DBE CD 56 1A    RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
4668   1DC1 7B                  LD      A,E             ; Get LSB
4669   1DC2 59                  LD      E,C             ; LSB = MSB
4670   1DC3 EE 4F               XOR     01001111B       ; Fiddle around
4671   1DC5 4F                  LD      C,A             ; New MSB
4672   1DC6 36 80               LD      (HL),80H        ; Set exponent
4673   1DC8 2B                  DEC     HL              ; Point to MSB
4674   1DC9 46                  LD      B,(HL)          ; Get MSB
4675   1DCA 36 80               LD      (HL),80H        ; Make value -0.5
4676   1DCC 21 C7 30            LD      HL,SEED         ; Random number seed
4677   1DCF 34                  INC     (HL)            ; Count seed
4678   1DD0 7E                  LD      A,(HL)          ; Get seed
4679   1DD1 D6 AB               SUB     171             ; Do it modulo 171
4680   1DD3 C2 DA 1D            JP      NZ,RND2         ; Non-zero - Ok
4681   1DD6 77                  LD      (HL),A          ; Zero seed
4682   1DD7 0C                  INC     C               ; Fillde about
4683   1DD8 15                  DEC     D               ; with the
4684   1DD9 1C                  INC     E               ; number
4685   1DDA CD 15 18    RND2:   CALL    BNORM           ; Normalise number
4686   1DDD 21 EA 30            LD      HL,LSTRND       ; Save random number
4687   1DE0 C3 62 1A            JP      FPTHL           ; Move FPREG to last and return
4688   1DE3             
4689   1DE3 77          RESEED: LD      (HL),A          ; Re-seed random numbers
4690   1DE4 2B                  DEC     HL
4691   1DE5 77                  LD      (HL),A
4692   1DE6 2B                  DEC     HL
4693   1DE7 77                  LD      (HL),A
4694   1DE8 C3 BE 1D            JP      RND1            ; Return RND seed
4695   1DEB             
4696   1DEB 68 B1 46 68 RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
4697   1DEF 99 E9 92 69         .BYTE   099H,0E9H,092H,069H
4698   1DF3 10 D1 75 68         .BYTE   010H,0D1H,075H,068H
4699   1DF7             
4700   1DF7 21 41 1E    COS:    LD      HL,HALFPI       ; Point to PI/2
4701   1DFA CD B5 17            CALL    ADDPHL          ; Add it to PPREG
4702   1DFD CD 3B 1A    SIN:    CALL    STAKFP          ; Put angle on stack
4703   1E00 01 49 83            LD      BC,8349H        ; BCDE = 2 PI
4704   1E03 11 DB 0F            LD      DE,0FDBH
4705   1E06 CD 4B 1A            CALL    FPBCDE          ; Move 2 PI to FPREG
4706   1E09 C1                  POP     BC              ; Restore angle
4707   1E0A D1                  POP     DE
4708   1E0B CD 60 19            CALL    DVBCDE          ; Divide angle by 2 PI
4709   1E0E CD 3B 1A            CALL    STAKFP          ; Put it on stack
4710   1E11 CD DD 1A            CALL    INT             ; Get INT of result
4711   1E14 C1                  POP     BC              ; Restore number
4712   1E15 D1                  POP     DE
4713   1E16 CD C1 17            CALL    SUBCDE          ; Make it 0 <= value < 1
4714   1E19 21 45 1E            LD      HL,QUARTR       ; Point to 0.25
4715   1E1C CD BB 17            CALL    SUBPHL          ; Subtract value from 0.25
4716   1E1F CD 0A 1A            CALL    TSTSGN          ; Test sign of value
4717   1E22 37                  SCF                     ; Flag positive
4718   1E23 F2 2D 1E            JP      P,SIN1          ; Positive - Ok
4719   1E26 CD B2 17            CALL    ROUND           ; Add 0.5 to value
4720   1E29 CD 0A 1A            CALL    TSTSGN          ; Test sign of value
4721   1E2C B7                  OR      A               ; Flag negative
4722   1E2D F5          SIN1:   PUSH    AF              ; Save sign
4723   1E2E F4 33 1A            CALL    P,INVSGN        ; Negate value if positive
4724   1E31 21 45 1E            LD      HL,QUARTR       ; Point to 0.25
4725   1E34 CD B5 17            CALL    ADDPHL          ; Add 0.25 to value
4726   1E37 F1                  POP     AF              ; Restore sign
4727   1E38 D4 33 1A            CALL    NC,INVSGN       ; Negative - Make positive
4728   1E3B 21 49 1E            LD      HL,SINTAB       ; Coefficient table
4729   1E3E C3 52 1D            JP      SUMSER          ; Evaluate sum of series
4730   1E41             
4731   1E41 DB 0F 49 81 HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
4732   1E45             
4733   1E45 00 00 00 7F QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
4734   1E49             
4735   1E49 05          SINTAB: .BYTE   5                       ; Table used by SIN
4736   1E4A BA D7 1E 86         .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
4737   1E4E 64 26 99 87         .BYTE   064H,026H,099H,087H     ;-76.575
4738   1E52 58 34 23 87         .BYTE   058H,034H,023H,087H     ; 81.602
4739   1E56 E0 5D A5 86         .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
4740   1E5A DA 0F 49 83         .BYTE   0DAH,00FH,049H,083H     ;  6.2832
4741   1E5E             
4742   1E5E CD 3B 1A    TAN:    CALL    STAKFP          ; Put angle on stack
4743   1E61 CD FD 1D            CALL    SIN             ; Get SIN of angle
4744   1E64 C1                  POP     BC              ; Restore angle
4745   1E65 E1                  POP     HL
4746   1E66 CD 3B 1A            CALL    STAKFP          ; Save SIN of angle
4747   1E69 EB                  EX      DE,HL           ; BCDE = Angle
4748   1E6A CD 4B 1A            CALL    FPBCDE          ; Angle to FPREG
4749   1E6D CD F7 1D            CALL    COS             ; Get COS of angle
4750   1E70 C3 5E 19            JP      DIV             ; TAN = SIN / COS
4751   1E73             
4752   1E73 CD 0A 1A    ATN:    CALL    TSTSGN          ; Test sign of value
4753   1E76 FC 9E 1C            CALL    M,NEGAFT        ; Negate result after if -ve
4754   1E79 FC 33 1A            CALL    M,INVSGN        ; Negate value if -ve
4755   1E7C 3A 97 31            LD      A,(FPEXP)       ; Get exponent
4756   1E7F FE 81               CP      81H             ; Number less than 1?
4757   1E81 DA 90 1E            JP      C,ATN1          ; Yes - Get arc tangnt
4758   1E84 01 00 81            LD      BC,8100H        ; BCDE = 1
4759   1E87 51                  LD      D,C
4760   1E88 59                  LD      E,C
4761   1E89 CD 60 19            CALL    DVBCDE          ; Get reciprocal of number
4762   1E8C 21 BB 17            LD      HL,SUBPHL       ; Sub angle from PI/2
4763   1E8F E5                  PUSH    HL              ; Save for angle > 1
4764   1E90 21 9A 1E    ATN1:   LD      HL,ATNTAB       ; Coefficient table
4765   1E93 CD 52 1D            CALL    SUMSER          ; Evaluate sum of series
4766   1E96 21 41 1E            LD      HL,HALFPI       ; PI/2 - angle in case > 1
4767   1E99 C9                  RET                     ; Number > 1 - Sub from PI/2
4768   1E9A             
4769   1E9A 09          ATNTAB: .BYTE   9                       ; Table used by ATN
4770   1E9B 4A D7 3B 78         .BYTE   04AH,0D7H,03BH,078H     ; 1/17
4771   1E9F 02 6E 84 7B         .BYTE   002H,06EH,084H,07BH     ;-1/15
4772   1EA3 FE C1 2F 7C         .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
4773   1EA7 74 31 9A 7D         .BYTE   074H,031H,09AH,07DH     ;-1/11
4774   1EAB 84 3D 5A 7D         .BYTE   084H,03DH,05AH,07DH     ; 1/9
4775   1EAF C8 7F 91 7E         .BYTE   0C8H,07FH,091H,07EH     ;-1/7
4776   1EB3 E4 BB 4C 7E         .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
4777   1EB7 6C AA AA 7F         .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
4778   1EBB 00 00 00 81         .BYTE   000H,000H,000H,081H     ; 1/1
4779   1EBF             
4780   1EBF             
4781   1EBF C9          ARET:   RET                     ; A RETurn instruction
4782   1EC0             
4783   1EC0 D7          GETINP: RST	    10H             ;input a character
4784   1EC1 C9                  RET
4785   1EC2             
4786   1EC2             CLS: 
4787   1EC2 3E 0C               LD      A,CS            ; ASCII Clear screen
4788   1EC4 C3 FC 1F            JP      MONOUT          ; Output character
4789   1EC7             
4790   1EC7 CD 89 17    WIDTH:  CALL    GETINT          ; Get integer 0-255
4791   1ECA 7B                  LD      A,E             ; Width to A
4792   1ECB 32 F2 30            LD      (LWIDTH),A      ; Set width
4793   1ECE C9                  RET
4794   1ECF             
4795   1ECF CD 28 10    LINES:  CALL    GETNUM          ; Get a number
4796   1ED2 CD 6D 0C            CALL    DEINT           ; Get integer -32768 to 32767
4797   1ED5 ED 53 F6 30         LD      (LINESC),DE     ; Set lines counter
4798   1ED9 ED 53 F8 30         LD      (LINESN),DE     ; Set lines number
4799   1EDD C9                  RET
4800   1EDE             
4801   1EDE CD 6D 0C    DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
4802   1EE1 D5                  PUSH    DE              ; Save number
4803   1EE2 E1                  POP     HL              ; Number to HL
4804   1EE3 46                  LD      B,(HL)          ; Get LSB of contents
4805   1EE4 23                  INC     HL
4806   1EE5 7E                  LD      A,(HL)          ; Get MSB of contents
4807   1EE6 C3 E3 13            JP      ABPASS          ; Return integer AB
4808   1EE9             
4809   1EE9 CD 28 10    DOKE:   CALL    GETNUM          ; Get a number
4810   1EEC CD 6D 0C            CALL    DEINT           ; Get integer -32768 to 32767
4811   1EEF D5                  PUSH    DE              ; Save address
4812   1EF0 CD 31 0A            CALL    CHKSYN          ; Make sure ',' follows
4813   1EF3 2C                  .BYTE      ','
4814   1EF4 CD 28 10            CALL    GETNUM          ; Get a number
4815   1EF7 CD 6D 0C            CALL    DEINT           ; Get integer -32768 to 32767
4816   1EFA E3                  EX      (SP),HL         ; Save value,get address
4817   1EFB 73                  LD      (HL),E          ; Save LSB of value
4818   1EFC 23                  INC     HL
4819   1EFD 72                  LD      (HL),D          ; Save MSB of value
4820   1EFE E1                  POP     HL              ; Restore code string address
4821   1EFF C9                  RET
4822   1F00             
4823   1F00             
4824   1F00             ; HEX$(nn) Convert 16 bit number to Hexadecimal string
4825   1F00             
4826   1F00 CD 2B 10    HEX: 	CALL	TSTNUM          ; Verify it's a number
4827   1F03 CD 6D 0C            CALL	DEINT           ; Get integer -32768 to 32767
4828   1F06 C5                  PUSH	BC              ; Save contents of BC
4829   1F07 21 99 31            LD	    HL,PBUFF
4830   1F0A 7A                  LD	    A,D             ; Get high order into A
4831   1F0B FE 00               CP      $0
4832   1F0D 28 0C       		JR      Z,HEX2          ; Skip output if both high digits are zero
4833   1F0F CD 38 1F            CALL    BYT2ASC         ; Convert D to ASCII
4834   1F12 78          		LD      A,B
4835   1F13 FE 30       		CP      '0'
4836   1F15 28 02       		JR      Z,HEX1          ; Don't store high digit if zero
4837   1F17 70                  LD	    (HL),B          ; Store it to PBUFF
4838   1F18 23                  INC	    HL              ; Next location
4839   1F19 71          HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
4840   1F1A 23                  INC     HL              ; Next location
4841   1F1B 7B          HEX2:   LD	    A,E             ; Get lower byte
4842   1F1C CD 38 1F            CALL    BYT2ASC         ; Convert E to ASCII
4843   1F1F 7A          		LD      A,D
4844   1F20 FE 00               CP      $0
4845   1F22 20 05       		JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
4846   1F24 78          		LD      A,B
4847   1F25 FE 30       		CP      '0'             ; If high digit of lower byte is zero then don't print
4848   1F27 28 02       		JR      Z,HEX4
4849   1F29 70          HEX3:   LD      (HL),B          ; to PBUFF+2
4850   1F2A 23                  INC     HL              ; Next location
4851   1F2B 71          HEX4:   LD      (HL),C          ; to PBUFF+3
4852   1F2C 23                  INC     HL              ; PBUFF+4 to zero
4853   1F2D AF                  XOR     A               ; Terminating character
4854   1F2E 77                  LD      (HL),A          ; Store zero to terminate
4855   1F2F 23                  INC     HL              ; Make sure PBUFF is terminated
4856   1F30 77                  LD      (HL),A          ; Store the double zero there
4857   1F31 C1                  POP     BC              ; Get BC back
4858   1F32 21 99 31            LD      HL,PBUFF        ; Reset to start of PBUFF
4859   1F35 C3 91 14            JP      STR1            ; Convert the PBUFF to a string and return it
4860   1F38             
4861   1F38 47          BYT2ASC	LD      B,A             ; Save original value
4862   1F39 E6 0F               AND     $0F             ; Strip off upper nybble
4863   1F3B FE 0A               CP      $0A             ; 0-9?
4864   1F3D 38 02               JR      C,ADD30         ; If A-F, add 7 more
4865   1F3F C6 07               ADD     A,$07           ; Bring value up to ASCII A-F
4866   1F41 C6 30       ADD30	ADD     A,$30           ; And make ASCII
4867   1F43 4F                  LD      C,A             ; Save converted char to C
4868   1F44 78                  LD      A,B             ; Retrieve original value
4869   1F45 0F                  RRCA                    ; and Rotate it right
4870   1F46 0F                  RRCA
4871   1F47 0F                  RRCA
4872   1F48 0F                  RRCA
4873   1F49 E6 0F               AND     $0F             ; Mask off upper nybble
4874   1F4B FE 0A               CP      $0A             ; 0-9? < A hex?
4875   1F4D 38 02               JR      C,ADD301        ; Skip Add 7
4876   1F4F C6 07               ADD     A,$07           ; Bring it up to ASCII A-F
4877   1F51 C6 30       ADD301	ADD     A,$30           ; And make it full ASCII
4878   1F53 47                  LD      B,A             ; Store high order byte
4879   1F54 C9                  RET	
4880   1F55             
4881   1F55             ; Convert "&Hnnnn" to FPREG
4882   1F55             ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
4883   1F55             ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
4884   1F55 EB          HEXTFP  EX      DE,HL           ; Move code string pointer to DE
4885   1F56 21 00 00            LD      HL,$0000        ; Zero out the value
4886   1F59 CD 6E 1F            CALL    GETHEX          ; Check the number for valid hex
4887   1F5C DA 8E 1F            JP      C,HXERR         ; First value wasn't hex, HX error
4888   1F5F 18 05               JR      HEXLP1          ; Convert first character
4889   1F61 CD 6E 1F    HEXLP   CALL    GETHEX          ; Get second and addtional characters
4890   1F64 38 1F               JR      C,HEXIT         ; Exit if not a hex character
4891   1F66 29          HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
4892   1F67 29                  ADD     HL,HL
4893   1F68 29                  ADD     HL,HL
4894   1F69 29                  ADD     HL,HL
4895   1F6A B5                  OR      L               ; Add in D0-D3 into L
4896   1F6B 6F                  LD      L,A             ; Save new value
4897   1F6C 18 F3               JR      HEXLP           ; And continue until all hex characters are in
4898   1F6E             
4899   1F6E 13          GETHEX  INC     DE              ; Next location
4900   1F6F 1A                  LD      A,(DE)          ; Load character at pointer
4901   1F70 FE 20               CP      ' '
4902   1F72 CA 6E 1F            JP      Z,GETHEX        ; Skip spaces
4903   1F75 D6 30               SUB     $30             ; Get absolute value
4904   1F77 D8                  RET     C               ; < "0", error
4905   1F78 FE 0A               CP      $0A
4906   1F7A 38 05               JR      C,NOSUB7        ; Is already in the range 0-9
4907   1F7C D6 07               SUB     $07             ; Reduce to A-F
4908   1F7E FE 0A               CP      $0A             ; Value should be $0A-$0F at this point
4909   1F80 D8                  RET     C               ; CY set if was :            ; < = > ? @
4910   1F81 FE 10       NOSUB7  CP      $10             ; > Greater than "F"?
4911   1F83 3F                  CCF
4912   1F84 C9                  RET                     ; CY set if it wasn't valid hex
4913   1F85                 
4914   1F85 EB          HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
4915   1F86 7A                  LD      A,D             ; Load DE into AC
4916   1F87 4B                  LD      C,E             ; For prep to 
4917   1F88 E5                  PUSH    HL
4918   1F89 CD E2 13            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4919   1F8C E1                  POP     HL
4920   1F8D C9                  RET
4921   1F8E             
4922   1F8E 1E 26       HXERR:  LD      E,HX            ; ?HEX Error
4923   1F90 C3 77 07            JP      ERROR
4924   1F93             
4925   1F93             ; BIN$(NN) Convert integer to a 1-16 char binary string
4926   1F93 CD 2B 10    BIN:    CALL    TSTNUM          ; Verify it's a number
4927   1F96 CD 6D 0C            CALL    DEINT           ; Get integer -32768 to 32767
4928   1F99 C5          BIN2:   PUSH    BC              ; Save contents of BC
4929   1F9A 21 99 31            LD      HL,PBUFF
4930   1F9D 06 11               LD      B,17            ; One higher than max char count
4931   1F9F             ZEROSUP:                        ; Suppress leading zeros
4932   1F9F 05                  DEC     B               ; Max 16 chars
4933   1FA0 78                  LD      A,B
4934   1FA1 FE 01               CP      $01
4935   1FA3 28 08               JR      Z,BITOUT        ; Always output at least one character
4936   1FA5 CB 13               RL      E
4937   1FA7 CB 12               RL      D
4938   1FA9 30 F4               JR      NC,ZEROSUP
4939   1FAB 18 04               JR      BITOUT2
4940   1FAD             BITOUT:      
4941   1FAD CB 13               RL      E
4942   1FAF CB 12               RL      D               ; Top bit now in carry
4943   1FB1             BITOUT2:
4944   1FB1 3E 30               LD      A,'0'           ; Char for '0'
4945   1FB3 CE 00               ADC     A,0             ; If carry set then '0' --> '1'
4946   1FB5 77                  LD      (HL),A
4947   1FB6 23                  INC     HL
4948   1FB7 05                  DEC     B
4949   1FB8 20 F3               JR      NZ,BITOUT
4950   1FBA AF                  XOR     A               ; Terminating character
4951   1FBB 77                  LD      (HL),A          ; Store zero to terminate
4952   1FBC 23                  INC     HL              ; Make sure PBUFF is terminated
4953   1FBD 77                  LD      (HL),A          ; Store the double zero there
4954   1FBE C1                  POP     BC
4955   1FBF 21 99 31            LD      HL,PBUFF
4956   1FC2 C3 91 14            JP      STR1
4957   1FC5             
4958   1FC5             ; Convert "&Bnnnn" to FPREG
4959   1FC5             ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
4960   1FC5 EB          BINTFP: EX      DE,HL           ; Move code string pointer to DE
4961   1FC6 21 00 00            LD      HL,$0000        ; Zero out the value
4962   1FC9 CD E2 1F            CALL    CHKBIN          ; Check the number for valid bin
4963   1FCC DA F0 1F            JP      C,BINERR        ; First value wasn't bin, HX error
4964   1FCF D6 30       BINIT:  SUB     '0'
4965   1FD1 29                  ADD     HL,HL           ; Rotate HL left
4966   1FD2 B5                  OR      L
4967   1FD3 6F                  LD      L,A
4968   1FD4 CD E2 1F            CALL    CHKBIN          ; Get second and addtional characters
4969   1FD7 30 F6               JR      NC,BINIT        ; Process if a bin character
4970   1FD9 EB                  EX      DE,HL           ; Value into DE, Code string into HL
4971   1FDA 7A                  LD      A,D             ; Load DE into AC
4972   1FDB 4B                  LD      C,E             ; For prep to 
4973   1FDC E5                  PUSH    HL
4974   1FDD CD E2 13            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4975   1FE0 E1                  POP     HL
4976   1FE1 C9                  RET
4977   1FE2             
4978   1FE2             ; Char is in A, NC if char is 0 or 1
4979   1FE2 13          CHKBIN: INC     DE
4980   1FE3 1A                  LD      A,(DE)
4981   1FE4 FE 20               CP      ' '
4982   1FE6 CA E2 1F            JP      Z,CHKBIN        ; Skip spaces
4983   1FE9 FE 30               CP      '0'             ; Set C if < '0'
4984   1FEB D8                  RET     C
4985   1FEC FE 32               CP      '2'
4986   1FEE 3F                  CCF                     ; Set C if > '1'
4987   1FEF C9                  RET
4988   1FF0             
4989   1FF0 1E 28       BINERR: LD      E,BN            ; ?BIN Error
4990   1FF2 C3 77 07            JP      ERROR
4991   1FF5             
4992   1FF5             
4993   1FF5             JJUMP1: 
4994   1FF5 DD 21 FF FF         LD      IX,-1           ; Flag cold start
4995   1FF9 C3 C7 03            JP      CSTART          ; Go and initialise
4996   1FFC             
4997   1FFC             MONOUT: 
4998   1FFC C3 08 00            JP      $0008           ; output a char
4999   1FFF             
5000   1FFF             
5001   1FFF             MONITR: 
5002   1FFF C3 00 00            JP      $0000           ; Restart (Normally Monitor Start)
5003   2002             
5004   2002             
5005   2002 3E 00       INITST: LD      A,0             ; Clear break flag
5006   2004 32 FD 30            LD      (BRKFLG),A
5007   2007 C3 CE 03            JP      INIT
5008   200A             
5009   200A ED 45       ARETN:  RETN                    ; Return from NMI
5010   200C             
5011   200C             
5012   200C F5          TSTBIT: PUSH    AF              ; Save bit mask
5013   200D A0                  AND     B               ; Get common bits
5014   200E C1                  POP     BC              ; Restore bit mask
5015   200F B8                  CP      B               ; Same bit set?
5016   2010 3E 00               LD      A,0             ; Return 0 in A
5017   2012 C9                  RET
5018   2013             
5019   2013 CD 3C 0A    OUTNCR: CALL    OUTC            ; Output character in A
5020   2016 C3 63 0E            JP      PRNTCRLF        ; Output CRLF
5021   2019             
5022   2019             .end
5023   2019             
tasm: Number of errors = 0
