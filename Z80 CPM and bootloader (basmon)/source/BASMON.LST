0001   0000             ;==================================================================================
0002   0000             ; The updates to the original BASIC within this file are copyright Grant Searle
0003   0000             ;
0004   0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0005   0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0006   0000             ;
0007   0000             ; http://searle.hostei.com/grant/index.html
0008   0000             ;
0009   0000             ; eMail: home.micros01@btinternet.com
0010   0000             ;
0011   0000             ; If the above don't work, please perform an Internet search to see if I have
0012   0000             ; updated the web page hosting service.
0013   0000             ;
0014   0000             ;==================================================================================
0015   0000             
0016   0000             
0017   0000             ;==================================================================================
0018   0000             ; Contents of this file are copyright Grant Searle
0019   0000             ; HEX routines from Joel Owens.
0020   0000             ;
0021   0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0022   0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0023   0000             ;
0024   0000             ; http://searle.hostei.com/grant/index.html
0025   0000             ;
0026   0000             ; eMail: home.micros01@btinternet.com
0027   0000             ;
0028   0000             ; If the above don't work, please perform an Internet search to see if I have
0029   0000             ; updated the web page hosting service.
0030   0000             ;
0031   0000             ;==================================================================================
0032   0000             
0033   0000             ;------------------------------------------------------------------------------
0034   0000             ;
0035   0000             ; Z80 Monitor Rom
0036   0000             ;
0037   0000             ;------------------------------------------------------------------------------
0038   0000             ; General Equates
0039   0000             ;------------------------------------------------------------------------------
0040   0000             
0041   0000             ;CR		.EQU	0DH
0042   0000             ;LF		.EQU	0AH
0043   0000             ;ESC		.EQU	1BH
0044   0000             ;CTRLC	.EQU	03H
0045   0000             M_CLS		.EQU	0CH
0046   0000             
0047   0000             
0048   0000             loadAddr	.EQU	0D000h	; CP/M load address
0049   0000             numSecs		.EQU	24	; Number of 512 sectors to be loaded
0050   0000             
0051   0000             
0052   0000             RTS_HIGH	.EQU	0D5H
0053   0000             RTS_LOW		.EQU	095H
0054   0000             
0055   0000             ACIA0_D		.EQU	$81
0056   0000             ACIA0_C		.EQU	$80
0057   0000             ACIA1_D		.EQU	$83
0058   0000             ACIA1_C		.EQU	$82
0059   0000             
0060   0000             SD_DATA		.EQU	088H
0061   0000             SD_CONTROL	.EQU	089H
0062   0000             SD_STATUS	.EQU	089H
0063   0000             SD_LBA0		.EQU	08AH
0064   0000             SD_LBA1		.EQU	08BH
0065   0000             SD_LBA2		.EQU	08CH
0066   0000             
0067   3000             	.ORG	$3000
0068   3000             
0069   3000             primaryIO	.ds	1
0070   3001             secNo		.ds	1
0071   3002             dmaAddr		.ds	2
0072   3004             
0073   3004 00          lba0		.DB	00h
0074   3005 00          lba1		.DB	00h
0075   3006 00          lba2		.DB	00h
0076   3007 00          lba3		.DB	00h
0077   3008             
0078   3008             stackSpace	.ds	32
0079   3028             M_STACK   	.EQU    $	; Stack top
0080   3028             
0081   3028             
0082   3028             ;------------------------------------------------------------------------------
0083   3028             ;                         START OF MONITOR ROM
0084   3028             ;------------------------------------------------------------------------------
0085   3028             
0086   0000             MON		.ORG	$0000		; MONITOR ROM RESET VECTOR
0087   0000             ;------------------------------------------------------------------------------
0088   0000             ; Reset
0089   0000             ;------------------------------------------------------------------------------
0090   0000 F3          RST00		DI			;Disable INTerrupts
0091   0001 C3 94 00    		JP	M_INIT		;Initialize Hardware and go
0092   0004 00          		NOP
0093   0005 00          		NOP
0094   0006 00          		NOP
0095   0007 00          		NOP
0096   0008             ;------------------------------------------------------------------------------
0097   0008             ; TX a character over RS232 wait for TXDONE first.
0098   0008             ;------------------------------------------------------------------------------
0099   0008 C3 32 00    RST08		JP	conout
0100   000B 00          		NOP
0101   000C 00          		NOP
0102   000D 00          		NOP
0103   000E 00          		NOP
0104   000F 00          		NOP
0105   0010             ;------------------------------------------------------------------------------
0106   0010             ; RX a character from buffer wait until char ready.
0107   0010             ;------------------------------------------------------------------------------
0108   0010 C3 1B 00    RST10		JP	conin
0109   0013 00          		NOP
0110   0014 00          		NOP
0111   0015 00          		NOP
0112   0016 00          		NOP
0113   0017 00          		NOP
0114   0018             ;------------------------------------------------------------------------------
0115   0018             ; Check input buffer status
0116   0018             ;------------------------------------------------------------------------------
0117   0018 C3 5C 00    RST18		JP	CKINCHAR
0118   001B             
0119   001B             
0120   001B             ;------------------------------------------------------------------------------
0121   001B             ; Console input routine
0122   001B             ; Use the "primaryIO" flag to determine which input port to monitor.
0123   001B             ;------------------------------------------------------------------------------
0124   001B             conin:
0125   001B 3A 00 30    		LD	A,(primaryIO)
0126   001E FE 00       		CP	0
0127   0020 20 08       		JR	NZ,coninB
0128   0022             coninA:
0129   0022             
0130   0022             waitForCharA:
0131   0022 CD 63 00    		call ckincharA
0132   0025 28 FB       		JR	Z, waitForCharA
0133   0027 DB 81       		IN   	A,(ACIA0_D)
0134   0029 C9          		RET	; Char ready in A
0135   002A             
0136   002A             coninB:
0137   002A             
0138   002A             waitForCharB:
0139   002A CD 6A 00    		call ckincharB
0140   002D 28 FB       		JR	Z, waitForCharB
0141   002F DB 83       		IN   	A,(ACIA1_D)
0142   0031 C9          		RET	; Char ready in A
0143   0032             
0144   0032             ;------------------------------------------------------------------------------
0145   0032             ; Console output routine
0146   0032             ; Use the "primaryIO" flag to determine which output port to send a character.
0147   0032             ;------------------------------------------------------------------------------
0148   0032 F5          conout:		PUSH	AF		; Store character
0149   0033 3A 00 30    		LD	A,(primaryIO)
0150   0036 FE 00       		CP	0
0151   0038 20 0D       		JR	NZ,conoutB1
0152   003A 18 01       		JR	conoutA1
0153   003C             conoutA:
0154   003C F5          		PUSH	AF
0155   003D             
0156   003D CD 50 00    conoutA1:	CALL	CKACIA0		; See if ACIA channel A is finished transmitting
0157   0040 28 FB       		JR	Z,conoutA1	; Loop until ACIA flag signals ready
0158   0042 F1          		POP	AF		; RETrieve character
0159   0043 D3 81       		OUT	(ACIA0_D),A	; OUTput the character
0160   0045 C9          		RET
0161   0046             
0162   0046             conoutB:
0163   0046 F5          		PUSH	AF
0164   0047             
0165   0047 CD 56 00    conoutB1:	CALL	CKACIA1		; See if ACIA channel B is finished transmitting
0166   004A 28 FB       		JR	Z,conoutB1	; Loop until ACIA flag signals ready
0167   004C F1          		POP	AF		; RETrieve character
0168   004D D3 83       		OUT	(ACIA1_D),A	; OUTput the character
0169   004F C9          		RET
0170   0050             
0171   0050             ;------------------------------------------------------------------------------
0172   0050             ; I/O status check routine
0173   0050             ; Use the "primaryIO" flag to determine which port to check.
0174   0050             ;------------------------------------------------------------------------------
0175   0050             CKACIA0
0176   0050 DB 80       		IN   	A,(ACIA0_C)	; Status byte D1=TX Buff Empty, D0=RX char ready	
0177   0052 0F          		RRCA			; Rotates RX status into Carry Flag,	
0178   0053 CB 47       		BIT  	0,A		; Set Zero flag if still transmitting character	
0179   0055 C9                  RET
0180   0056             
0181   0056             CKACIA1
0182   0056 DB 82       		IN   	A,(ACIA1_C)	; Status byte D1=TX Buff Empty, D0=RX char ready	
0183   0058 0F          		RRCA			; Rotates RX status into Carry Flag,	
0184   0059 CB 47       		BIT  	0,A		; Set Zero flag if still transmitting character	
0185   005B C9                  RET
0186   005C             
0187   005C             ;------------------------------------------------------------------------------
0188   005C             ; Check if there is a character in the input buffer
0189   005C             ; Use the "primaryIO" flag to determine which port to check.
0190   005C             ;------------------------------------------------------------------------------
0191   005C             CKINCHAR
0192   005C 3A 00 30    		LD	A,(primaryIO)
0193   005F FE 00       		CP	0
0194   0061 20 07       		JR	NZ,ckincharB
0195   0063             
0196   0063             ckincharA:
0197   0063             
0198   0063 DB 80       		IN   A,(ACIA0_C)		; Status byte
0199   0065 E6 01       		AND  $01
0200   0067 FE 00       		CP   $0			; Z flag set if no char
0201   0069 C9          		RET
0202   006A             
0203   006A             ckincharB:
0204   006A             
0205   006A DB 82       		IN   A,(ACIA1_C)		; Status byte
0206   006C E6 01       		AND  $01
0207   006E FE 00       		CP   $0			; Z flag set if no char
0208   0070 C9          		RET
0209   0071             
0210   0071             ;------------------------------------------------------------------------------
0211   0071             ; Filtered Character I/O
0212   0071             ;------------------------------------------------------------------------------
0213   0071             
0214   0071 D7          RDCHR		RST	10H
0215   0072 FE 0A       		CP	LF
0216   0074 28 FB       		JR	Z,RDCHR		; Ignore LF
0217   0076 FE 1B       		CP	ESC
0218   0078 20 02       		JR	NZ,RDCHR1
0219   007A 3E 03       		LD	A,CTRLC		; Change ESC to CTRL-C
0220   007C C9          RDCHR1		RET
0221   007D             
0222   007D FE 0D       WRCHR		CP	CR
0223   007F 28 0A       		JR	Z,WRCRLF	; When CR, write CRLF
0224   0081 FE 0C       		CP	M_CLS
0225   0083 28 04       		JR	Z,WR		; Allow write of "CLS"
0226   0085 FE 20       		CP	' '		; Don't write out any other control codes
0227   0087 38 01       		JR	C,NOWR		; ie. < space
0228   0089 CF          WR		RST	08H
0229   008A C9          NOWR		RET
0230   008B             
0231   008B 3E 0D       WRCRLF		LD	A,CR
0232   008D CF          		RST	08H
0233   008E 3E 0A       		LD	A,LF
0234   0090 CF          		RST	08H
0235   0091 3E 0D       		LD	A,CR
0236   0093 C9          		RET
0237   0094             
0238   0094             
0239   0094             ;------------------------------------------------------------------------------
0240   0094             ; Initialise hardware and start main loop
0241   0094             ;------------------------------------------------------------------------------
0242   0094 31 28 30    M_INIT		LD   SP,M_STACK		; Set the Stack Pointer
0243   0097             
0244   0097 3E 95       	   LD        A,RTS_LOW
0245   0099 D3 80       	   OUT       (ACIA0_C),A         ; Initialise ACIA0
0246   009B D3 82       	   OUT       (ACIA1_C),A         ; Initialise ACIA1
0247   009D             		; Display the "Press space to start" message on both consoles
0248   009D 3E 00       		LD	A,$00
0249   009F 32 00 30    		LD	(primaryIO),A
0250   00A2 21 65 03        		LD   	HL,INITTXT
0251   00A5 CD 1B 01    		CALL 	M_PRINT
0252   00A8 3E 01       		LD	A,$01
0253   00AA 32 00 30    		LD	(primaryIO),A
0254   00AD 21 65 03        		LD   	HL,INITTXT
0255   00B0 CD 1B 01    		CALL 	M_PRINT
0256   00B3             
0257   00B3             		; Wait until space is in one of the buffers to determine the active console
0258   00B3             
0259   00B3             waitForSpace:
0260   00B3             
0261   00B3 CD 63 00    		CALL ckincharA
0262   00B6 28 0F       		jr	Z,notInA
0263   00B8 3E 00       		LD	A,$00
0264   00BA 32 00 30    		LD	(primaryIO),A
0265   00BD CD 1B 00    		CALL	conin
0266   00C0 FE 20       		CP	' '
0267   00C2 C2 B3 00    		JP	NZ, waitForSpace
0268   00C5 18 14       		JR	spacePressed
0269   00C7             
0270   00C7             notInA:
0271   00C7 CD 6A 00    		CALL ckincharB
0272   00CA 28 E7       		JR	Z,waitForSpace
0273   00CC 3E 01       		LD	A,$01
0274   00CE 32 00 30    		LD	(primaryIO),A
0275   00D1 CD 1B 00    		CALL	conin
0276   00D4 FE 20       		CP	' '
0277   00D6 C2 B3 00    		JP	NZ, waitForSpace
0278   00D9 18 00       		JR	spacePressed
0279   00DB             
0280   00DB             spacePressed:
0281   00DB             
0282   00DB             		; Clear message on both consoles
0283   00DB 3E 0C       		LD	A,$0C
0284   00DD CD 3C 00    		CALL	conoutA
0285   00E0 CD 46 00    		CALL	conoutB
0286   00E3             
0287   00E3             		; primaryIO is now set to the channel where SPACE was pressed
0288   00E3             	
0289   00E3             
0290   00E3 CD 22 01    		CALL TXCRLF	; TXCRLF
0291   00E6 21 96 02    		LD   HL,M_SIGNON	; Print SIGNON message
0292   00E9 CD 1B 01    		CALL M_PRINT
0293   00EC             
0294   00EC             ;------------------------------------------------------------------------------
0295   00EC             ; Monitor command loop
0296   00EC             ;------------------------------------------------------------------------------
0297   00EC 21 EC 00    MAIN  		LD   HL,MAIN	; Save entry point for Monitor	
0298   00EF E5          		PUSH HL		; This is the return address
0299   00F0 CD 22 01    MAIN0		CALL TXCRLF	; Entry point for Monitor, Normal	
0300   00F3 3E 3E       		LD   A,'>'	; Get a ">"	
0301   00F5 CF          		RST 08H		; print it
0302   00F6             
0303   00F6 CD 71 00    MAIN1		CALL RDCHR	; Get a character from the input port
0304   00F9 FE 20       		CP   ' '	; <spc> or less? 	
0305   00FB 38 F9       		JR   C,MAIN1	; Go back
0306   00FD             	
0307   00FD FE 3A       		CP   ':'	; ":"?
0308   00FF CA 99 01    		JP   Z,LOAD	; First character of a HEX load
0309   0102             
0310   0102 CD 7D 00    		CALL WRCHR	; Print char on console
0311   0105             
0312   0105 E6 5F       		AND  $5F	; Make character uppercase
0313   0107             
0314   0107 FE 42       		CP   'B'
0315   0109 CA DA 01    		JP   Z,BASIC
0316   010C             
0317   010C FE 47       		CP   'G'
0318   010E CA 93 01    		JP   Z,M_GOTO
0319   0111             
0320   0111 FE 58       		CP   'X'
0321   0113 CA F1 01    		JP   Z,CPMLOAD
0322   0116             
0323   0116 3E 3F       		LD   A,'?'	; Get a "?"	
0324   0118 CF          		RST 08H		; Print it
0325   0119 18 D5       		JR   MAIN0
0326   011B             	
0327   011B             ;------------------------------------------------------------------------------
0328   011B             ; Print string of characters to Serial A until byte=$00, WITH CR, LF
0329   011B             ;------------------------------------------------------------------------------
0330   011B 7E          M_PRINT		LD   A,(HL)	; Get character
0331   011C B7          		OR   A		; Is it $00 ?
0332   011D C8          		RET  Z		; Then RETurn on terminator
0333   011E CF          		RST  08H	; Print it
0334   011F 23          		INC  HL		; Next Character
0335   0120 18 F9       		JR   M_PRINT	; Continue until $00
0336   0122             
0337   0122             
0338   0122 3E 0D       TXCRLF		LD   A,$0D	; 
0339   0124 CF          		RST  08H	; Print character 
0340   0125 3E 0A       		LD   A,$0A	; 
0341   0127 CF          		RST  08H	; Print character
0342   0128 C9          		RET
0343   0129             
0344   0129             ;------------------------------------------------------------------------------
0345   0129             ; Get a character from the console, must be $20-$7F to be valid (no control characters)
0346   0129             ; <Ctrl-c> and <SPACE> breaks with the Zero Flag set
0347   0129             ;------------------------------------------------------------------------------	
0348   0129 CD 71 00    M_GETCHR		CALL RDCHR	; RX a Character
0349   012C FE 03       		CP   $03	; <ctrl-c> User break?
0350   012E C8          		RET  Z			
0351   012F FE 20       		CP   $20	; <space> or better?
0352   0131 38 F6       		JR   C,M_GETCHR	; Do it again until we get something usable
0353   0133 C9          		RET
0354   0134             ;------------------------------------------------------------------------------
0355   0134             ; Gets two ASCII characters from the console (assuming them to be HEX 0-9 A-F)
0356   0134             ; Moves them into B and C, converts them into a byte value in A and updates a
0357   0134             ; Checksum value in E
0358   0134             ;------------------------------------------------------------------------------
0359   0134 CD 29 01    GET2		CALL M_GETCHR	; Get us a valid character to work with
0360   0137 47          		LD   B,A	; Load it in B
0361   0138 CD 29 01    		CALL M_GETCHR	; Get us another character
0362   013B 4F          		LD   C,A	; load it in C
0363   013C CD 73 01    		CALL BCTOA	; Convert ASCII to byte
0364   013F 4F          		LD   C,A	; Build the checksum
0365   0140 7B          		LD   A,E
0366   0141 91          		SUB  C		; The checksum should always equal zero when checked
0367   0142 5F          		LD   E,A	; Save the checksum back where it came from
0368   0143 79          		LD   A,C	; Retrieve the byte and go back
0369   0144 C9          		RET
0370   0145             ;------------------------------------------------------------------------------
0371   0145             ; Gets four Hex characters from the console, converts them to values in HL
0372   0145             ;------------------------------------------------------------------------------
0373   0145 21 00 00    GETHL		LD   HL,$0000	; Gets xxxx but sets Carry Flag on any Terminator
0374   0148 CD 8C 01    		CALL ECHO	; RX a Character
0375   014B FE 0D       		CP   $0D	; <CR>?
0376   014D 20 0E       		JR   NZ,GETX2	; other key		
0377   014F 37          SETCY		SCF		; Set Carry Flag
0378   0150 C9          		RET             ; and Return to main program		
0379   0151             ;------------------------------------------------------------------------------
0380   0151             ; This routine converts last four hex characters (0-9 A-F) user types into a value in HL
0381   0151             ; Rotates the old out and replaces with the new until the user hits a terminating character
0382   0151             ;------------------------------------------------------------------------------
0383   0151 21 00 00    GETX		LD   HL,$0000	; CLEAR HL
0384   0154 CD 8C 01    GETX1		CALL ECHO	; RX a character from the console
0385   0157 FE 0D       		CP   $0D	; <CR>
0386   0159 C8          		RET  Z		; quit
0387   015A FE 2C       		CP   $2C	; <,> can be used to safely quit for multiple entries
0388   015C C8          		RET  Z		; (Like filling both DE and HL from the user)
0389   015D FE 03       GETX2		CP   $03	; Likewise, a <ctrl-C> will terminate clean, too, but
0390   015F 28 EE       		JR   Z,SETCY	; It also sets the Carry Flag for testing later.
0391   0161 29          		ADD  HL,HL	; Otherwise, rotate the previous low nibble to high
0392   0162 29          		ADD  HL,HL	; rather slowly
0393   0163 29          		ADD  HL,HL	; until we get to the top
0394   0164 29          		ADD  HL,HL	; and then we can continue on.
0395   0165 D6 30       		SUB  $30	; Convert ASCII to byte	value
0396   0167 FE 0A       		CP   $0A	; Are we in the 0-9 range?
0397   0169 38 02       		JR   C,GETX3	; Then we just need to sub $30, but if it is A-F
0398   016B D6 07       		SUB  $07	; We need to take off 7 more to get the value down to
0399   016D E6 0F       GETX3		AND  $0F	; to the right hex value
0400   016F 85          		ADD  A,L	; Add the high nibble to the low
0401   0170 6F          		LD   L,A	; Move the byte back to A
0402   0171 18 E1       		JR   GETX1	; and go back for next character until he terminates
0403   0173             ;------------------------------------------------------------------------------
0404   0173             ; Convert ASCII characters in B C registers to a byte value in A
0405   0173             ;------------------------------------------------------------------------------
0406   0173 78          BCTOA		LD   A,B	; Move the hi order byte to A
0407   0174 D6 30       		SUB  $30	; Take it down from Ascii
0408   0176 FE 0A       		CP   $0A	; Are we in the 0-9 range here?
0409   0178 38 02       		JR   C,BCTOA1	; If so, get the next nybble
0410   017A D6 07       		SUB  $07	; But if A-F, take it down some more
0411   017C 07          BCTOA1		RLCA		; Rotate the nybble from low to high
0412   017D 07          		RLCA		; One bit at a time
0413   017E 07          		RLCA		; Until we
0414   017F 07          		RLCA		; Get there with it
0415   0180 47          		LD   B,A	; Save the converted high nybble
0416   0181 79          		LD   A,C	; Now get the low order byte
0417   0182 D6 30       		SUB  $30	; Convert it down from Ascii
0418   0184 FE 0A       		CP   $0A	; 0-9 at this point?
0419   0186 38 02       		JR   C,BCTOA2	; Good enough then, but
0420   0188 D6 07       		SUB  $07	; Take off 7 more if it's A-F
0421   018A 80          BCTOA2		ADD  A,B	; Add in the high order nybble
0422   018B C9          		RET
0423   018C             
0424   018C             ;------------------------------------------------------------------------------
0425   018C             ; Get a character and echo it back to the user
0426   018C             ;------------------------------------------------------------------------------
0427   018C CD 71 00    ECHO		CALL	RDCHR
0428   018F CD 7D 00    		CALL	WRCHR
0429   0192 C9          		RET
0430   0193             
0431   0193             ;------------------------------------------------------------------------------
0432   0193             ; GOTO command
0433   0193             ;------------------------------------------------------------------------------
0434   0193 CD 45 01    M_GOTO		CALL GETHL		; ENTRY POINT FOR <G>oto addr. Get XXXX from user.
0435   0196 D8          		RET  C			; Return if invalid       	
0436   0197 E5          		PUSH HL
0437   0198 C9          		RET			; Jump to HL address value
0438   0199             
0439   0199             ;------------------------------------------------------------------------------
0440   0199             ; LOAD Intel Hex format file from the console.
0441   0199             ; [Intel Hex Format is:
0442   0199             ; 1) Colon (Frame 0)
0443   0199             ; 2) Record Length Field (Frames 1 and 2)
0444   0199             ; 3) Load Address Field (Frames 3,4,5,6)
0445   0199             ; 4) Record Type Field (Frames 7 and 8)
0446   0199             ; 5) Data Field (Frames 9 to 9+2*(Record Length)-1
0447   0199             ; 6) Checksum Field - Sum of all byte values from Record Length to and 
0448   0199             ;   including Checksum Field = 0 ]
0449   0199             ;------------------------------------------------------------------------------	
0450   0199 1E 00       LOAD		LD   E,0	; First two Characters is the Record Length Field
0451   019B CD 34 01    		CALL GET2	; Get us two characters into BC, convert it to a byte <A>
0452   019E 57          		LD   D,A	; Load Record Length count into D
0453   019F CD 34 01    		CALL GET2	; Get next two characters, Memory Load Address <H>
0454   01A2 67          		LD   H,A	; put value in H register.
0455   01A3 CD 34 01    		CALL GET2	; Get next two characters, Memory Load Address <L>
0456   01A6 6F          		LD   L,A	; put value in L register.
0457   01A7 CD 34 01    		CALL GET2	; Get next two characters, Record Field Type
0458   01AA FE 01       		CP   $01	; Record Field Type 00 is Data, 01 is End of File
0459   01AC 20 09       		JR   NZ,LOAD2	; Must be the end of that file
0460   01AE CD 34 01    		CALL GET2	; Get next two characters, assemble into byte
0461   01B1 7B          		LD   A,E	; Recall the Checksum byte
0462   01B2 A7          		AND  A		; Is it Zero?
0463   01B3 28 1E       		JR   Z,LOAD00	; Print footer reached message
0464   01B5 18 15       		JR   LOADERR	; Checksums don't add up, Error out
0465   01B7             		
0466   01B7 7A          LOAD2		LD   A,D	; Retrieve line character counter	
0467   01B8 A7          		AND  A		; Are we done with this line?
0468   01B9 28 0B       		JR   Z,LOAD3	; Get two more ascii characters, build a byte and checksum
0469   01BB CD 34 01    		CALL GET2	; Get next two chars, convert to byte in A, checksum it
0470   01BE 77          		LD   (HL),A	; Move converted byte in A to memory location
0471   01BF 23          		INC  HL		; Increment pointer to next memory location	
0472   01C0 3E 2E       		LD   A,'.'	; Print out a "." for every byte loaded
0473   01C2 CF          		RST  08H	;
0474   01C3 15          		DEC  D		; Decrement line character counter
0475   01C4 18 F1       		JR   LOAD2	; and keep loading into memory until line is complete
0476   01C6             		
0477   01C6 CD 34 01    LOAD3		CALL GET2	; Get two chars, build byte and checksum
0478   01C9 7B          		LD   A,E	; Check the checksum value
0479   01CA A7          		AND  A		; Is it zero?
0480   01CB C8          		RET  Z
0481   01CC             
0482   01CC 21 54 03    LOADERR		LD   HL,CKSUMERR  ; Get "Checksum Error" message
0483   01CF CD 1B 01    		CALL M_PRINT	; Print Message from (HL) and terminate the load
0484   01D2 C9          		RET
0485   01D3             
0486   01D3 21 8A 03    LOAD00  	LD   HL,LDETXT	; Print load complete message
0487   01D6 CD 1B 01    		CALL M_PRINT
0488   01D9 C9          		RET
0489   01DA             
0490   01DA             ;------------------------------------------------------------------------------
0491   01DA             ; Start BASIC command
0492   01DA             ;------------------------------------------------------------------------------
0493   01DA             BASIC
0494   01DA 21 42 03        		LD HL,M_BASTXT
0495   01DD CD 1B 01    		CALL M_PRINT
0496   01E0 CD 29 01    		CALL M_GETCHR
0497   01E3 C8          		RET Z	; Cancel if CTRL-C
0498   01E4 E6 5F       		AND  $5F ; uppercase
0499   01E6 FE 43       		CP 'C'
0500   01E8 CA 95 03    		JP  Z,COLD
0501   01EB FE 57       		CP 'W'
0502   01ED CA 98 03    		JP  Z,WARM
0503   01F0 C9          		RET
0504   01F1             
0505   01F1             ;------------------------------------------------------------------------------
0506   01F1             ; CP/M load command
0507   01F1             ;------------------------------------------------------------------------------
0508   01F1             CPMLOAD
0509   01F1             
0510   01F1 21 03 02        	LD HL,CPMTXT
0511   01F4 CD 1B 01    		CALL M_PRINT
0512   01F7 CD 29 01    		CALL M_GETCHR
0513   01FA C8          		RET Z	; Cancel if CTRL-C
0514   01FB E6 5F       		AND  $5F ; uppercase
0515   01FD FE 59       		CP 'Y'
0516   01FF CA 24 02    		JP  Z,CPMLOAD2
0517   0202 C9          		RET
0518   0203             CPMTXT
0519   0203 0D 0A       		.BYTE	$0D,$0A
0520   0205 426F6F742043		.TEXT	"Boot CP/M?"
0520   020B 502F4D3F
0521   020F 00          		.BYTE	$00
0522   0210             
0523   0210             CPMTXT2
0524   0210 0D 0A       		.BYTE	$0D,$0A
0525   0212 4C6F6164696E		.TEXT	"Loading CP/M..."
0525   0218 672043502F4D2E2E2E
0526   0221 0D 0A 00    		.BYTE	$0D,$0A,$00
0527   0224             
0528   0224             CPMLOAD2
0529   0224 21 10 02        	LD HL,CPMTXT2
0530   0227 CD 1B 01    		CALL M_PRINT
0531   022A             		
0532   022A 06 18       		LD	B,numSecs
0533   022C             
0534   022C 3E 00       		LD	A,0
0535   022E 32 04 30    		LD	(lba0),A
0536   0231 32 05 30    		ld 	(lba1),A
0537   0234 32 06 30    		ld 	(lba2),A
0538   0237 32 07 30    		ld 	(lba3),A
0539   023A             		
0540   023A 21 00 D0    		LD	HL,loadAddr
0541   023D 22 02 30    		LD	(dmaAddr),HL
0542   0240             processSectors:
0543   0240             
0544   0240 CD 6E 02    		call	readhst
0545   0243             
0546   0243 11 00 02    		LD	DE,0200H
0547   0246 2A 02 30    		LD	HL,(dmaAddr)
0548   0249 19          		ADD	HL,DE
0549   024A 22 02 30    		LD	(dmaAddr),HL
0550   024D 3A 04 30    		LD	A,(lba0)
0551   0250 3C          		INC	A
0552   0251 32 04 30    		LD	(lba0),A
0553   0254             
0554   0254 10 EA       		djnz	processSectors
0555   0256             
0556   0256             ; Start CP/M using entry at top of BIOS
0557   0256             ; The current active console stream ID is pushed onto the stack
0558   0256             ; to allow the CBIOS to pick it up
0559   0256             ; 0 = ACIA0, 1 = ACIA1
0560   0256             		
0561   0256 3A 00 30    		ld	A,(primaryIO)
0562   0259 F5          		PUSH	AF
0563   025A 2A FE FF    		ld	HL,($FFFE)
0564   025D E9          		jp	(HL)
0565   025E             
0566   025E             
0567   025E             ;------------------------------------------------------------------------------
0568   025E             ; ROUTINES AS USED IN BIOS
0569   025E             ;------------------------------------------------------------------------------
0570   025E             
0571   025E             ;================================================================================================
0572   025E             ; Convert track/head/sector into LBA for physical access to the disk
0573   025E             ;================================================================================================
0574   025E             setLBAaddr:	
0575   025E             		; Transfer LBA to disk (LBA3 not used on SD card)
0576   025E 3A 06 30    		LD	A,(lba2)
0577   0261 D3 8C       		OUT	(SD_LBA2),A
0578   0263 3A 05 30    		LD	A,(lba1)
0579   0266 D3 8B       		OUT	(SD_LBA1),A
0580   0268 3A 04 30    		LD	A,(lba0)
0581   026B D3 8A       		OUT	(SD_LBA0),A
0582   026D C9          		RET
0583   026E             		
0584   026E             ;================================================================================================
0585   026E             ; Read physical sector from host
0586   026E             ;================================================================================================
0587   026E             
0588   026E             readhst:
0589   026E F5          		PUSH 	AF
0590   026F C5          		PUSH 	BC
0591   0270 E5          		PUSH 	HL
0592   0271             
0593   0271 DB 89       rdWait1: IN	A,(SD_STATUS)
0594   0273 FE 80       		CP	128
0595   0275 20 FA       		JR	NZ,rdWait1
0596   0277             		
0597   0277 CD 5E 02    		CALL 	setLBAaddr
0598   027A             		
0599   027A 3E 00       		LD	A,$00	; 00 = Read block
0600   027C D3 89       		OUT	(SD_CONTROL),A
0601   027E             
0602   027E 0E 04       		LD 	c,4
0603   0280             ;		LD 	HL,hstbuf
0604   0280             rd4secs:
0605   0280 06 80       		LD 	b,128
0606   0282             rdByte:
0607   0282             
0608   0282 DB 89       rdWait2: IN	A,(SD_STATUS)
0609   0284 FE E0       		CP	224	; Read byte waiting
0610   0286 20 FA       		JR	NZ,rdWait2
0611   0288             
0612   0288 DB 88       		IN	A,(SD_DATA)
0613   028A             
0614   028A 77          		LD 	(HL),A
0615   028B 23          		INC 	HL
0616   028C 05          		dec 	b
0617   028D 20 F3       		JR 	NZ, rdByte
0618   028F 0D          		dec 	c
0619   0290 20 EE       		JR 	NZ,rd4secs
0620   0292             
0621   0292 E1          		POP 	HL
0622   0293 C1          		POP 	BC
0623   0294 F1          		POP 	AF
0624   0295             
0625   0295             ;		XOR 	a
0626   0295             ;		ld	(erflag),a
0627   0295 C9          		RET
0628   0296             
0629   0296             ;------------------------------------------------------------------------------
0630   0296             ; END OF ROUTINES AS USED IN BIOS
0631   0296             ;------------------------------------------------------------------------------
0632   0296             
0633   0296             
0634   0296 43502F4D2042M_SIGNON	.BYTE	"CP/M Boot ROM 2.0"
0634   029C 6F6F7420524F4D20322E30
0635   02A7 20627920472E		.BYTE	" by G. Searle"
0635   02AD 20536561726C65
0636   02B4 0D 0A       		.BYTE	$0D,$0A
0637   02B6 0D 0A       		.BYTE	$0D,$0A
0638   02B8 4243206F7220		.TEXT	"BC or BW - ROM BASIC Cold/Warm"
0638   02BE 4257202D20524F4D20424153494320436F6C642F5761726D
0639   02D6 0D 0A       		.BYTE	$0D,$0A
0640   02D8 582020202020		.TEXT	"X        - Boot CP/M (load $D000-$FFFF)"
0640   02DE 2020202D20426F6F742043502F4D20286C6F61642024443030302D244646464629
0641   02FF 0D 0A       		.BYTE	$0D,$0A
0642   0301 3A6E6E6E6E2E		.TEXT	":nnnn... - Load Intel-Hex file record"
0642   0307 2E2E202D204C6F616420496E74656C2D4865782066696C65207265636F7264
0643   0326 0D 0A       		.BYTE	$0D,$0A
0644   0328 476E6E6E6E20		.TEXT	"Gnnnn    - Run loc nnnn"
0644   032E 2020202D2052756E206C6F63206E6E6E6E
0645   033F 0D 0A       		.BYTE	$0D,$0A
0646   0341 00                 	.BYTE   $00
0647   0342             
0648   0342             M_BASTXT
0649   0342 0D 0A       		.BYTE	$0D,$0A
0650   0344 436F6C64206F		.TEXT	"Cold or warm?"
0650   034A 72207761726D3F
0651   0351 0D 0A 00    		.BYTE	$0D,$0A,$00
0652   0354             
0653   0354 436865636B73CKSUMERR	.BYTE	"Checksum error"
0653   035A 756D206572726F72
0654   0362 0D 0A 00    		.BYTE	$0D,$0A,$00
0655   0365             
0656   0365             INITTXT  
0657   0365 0C          		.BYTE	$0C
0658   0366 507265737320		.TEXT	"Press [SPACE] to activate console"
0658   036C 5B53504143455D20746F20616374697661746520636F6E736F6C65
0659   0387 0D 0A 00    		.BYTE	$0D,$0A, $00
0660   038A             
0661   038A             LDETXT  
0662   038A 436F6D706C65		.TEXT	"Complete"
0662   0390 7465
0663   0392 0D 0A 00    		.BYTE	$0D,$0A, $00
0664   0395             
0665   0395             ;===========================================================================================================================
0666   0395             
0667   0395             ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
0668   0395             ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
0669   0395             ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
0670   0395             ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
0671   0395             ; the original ROM code (checksum A934H). PA
0672   0395             
0673   0395             ; GENERAL EQUATES
0674   0395             
0675   0395             CTRLC   .EQU    03H             ; Control "C"
0676   0395             CTRLG   .EQU    07H             ; Control "G"
0677   0395             BKSP    .EQU    08H             ; Back space
0678   0395             LF      .EQU    0AH             ; Line feed
0679   0395             CS      .EQU    0CH             ; Clear screen
0680   0395             CR      .EQU    0DH             ; Carriage return
0681   0395             CTRLO   .EQU    0FH             ; Control "O"
0682   0395             CTRLQ	.EQU	11H		        ; Control "Q"
0683   0395             CTRLR   .EQU    12H             ; Control "R"
0684   0395             CTRLS   .EQU    13H             ; Control "S"
0685   0395             CTRLU   .EQU    15H             ; Control "U"
0686   0395             ESC     .EQU    1BH             ; Escape
0687   0395             DEL     .EQU    7FH             ; Delete
0688   0395             
0689   0395             ; BASIC WORK SPACE LOCATIONS
0690   0395             
0691   0395             WRKSPC  .EQU    30B0H             ; BASIC Work space
0692   0395             USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
0693   0395             OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
0694   0395             OTPORT  .EQU    WRKSPC+7H           ; Port (p)
0695   0395             DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
0696   0395             DIV1    .EQU    WRKSPC+0AH           ; <- Values
0697   0395             DIV2    .EQU    WRKSPC+0EH           ; <-   to
0698   0395             DIV3    .EQU    WRKSPC+12H           ; <-   be
0699   0395             DIV4    .EQU    WRKSPC+15H           ; <-inserted
0700   0395             SEED    .EQU    WRKSPC+17H           ; Random number seed
0701   0395             LSTRND  .EQU    WRKSPC+3AH           ; Last random number
0702   0395             INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
0703   0395             INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
0704   0395             NULLS   .EQU    WRKSPC+41H           ; Number of nulls
0705   0395             LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
0706   0395             COMMAN  .EQU    WRKSPC+43H           ; Width for commas
0707   0395             NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
0708   0395             CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
0709   0395             LINESC  .EQU    WRKSPC+46H           ; Lines counter
0710   0395             LINESN  .EQU    WRKSPC+48H           ; Lines number
0711   0395             CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
0712   0395             NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
0713   0395             BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
0714   0395             RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
0715   0395             POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
0716   0395             PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
0717   0395             RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
0718   0395             STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
0719   0395             LINEAT  .EQU    WRKSPC+5CH           ; Current line number
0720   0395             BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
0721   0395             BUFFER  .EQU    WRKSPC+61H           ; Input buffer
0722   0395             STACK   .EQU    WRKSPC+66H           ; Initial stack
0723   0395             CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
0724   0395             LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
0725   0395             TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
0726   0395             DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
0727   0395             LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
0728   0395             TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
0729   0395             TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
0730   0395             TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
0731   0395             STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
0732   0395             CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
0733   0395             LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
0734   0395             DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
0735   0395             FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
0736   0395             LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
0737   0395             READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
0738   0395             BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
0739   0395             NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
0740   0395             ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
0741   0395             CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
0742   0395             PROGND  .EQU    WRKSPC+0D6H          ; End of program
0743   0395             VAREND  .EQU    WRKSPC+0D8H          ; End of variables
0744   0395             ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
0745   0395             NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
0746   0395             FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
0747   0395             FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
0748   0395             FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
0749   0395             FPEXP   .EQU    FPREG+3         ; Floating point exponent
0750   0395             SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
0751   0395             PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
0752   0395             MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
0753   0395             PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area
0754   0395             STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
0755   0395             
0756   0395             ; BASIC ERROR CODE VALUES
0757   0395             
0758   0395             NF      .EQU    00H             ; NEXT without FOR
0759   0395             SN      .EQU    02H             ; Syntax error
0760   0395             RG      .EQU    04H             ; RETURN without GOSUB
0761   0395             OD      .EQU    06H             ; Out of DATA
0762   0395             FC      .EQU    08H             ; Function call error
0763   0395             OV      .EQU    0AH             ; Overflow
0764   0395             OM      .EQU    0CH             ; Out of memory
0765   0395             UL      .EQU    0EH             ; Undefined line number
0766   0395             BS      .EQU    10H             ; Bad subscript
0767   0395             DD      .EQU    12H             ; Re-DIMensioned array
0768   0395             DZ      .EQU    14H             ; Division by zero (/0)
0769   0395             ID      .EQU    16H             ; Illegal direct
0770   0395             TM      .EQU    18H             ; Type miss-match
0771   0395             OS      .EQU    1AH             ; Out of string space
0772   0395             LS      .EQU    1CH             ; String too long
0773   0395             ST      .EQU    1EH             ; String formula too complex
0774   0395             CN      .EQU    20H             ; Can't CONTinue
0775   0395             UF      .EQU    22H             ; UnDEFined FN function
0776   0395             MO      .EQU    24H             ; Missing operand
0777   0395             HX      .EQU    26H             ; HEX error
0778   0395             BN      .EQU    28H             ; BIN error
0779   0395             
0780   0395             ;        .ORG    00396H
0781   0395             
0782   0395 C3 9B 03    COLD:   JP      STARTB          ; Jump for cold start
0783   0398 C3 39 04    WARM:   JP      WARMST          ; Jump for warm start
0784   039B             STARTB: 
0785   039B DD 21 00 00         LD      IX,0            ; Flag cold start
0786   039F C3 A6 03            JP      CSTART          ; Jump to initialise
0787   03A2             
0788   03A2 4C 0C               .WORD   DEINT           ; Get integer -32768 to 32767
0789   03A4 C2 13               .WORD   ABPASS          ; Return integer in AB
0790   03A6             
0791   03A6             
0792   03A6 21 B0 30    CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
0793   03A9 F9                  LD      SP,HL           ; Set up a temporary stack
0794   03AA C3 E1 1F            JP      INITST          ; Go to initialise
0795   03AD             
0796   03AD 11 73 06    INIT:   LD      DE,INITAB       ; Initialise workspace
0797   03B0 06 63               LD      B,INITBE-INITAB+3; Bytes to copy
0798   03B2 21 B0 30            LD      HL,WRKSPC       ; Into workspace RAM
0799   03B5 1A          COPY:   LD      A,(DE)          ; Get source
0800   03B6 77                  LD      (HL),A          ; To destination
0801   03B7 23                  INC     HL              ; Next destination
0802   03B8 13                  INC     DE              ; Next source
0803   03B9 05                  DEC     B               ; Count bytes
0804   03BA C2 B5 03            JP      NZ,COPY         ; More to move
0805   03BD F9                  LD      SP,HL           ; Temporary stack
0806   03BE CD 74 08            CALL    CLREG           ; Clear registers and stack
0807   03C1 CD 42 0E            CALL    PRNTCRLF        ; Output CRLF
0808   03C4 32 5A 31            LD      (BUFFER+72+1),A ; Mark end of buffer
0809   03C7 32 A9 31            LD      (PROGST),A      ; Initialise program area
0810   03CA 21 88 04    MSIZE:  LD      HL,MEMMSG       ; Point to message
0811   03CD CD E0 14            CALL    PRS             ; Output "Memory size"
0812   03D0 CD 91 08            CALL    PROMPT          ; Get input with '?'
0813   03D3 CD 9A 0B            CALL    GETCHR          ; Get next character
0814   03D6 B7                  OR      A               ; Set flags
0815   03D7 C2 EF 03            JP      NZ,TSTMEM       ; If number - Test if RAM there
0816   03DA 21 0D 32            LD      HL,STLOOK       ; Point to start of RAM
0817   03DD 23          MLOOP:  INC     HL              ; Next byte
0818   03DE 7C                  LD      A,H             ; Above address FFFF ?
0819   03DF B5                  OR      L
0820   03E0 CA 01 04            JP      Z,SETTOP        ; Yes - 64K RAM
0821   03E3 7E                  LD      A,(HL)          ; Get contents
0822   03E4 47                  LD      B,A             ; Save it
0823   03E5 2F                  CPL                     ; Flip all bits
0824   03E6 77                  LD      (HL),A          ; Put it back
0825   03E7 BE                  CP      (HL)            ; RAM there if same
0826   03E8 70                  LD      (HL),B          ; Restore old contents
0827   03E9 CA DD 03            JP      Z,MLOOP         ; If RAM - test next byte
0828   03EC C3 01 04            JP      SETTOP          ; Top of RAM found
0829   03EF             
0830   03EF CD 66 0C    TSTMEM: CALL    ATOH            ; Get high memory into DE
0831   03F2 B7                  OR      A               ; Set flags on last byte
0832   03F3 C2 42 07            JP      NZ,SNERR        ; ?SN Error if bad character
0833   03F6 EB                  EX      DE,HL           ; Address into HL
0834   03F7 2B                  DEC     HL              ; Back one byte
0835   03F8 3E D9               LD      A,11011001B     ; Test byte
0836   03FA 46                  LD      B,(HL)          ; Get old contents
0837   03FB 77                  LD      (HL),A          ; Load test byte
0838   03FC BE                  CP      (HL)            ; RAM there if same
0839   03FD 70                  LD      (HL),B          ; Restore old contents
0840   03FE C2 CA 03            JP      NZ,MSIZE        ; Ask again if no RAM
0841   0401             
0842   0401 2B          SETTOP: DEC     HL              ; Back one byte
0843   0402 11 0C 32            LD      DE,STLOOK-1     ; See if enough RAM
0844   0405 CD 0A 0A            CALL    CPDEHL          ; Compare DE with HL
0845   0408 DA CA 03            JP      C,MSIZE         ; Ask again if not enough RAM
0846   040B 11 CE FF            LD      DE,0-50         ; 50 Bytes string space
0847   040E 22 5F 31            LD      (LSTRAM),HL     ; Save last available RAM
0848   0411 19                  ADD     HL,DE           ; Allocate string space
0849   0412 22 0A 31            LD      (STRSPC),HL     ; Save string space
0850   0415 CD 4F 08            CALL    CLRPTR          ; Clear program area
0851   0418 2A 0A 31            LD      HL,(STRSPC)     ; Get end of memory
0852   041B 11 EF FF            LD      DE,0-17         ; Offset for free bytes
0853   041E 19                  ADD     HL,DE           ; Adjust HL
0854   041F 11 A9 31            LD      DE,PROGST       ; Start of program text
0855   0422 7D                  LD      A,L             ; Get LSB
0856   0423 93                  SUB     E               ; Adjust it
0857   0424 6F                  LD      L,A             ; Re-save
0858   0425 7C                  LD      A,H             ; Get MSB
0859   0426 9A                  SBC     A,D             ; Adjust it
0860   0427 67                  LD      H,A             ; Re-save
0861   0428 E5                  PUSH    HL              ; Save bytes free
0862   0429 21 51 04            LD      HL,SIGNON       ; Sign-on message
0863   042C CD E0 14            CALL    PRS             ; Output string
0864   042F E1                  POP     HL              ; Get bytes free back
0865   0430 CD 83 1B            CALL    PRNTHL          ; Output amount of free memory
0866   0433 21 42 04            LD      HL,BFREE        ; " Bytes free" message
0867   0436 CD E0 14            CALL    PRS             ; Output string
0868   0439             
0869   0439 31 16 31    WARMST: LD      SP,STACK        ; Temporary stack
0870   043C CD 74 08    BRKRET: CALL    CLREG           ; Clear registers and stack
0871   043F C3 8D 07            JP      PRNTOK          ; Go to get command line
0872   0442             
0873   0442 204279746573BFREE:  .BYTE   " Bytes free",CR,LF,0,0
0873   0448 20667265650D0A0000
0874   0451             
0875   0451 5A3830204241SIGNON: .BYTE   "Z80 BASIC Ver 4.7b",CR,LF
0875   0457 5349432056657220342E37620D0A
0876   0465 436F70797269        .BYTE   "Copyright ",40,"C",41
0876   046B 67687420284329
0877   0472 203139373820        .BYTE   " 1978 by Microsoft",CR,LF,0,0
0877   0478 6279204D6963726F736F66740D0A0000
0878   0488             
0879   0488 4D656D6F7279MEMMSG: .BYTE   "Memory top",0
0879   048E 20746F7000
0880   0493             
0881   0493             ; FUNCTION ADDRESS TABLE
0882   0493             
0883   0493 F8 19       FNCTAB: .WORD   SGN
0884   0495 BC 1A               .WORD   INT
0885   0497 0E 1A               .WORD   ABS
0886   0499 B3 30               .WORD   USR
0887   049B A0 13               .WORD   FRE
0888   049D 25 17               .WORD   INP
0889   049F CE 13               .WORD   POS
0890   04A1 82 1C               .WORD   SQR
0891   04A3 61 1D               .WORD   RND
0892   04A5 9D 18               .WORD   LOG
0893   04A7 D0 1C               .WORD   EXP
0894   04A9 D6 1D               .WORD   COS
0895   04AB DC 1D               .WORD   SIN
0896   04AD 3D 1E               .WORD   TAN
0897   04AF 52 1E               .WORD   ATN
0898   04B1 79 17               .WORD   PEEK
0899   04B3 BD 1E               .WORD   DEEK
0900   04B5 01 31               .WORD   POINT
0901   04B7 52 16               .WORD   LEN
0902   04B9 6A 14               .WORD   STR
0903   04BB EC 16               .WORD   VAL
0904   04BD 61 16               .WORD   ASC
0905   04BF 72 16               .WORD   CHR
0906   04C1 DF 1E               .WORD   HEX
0907   04C3 72 1F               .WORD   BIN
0908   04C5 82 16               .WORD   LEFT
0909   04C7 B2 16               .WORD   RIGHT
0910   04C9 BC 16               .WORD   MID
0911   04CB             
0912   04CB             ; RESERVED WORD LIST
0913   04CB             
0914   04CB C5 4E 44    WORDS:  .BYTE   'E'+80H,"ND"
0915   04CE C6 4F 52            .BYTE   'F'+80H,"OR"
0916   04D1 CE 45 58 54         .BYTE   'N'+80H,"EXT"
0917   04D5 C4 41 54 41         .BYTE   'D'+80H,"ATA"
0918   04D9 C94E505554          .BYTE   'I'+80H,"NPUT"
0919   04DE C4 49 4D            .BYTE   'D'+80H,"IM"
0920   04E1 D2 45 41 44         .BYTE   'R'+80H,"EAD"
0921   04E5 CC 45 54            .BYTE   'L'+80H,"ET"
0922   04E8 C7 4F 54 4F         .BYTE   'G'+80H,"OTO"
0923   04EC D2 55 4E            .BYTE   'R'+80H,"UN"
0924   04EF C9 46               .BYTE   'I'+80H,"F"
0925   04F1 D24553544F52        .BYTE   'R'+80H,"ESTORE"
0925   04F7 45
0926   04F8 C74F535542          .BYTE   'G'+80H,"OSUB"
0927   04FD D2455455524E        .BYTE   'R'+80H,"ETURN"
0928   0503 D2 45 4D            .BYTE   'R'+80H,"EM"
0929   0506 D3 54 4F 50         .BYTE   'S'+80H,"TOP"
0930   050A CF 55 54            .BYTE   'O'+80H,"UT"
0931   050D CF 4E               .BYTE   'O'+80H,"N"
0932   050F CE 55 4C 4C         .BYTE   'N'+80H,"ULL"
0933   0513 D7 41 49 54         .BYTE   'W'+80H,"AIT"
0934   0517 C4 45 46            .BYTE   'D'+80H,"EF"
0935   051A D0 4F 4B 45         .BYTE   'P'+80H,"OKE"
0936   051E C4 4F 4B 45         .BYTE   'D'+80H,"OKE"
0937   0522 D3435245454E        .BYTE   'S'+80H,"CREEN"
0938   0528 CC494E4553          .BYTE   'L'+80H,"INES"
0939   052D C3 4C 53            .BYTE   'C'+80H,"LS"
0940   0530 D749445448          .BYTE   'W'+80H,"IDTH"
0941   0535 CD4F4E49544F        .BYTE   'M'+80H,"ONITOR"
0941   053B 52
0942   053C D3 45 54            .BYTE   'S'+80H,"ET"
0943   053F D245534554          .BYTE   'R'+80H,"ESET"
0944   0544 D052494E54          .BYTE   'P'+80H,"RINT"
0945   0549 C3 4F 4E 54         .BYTE   'C'+80H,"ONT"
0946   054D CC 49 53 54         .BYTE   'L'+80H,"IST"
0947   0551 C34C454152          .BYTE   'C'+80H,"LEAR"
0948   0556 C34C4F4144          .BYTE   'C'+80H,"LOAD"
0949   055B C353415645          .BYTE   'C'+80H,"SAVE"
0950   0560 CE 45 57            .BYTE   'N'+80H,"EW"
0951   0563             
0952   0563 D4 41 42 28         .BYTE   'T'+80H,"AB("
0953   0567 D4 4F               .BYTE   'T'+80H,"O"
0954   0569 C6 4E               .BYTE   'F'+80H,"N"
0955   056B D3 50 43 28         .BYTE   'S'+80H,"PC("
0956   056F D4 48 45 4E         .BYTE   'T'+80H,"HEN"
0957   0573 CE 4F 54            .BYTE   'N'+80H,"OT"
0958   0576 D3 54 45 50         .BYTE   'S'+80H,"TEP"
0959   057A             
0960   057A AB                  .BYTE   '+'+80H
0961   057B AD                  .BYTE   '-'+80H
0962   057C AA                  .BYTE   '*'+80H
0963   057D AF                  .BYTE   '/'+80H
0964   057E DE                  .BYTE   '^'+80H
0965   057F C1 4E 44            .BYTE   'A'+80H,"ND"
0966   0582 CF 52               .BYTE   'O'+80H,"R"
0967   0584 BE                  .BYTE   '>'+80H
0968   0585 BD                  .BYTE   '='+80H
0969   0586 BC                  .BYTE   '<'+80H
0970   0587             
0971   0587 D3 47 4E            .BYTE   'S'+80H,"GN"
0972   058A C9 4E 54            .BYTE   'I'+80H,"NT"
0973   058D C1 42 53            .BYTE   'A'+80H,"BS"
0974   0590 D5 53 52            .BYTE   'U'+80H,"SR"
0975   0593 C6 52 45            .BYTE   'F'+80H,"RE"
0976   0596 C9 4E 50            .BYTE   'I'+80H,"NP"
0977   0599 D0 4F 53            .BYTE   'P'+80H,"OS"
0978   059C D3 51 52            .BYTE   'S'+80H,"QR"
0979   059F D2 4E 44            .BYTE   'R'+80H,"ND"
0980   05A2 CC 4F 47            .BYTE   'L'+80H,"OG"
0981   05A5 C5 58 50            .BYTE   'E'+80H,"XP"
0982   05A8 C3 4F 53            .BYTE   'C'+80H,"OS"
0983   05AB D3 49 4E            .BYTE   'S'+80H,"IN"
0984   05AE D4 41 4E            .BYTE   'T'+80H,"AN"
0985   05B1 C1 54 4E            .BYTE   'A'+80H,"TN"
0986   05B4 D0 45 45 4B         .BYTE   'P'+80H,"EEK"
0987   05B8 C4 45 45 4B         .BYTE   'D'+80H,"EEK"
0988   05BC D04F494E54          .BYTE   'P'+80H,"OINT"
0989   05C1 CC 45 4E            .BYTE   'L'+80H,"EN"
0990   05C4 D3 54 52 24         .BYTE   'S'+80H,"TR$"
0991   05C8 D6 41 4C            .BYTE   'V'+80H,"AL"
0992   05CB C1 53 43            .BYTE   'A'+80H,"SC"
0993   05CE C3 48 52 24         .BYTE   'C'+80H,"HR$"
0994   05D2 C8 45 58 24         .BYTE   'H'+80H,"EX$"
0995   05D6 C2 49 4E 24         .BYTE   'B'+80H,"IN$"
0996   05DA CC45465424          .BYTE   'L'+80H,"EFT$"
0997   05DF D24947485424        .BYTE   'R'+80H,"IGHT$"
0998   05E5 CD 49 44 24         .BYTE   'M'+80H,"ID$"
0999   05E9 80                  .BYTE   80H             ; End of list marker
1000   05EA             
1001   05EA             ; KEYWORD ADDRESS TABLE
1002   05EA             
1003   05EA E4 0B       WORDTB: .WORD   PEND
1004   05EC E1 0A               .WORD   FOR
1005   05EE BC 0F               .WORD   NEXT
1006   05F0 31 0D               .WORD   DATA
1007   05F2 C3 0E               .WORD   INPUT
1008   05F4 F8 11               .WORD   DIM
1009   05F6 F2 0E               .WORD   READ
1010   05F8 48 0D               .WORD   LET
1011   05FA EE 0C               .WORD   GOTO
1012   05FC D1 0C               .WORD   RUN
1013   05FE C0 0D               .WORD   IF
1014   0600 AA 0B               .WORD   RESTOR
1015   0602 DD 0C               .WORD   GOSUB
1016   0604 0C 0D               .WORD   RETURN
1017   0606 33 0D               .WORD   REM
1018   0608 E2 0B               .WORD   STOP
1019   060A 31 17               .WORD   POUT
1020   060C A2 0D               .WORD   ON
1021   060E 23 0C               .WORD   NULL
1022   0610 37 17               .WORD   WAIT
1023   0612 D6 13               .WORD   DEF
1024   0614 80 17               .WORD   POKE
1025   0616 C8 1E               .WORD   DOKE
1026   0618 33 0D               .WORD   REM
1027   061A AE 1E               .WORD   LINES
1028   061C A1 1E               .WORD   CLS
1029   061E A6 1E               .WORD   WIDTH
1030   0620 DE 1F               .WORD   MONITR
1031   0622 04 31               .WORD   PSET
1032   0624 07 31               .WORD   RESET
1033   0626 E4 0D               .WORD   PRINT
1034   0628 10 0C               .WORD   CONT
1035   062A 56 0A               .WORD   LIST
1036   062C 8B 0C               .WORD   CLEAR
1037   062E 33 0D               .WORD   REM
1038   0630 33 0D               .WORD   REM
1039   0632 4E 08               .WORD   NEW
1040   0634             
1041   0634             ; RESERVED WORD TOKEN VALUES
1042   0634             
1043   0634             ZEND    .EQU    080H            ; END
1044   0634             ZFOR    .EQU    081H            ; FOR
1045   0634             ZDATA   .EQU    083H            ; DATA
1046   0634             ZGOTO   .EQU    088H            ; GOTO
1047   0634             ZGOSUB  .EQU    08CH            ; GOSUB
1048   0634             ZREM    .EQU    08EH            ; REM
1049   0634             ZPRINT  .EQU    09EH            ; PRINT
1050   0634             ZNEW    .EQU    0A4H            ; NEW
1051   0634             
1052   0634             ZTAB    .EQU    0A5H            ; TAB
1053   0634             ZTO     .EQU    0A6H            ; TO
1054   0634             ZFN     .EQU    0A7H            ; FN
1055   0634             ZSPC    .EQU    0A8H            ; SPC
1056   0634             ZTHEN   .EQU    0A9H            ; THEN
1057   0634             ZNOT    .EQU    0AAH            ; NOT
1058   0634             ZSTEP   .EQU    0ABH            ; STEP
1059   0634             
1060   0634             ZPLUS   .EQU    0ACH            ; +
1061   0634             ZMINUS  .EQU    0ADH            ; -
1062   0634             ZTIMES  .EQU    0AEH            ; *
1063   0634             ZDIV    .EQU    0AFH            ; /
1064   0634             ZOR     .EQU    0B2H            ; OR
1065   0634             ZGTR    .EQU    0B3H            ; >
1066   0634             ZEQUAL  .EQU    0B4H            ; M
1067   0634             ZLTH    .EQU    0B5H            ; <
1068   0634             ZSGN    .EQU    0B6H            ; SGN
1069   0634             ZPOINT  .EQU    0C7H            ; POINT
1070   0634             ZLEFT   .EQU    0CDH +2         ; LEFT$
1071   0634             
1072   0634             ; ARITHMETIC PRECEDENCE TABLE
1073   0634             
1074   0634 79          PRITAB: .BYTE   79H             ; Precedence value
1075   0635 6A 1B               .WORD   PADD            ; FPREG = <last> + FPREG
1076   0637             
1077   0637 79                  .BYTE   79H             ; Precedence value
1078   0638 9E 17               .WORD   PSUB            ; FPREG = <last> - FPREG
1079   063A             
1080   063A 7C                  .BYTE   7CH             ; Precedence value
1081   063B DC 18               .WORD   MULT            ; PPREG = <last> * FPREG
1082   063D             
1083   063D 7C                  .BYTE   7CH             ; Precedence value
1084   063E 3D 19               .WORD   DIV             ; FPREG = <last> / FPREG
1085   0640             
1086   0640 7F                  .BYTE   7FH             ; Precedence value
1087   0641 8B 1C               .WORD   POWER           ; FPREG = <last> ^ FPREG
1088   0643             
1089   0643 50                  .BYTE   50H             ; Precedence value
1090   0644 51 11               .WORD   PAND            ; FPREG = <last> AND FPREG
1091   0646             
1092   0646 46                  .BYTE   46H             ; Precedence value
1093   0647 50 11               .WORD   POR             ; FPREG = <last> OR FPREG
1094   0649             
1095   0649             ; BASIC ERROR CODE LIST
1096   0649             
1097   0649 4E 46       ERRORS: .BYTE   "NF"            ; NEXT without FOR
1098   064B 53 4E               .BYTE   "SN"            ; Syntax error
1099   064D 52 47               .BYTE   "RG"            ; RETURN without GOSUB
1100   064F 4F 44               .BYTE   "OD"            ; Out of DATA
1101   0651 46 43               .BYTE   "FC"            ; Illegal function call
1102   0653 4F 56               .BYTE   "OV"            ; Overflow error
1103   0655 4F 4D               .BYTE   "OM"            ; Out of memory
1104   0657 55 4C               .BYTE   "UL"            ; Undefined line
1105   0659 42 53               .BYTE   "BS"            ; Bad subscript
1106   065B 44 44               .BYTE   "DD"            ; Re-DIMensioned array
1107   065D 2F 30               .BYTE   "/0"            ; Division by zero
1108   065F 49 44               .BYTE   "ID"            ; Illegal direct
1109   0661 54 4D               .BYTE   "TM"            ; Type mis-match
1110   0663 4F 53               .BYTE   "OS"            ; Out of string space
1111   0665 4C 53               .BYTE   "LS"            ; String too long
1112   0667 53 54               .BYTE   "ST"            ; String formula too complex
1113   0669 43 4E               .BYTE   "CN"            ; Can't CONTinue
1114   066B 55 46               .BYTE   "UF"            ; Undefined FN function
1115   066D 4D 4F               .BYTE   "MO"            ; Missing operand
1116   066F 48 58               .BYTE   "HX"            ; HEX error
1117   0671 42 4E               .BYTE   "BN"            ; BIN error
1118   0673             
1119   0673             ; INITIALISATION TABLE -------------------------------------------------------
1120   0673             
1121   0673 C3 39 04    INITAB: JP      WARMST          ; Warm start jump
1122   0676 C3 61 0C            JP      FCERR           ; "USR (X)" jump (Set to Error)
1123   0679 D3 00               OUT     (0),A           ; "OUT p,n" skeleton
1124   067B C9                  RET
1125   067C D6 00               SUB     0               ; Division support routine
1126   067E 6F                  LD      L,A
1127   067F 7C                  LD      A,H
1128   0680 DE 00               SBC     A,0
1129   0682 67                  LD      H,A
1130   0683 78                  LD      A,B
1131   0684 DE 00               SBC     A,0
1132   0686 47                  LD      B,A
1133   0687 3E 00               LD      A,0
1134   0689 C9                  RET
1135   068A 00 00 00            .BYTE   0,0,0                   ; Random number seed table used by RND
1136   068D 35 4A CA 99         .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
1137   0691 39 1C 76 98         .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
1138   0695 22 95 B3 98         .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
1139   0699 0A DD 47 98         .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
1140   069D 53 D1 99 99         .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
1141   06A1 0A 1A 9F 98         .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
1142   06A5 65 BC CD 98         .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
1143   06A9 D6 77 3E 98         .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
1144   06AD 52 C7 4F 80         .BYTE   052H,0C7H,04FH,080H     ; Last random number
1145   06B1 DB 00               IN      A,(0)           ; INP (x) skeleton
1146   06B3 C9                  RET
1147   06B4 01                  .BYTE   1               ; POS (x) number (1)
1148   06B5 FF                  .BYTE   255             ; Terminal width (255 = no auto CRLF)
1149   06B6 1C                  .BYTE   28              ; Width for commas (3 columns)
1150   06B7 00                  .BYTE   0               ; No nulls after input bytes
1151   06B8 00                  .BYTE   0               ; Output enabled (^O off)
1152   06B9 14 00               .WORD   20              ; Initial lines counter
1153   06BB 14 00               .WORD   20              ; Initial lines number
1154   06BD 00 00               .WORD   0               ; Array load/save check sum
1155   06BF 00                  .BYTE   0               ; Break not by NMI
1156   06C0 00                  .BYTE   0               ; Break flag
1157   06C1 C3 87 09            JP      TTYLIN          ; Input reflection (set to TTY)
1158   06C4 C3 00 00            JP      $0000           ; POINT reflection unused
1159   06C7 C3 00 00            JP      $0000           ; SET reflection
1160   06CA C3 00 00            JP      $0000          	; RESET reflection
1161   06CD 0D 32               .WORD   STLOOK          ; Temp string space
1162   06CF FE FF               .WORD   -2              ; Current line number (cold)
1163   06D1 AA 31               .WORD   PROGST+1        ; Start of program text
1164   06D3             INITBE:                         
1165   06D3             
1166   06D3             ; END OF INITIALISATION TABLE ---------------------------------------------------
1167   06D3             
1168   06D3 204572726F72ERRMSG: .BYTE   " Error",0
1168   06D9 00
1169   06DA 20696E2000  INMSG:  .BYTE   " in ",0
1170   06DF             ZERBYT  .EQU    $-1             ; A zero byte
1171   06DF 4F6B0D0A0000OKMSG:  .BYTE   "Ok",CR,LF,0,0
1172   06E5 427265616B00BRKMSG: .BYTE   "Break",0
1173   06EB             
1174   06EB 21 04 00    BAKSTK: LD      HL,4            ; Look for "FOR" block with
1175   06EE 39                  ADD     HL,SP           ; same index as specified
1176   06EF 7E          LOKFOR: LD      A,(HL)          ; Get block ID
1177   06F0 23                  INC     HL              ; Point to index address
1178   06F1 FE 81               CP      ZFOR            ; Is it a "FOR" token
1179   06F3 C0                  RET     NZ              ; No - exit
1180   06F4 4E                  LD      C,(HL)          ; BC = Address of "FOR" index
1181   06F5 23                  INC     HL
1182   06F6 46                  LD      B,(HL)
1183   06F7 23                  INC     HL              ; Point to sign of STEP
1184   06F8 E5                  PUSH    HL              ; Save pointer to sign
1185   06F9 69                  LD      L,C             ; HL = address of "FOR" index
1186   06FA 60                  LD      H,B
1187   06FB 7A                  LD      A,D             ; See if an index was specified
1188   06FC B3                  OR      E               ; DE = 0 if no index specified
1189   06FD EB                  EX      DE,HL           ; Specified index into HL
1190   06FE CA 05 07            JP      Z,INDFND        ; Skip if no index given
1191   0701 EB                  EX      DE,HL           ; Index back into DE
1192   0702 CD 0A 0A            CALL    CPDEHL          ; Compare index with one given
1193   0705 01 0D 00    INDFND: LD      BC,16-3         ; Offset to next block
1194   0708 E1                  POP     HL              ; Restore pointer to sign
1195   0709 C8                  RET     Z               ; Return if block found
1196   070A 09                  ADD     HL,BC           ; Point to next block
1197   070B C3 EF 06            JP      LOKFOR          ; Keep on looking
1198   070E             
1199   070E CD 28 07    MOVUP:  CALL    ENFMEM          ; See if enough memory
1200   0711 C5          MOVSTR: PUSH    BC              ; Save end of source
1201   0712 E3                  EX      (SP),HL         ; Swap source and dest" end
1202   0713 C1                  POP     BC              ; Get end of destination
1203   0714 CD 0A 0A    MOVLP:  CALL    CPDEHL          ; See if list moved
1204   0717 7E                  LD      A,(HL)          ; Get byte
1205   0718 02                  LD      (BC),A          ; Move it
1206   0719 C8                  RET     Z               ; Exit if all done
1207   071A 0B                  DEC     BC              ; Next byte to move to
1208   071B 2B                  DEC     HL              ; Next byte to move
1209   071C C3 14 07            JP      MOVLP           ; Loop until all bytes moved
1210   071F             
1211   071F E5          CHKSTK: PUSH    HL              ; Save code string address
1212   0720 2A 8A 31            LD      HL,(ARREND)     ; Lowest free memory
1213   0723 06 00               LD      B,0             ; BC = Number of levels to test
1214   0725 09                  ADD     HL,BC           ; 2 Bytes for each level
1215   0726 09                  ADD     HL,BC
1216   0727 3E                  .BYTE   3EH             ; Skip "PUSH HL"
1217   0728 E5          ENFMEM: PUSH    HL              ; Save code string address
1218   0729 3E D0               LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
1219   072B 95                  SUB     L
1220   072C 6F                  LD      L,A
1221   072D 3E FF               LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
1222   072F 9C                  SBC     A,H
1223   0730 DA 37 07            JP      C,OMERR         ; Not enough - ?OM Error
1224   0733 67                  LD      H,A
1225   0734 39                  ADD     HL,SP           ; Test if stack is overflowed
1226   0735 E1                  POP     HL              ; Restore code string address
1227   0736 D8                  RET     C               ; Return if enough mmory
1228   0737 1E 0C       OMERR:  LD      E,OM            ; ?OM Error
1229   0739 C3 56 07            JP      ERROR
1230   073C             
1231   073C 2A 79 31    DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
1232   073F 22 0C 31            LD      (LINEAT),HL     ; Save as current line
1233   0742 1E 02       SNERR:  LD      E,SN            ; ?SN Error
1234   0744 01                  .BYTE   01H             ; Skip "LD E,DZ"
1235   0745 1E 14       DZERR:  LD      E,DZ            ; ?/0 Error
1236   0747 01                  .BYTE   01H             ; Skip "LD E,NF"
1237   0748 1E 00       NFERR:  LD      E,NF            ; ?NF Error
1238   074A 01                  .BYTE   01H             ; Skip "LD E,DD"
1239   074B 1E 12       DDERR:  LD      E,DD            ; ?DD Error
1240   074D 01                  .BYTE   01H             ; Skip "LD E,UF"
1241   074E 1E 22       UFERR:  LD      E,UF            ; ?UF Error
1242   0750 01                  .BYTE   01H             ; Skip "LD E,OV
1243   0751 1E 0A       OVERR:  LD      E,OV            ; ?OV Error
1244   0753 01                  .BYTE   01H             ; Skip "LD E,TM"
1245   0754 1E 18       TMERR:  LD      E,TM            ; ?TM Error
1246   0756             
1247   0756 CD 74 08    ERROR:  CALL    CLREG           ; Clear registers and stack
1248   0759 32 F5 30            LD      (CTLOFG),A      ; Enable output (A is 0)
1249   075C CD 35 0E            CALL    STTLIN          ; Start new line
1250   075F 21 49 06            LD      HL,ERRORS       ; Point to error codes
1251   0762 57                  LD      D,A             ; D = 0 (A is 0)
1252   0763 3E 3F               LD      A,'?'
1253   0765 CD 1B 0A            CALL    OUTC            ; Output '?'
1254   0768 19                  ADD     HL,DE           ; Offset to correct error code
1255   0769 7E                  LD      A,(HL)          ; First character
1256   076A CD 1B 0A            CALL    OUTC            ; Output it
1257   076D CD 9A 0B            CALL    GETCHR          ; Get next character
1258   0770 CD 1B 0A            CALL    OUTC            ; Output it
1259   0773 21 D3 06            LD      HL,ERRMSG       ; "Error" message
1260   0776 CD E0 14    ERRIN:  CALL    PRS             ; Output message
1261   0779 2A 0C 31            LD      HL,(LINEAT)     ; Get line of error
1262   077C 11 FE FF            LD      DE,-2           ; Cold start error if -2
1263   077F CD 0A 0A            CALL    CPDEHL          ; See if cold start error
1264   0782 CA A6 03            JP      Z,CSTART        ; Cold start error - Restart
1265   0785 7C                  LD      A,H             ; Was it a direct error?
1266   0786 A5                  AND     L               ; Line = -1 if direct error
1267   0787 3C                  INC     A
1268   0788 C4 7B 1B            CALL    NZ,LINEIN       ; No - output line of error
1269   078B 3E                  .BYTE   3EH             ; Skip "POP BC"
1270   078C C1          POPNOK: POP     BC              ; Drop address in input buffer
1271   078D             
1272   078D AF          PRNTOK: XOR     A               ; Output "Ok" and get command
1273   078E 32 F5 30            LD      (CTLOFG),A      ; Enable output
1274   0791 CD 35 0E            CALL    STTLIN          ; Start new line
1275   0794 21 DF 06            LD      HL,OKMSG        ; "Ok" message
1276   0797 CD E0 14            CALL    PRS             ; Output "Ok"
1277   079A 21 FF FF    GETCMD: LD      HL,-1           ; Flag direct mode
1278   079D 22 0C 31            LD      (LINEAT),HL     ; Save as current line
1279   07A0 CD 87 09            CALL    GETLIN          ; Get an input line
1280   07A3 DA 9A 07            JP      C,GETCMD        ; Get line again if break
1281   07A6 CD 9A 0B            CALL    GETCHR          ; Get first character
1282   07A9 3C                  INC     A               ; Test if end of line
1283   07AA 3D                  DEC     A               ; Without affecting Carry
1284   07AB CA 9A 07            JP      Z,GETCMD        ; Nothing entered - Get another
1285   07AE F5                  PUSH    AF              ; Save Carry status
1286   07AF CD 66 0C            CALL    ATOH            ; Get line number into DE
1287   07B2 D5                  PUSH    DE              ; Save line number
1288   07B3 CD 9E 08            CALL    CRUNCH          ; Tokenise rest of line
1289   07B6 47                  LD      B,A             ; Length of tokenised line
1290   07B7 D1                  POP     DE              ; Restore line number
1291   07B8 F1                  POP     AF              ; Restore Carry
1292   07B9 D2 7A 0B            JP      NC,EXCUTE       ; No line number - Direct mode
1293   07BC D5                  PUSH    DE              ; Save line number
1294   07BD C5                  PUSH    BC              ; Save length of tokenised line
1295   07BE AF                  XOR     A
1296   07BF 32 7C 31            LD      (LSTBIN),A      ; Clear last byte input
1297   07C2 CD 9A 0B            CALL    GETCHR          ; Get next character
1298   07C5 B7                  OR      A               ; Set flags
1299   07C6 F5                  PUSH    AF              ; And save them
1300   07C7 CD 2E 08            CALL    SRCHLN          ; Search for line number in DE
1301   07CA DA D3 07            JP      C,LINFND        ; Jump if line found
1302   07CD F1                  POP     AF              ; Get status
1303   07CE F5                  PUSH    AF              ; And re-save
1304   07CF CA 07 0D            JP      Z,ULERR         ; Nothing after number - Error
1305   07D2 B7                  OR      A               ; Clear Carry
1306   07D3 C5          LINFND: PUSH    BC              ; Save address of line in prog
1307   07D4 D2 EA 07            JP      NC,INEWLN       ; Line not found - Insert new
1308   07D7 EB                  EX      DE,HL           ; Next line address in DE
1309   07D8 2A 86 31            LD      HL,(PROGND)     ; End of program
1310   07DB 1A          SFTPRG: LD      A,(DE)          ; Shift rest of program down
1311   07DC 02                  LD      (BC),A
1312   07DD 03                  INC     BC              ; Next destination
1313   07DE 13                  INC     DE              ; Next source
1314   07DF CD 0A 0A            CALL    CPDEHL          ; All done?
1315   07E2 C2 DB 07            JP      NZ,SFTPRG       ; More to do
1316   07E5 60                  LD      H,B             ; HL - New end of program
1317   07E6 69                  LD      L,C
1318   07E7 22 86 31            LD      (PROGND),HL     ; Update end of program
1319   07EA             
1320   07EA D1          INEWLN: POP     DE              ; Get address of line,
1321   07EB F1                  POP     AF              ; Get status
1322   07EC CA 11 08            JP      Z,SETPTR        ; No text - Set up pointers
1323   07EF 2A 86 31            LD      HL,(PROGND)     ; Get end of program
1324   07F2 E3                  EX      (SP),HL         ; Get length of input line
1325   07F3 C1                  POP     BC              ; End of program to BC
1326   07F4 09                  ADD     HL,BC           ; Find new end
1327   07F5 E5                  PUSH    HL              ; Save new end
1328   07F6 CD 0E 07            CALL    MOVUP           ; Make space for line
1329   07F9 E1                  POP     HL              ; Restore new end
1330   07FA 22 86 31            LD      (PROGND),HL     ; Update end of program pointer
1331   07FD EB                  EX      DE,HL           ; Get line to move up in HL
1332   07FE 74                  LD      (HL),H          ; Save MSB
1333   07FF D1                  POP     DE              ; Get new line number
1334   0800 23                  INC     HL              ; Skip pointer
1335   0801 23                  INC     HL
1336   0802 73                  LD      (HL),E          ; Save LSB of line number
1337   0803 23                  INC     HL
1338   0804 72                  LD      (HL),D          ; Save MSB of line number
1339   0805 23                  INC     HL              ; To first byte in line
1340   0806 11 11 31            LD      DE,BUFFER       ; Copy buffer to program
1341   0809 1A          MOVBUF: LD      A,(DE)          ; Get source
1342   080A 77                  LD      (HL),A          ; Save destinations
1343   080B 23                  INC     HL              ; Next source
1344   080C 13                  INC     DE              ; Next destination
1345   080D B7                  OR      A               ; Done?
1346   080E C2 09 08            JP      NZ,MOVBUF       ; No - Repeat
1347   0811 CD 5A 08    SETPTR: CALL    RUNFST          ; Set line pointers
1348   0814 23                  INC     HL              ; To LSB of pointer
1349   0815 EB                  EX      DE,HL           ; Address to DE
1350   0816 62          PTRLP:  LD      H,D             ; Address to HL
1351   0817 6B                  LD      L,E
1352   0818 7E                  LD      A,(HL)          ; Get LSB of pointer
1353   0819 23                  INC     HL              ; To MSB of pointer
1354   081A B6                  OR      (HL)            ; Compare with MSB pointer
1355   081B CA 9A 07            JP      Z,GETCMD        ; Get command line if end
1356   081E 23                  INC     HL              ; To LSB of line number
1357   081F 23                  INC     HL              ; Skip line number
1358   0820 23                  INC     HL              ; Point to first byte in line
1359   0821 AF                  XOR     A               ; Looking for 00 byte
1360   0822 BE          FNDEND: CP      (HL)            ; Found end of line?
1361   0823 23                  INC     HL              ; Move to next byte
1362   0824 C2 22 08            JP      NZ,FNDEND       ; No - Keep looking
1363   0827 EB                  EX      DE,HL           ; Next line address to HL
1364   0828 73                  LD      (HL),E          ; Save LSB of pointer
1365   0829 23                  INC     HL
1366   082A 72                  LD      (HL),D          ; Save MSB of pointer
1367   082B C3 16 08            JP      PTRLP           ; Do next line
1368   082E             
1369   082E 2A 0E 31    SRCHLN: LD      HL,(BASTXT)     ; Start of program text
1370   0831 44          SRCHLP: LD      B,H             ; BC = Address to look at
1371   0832 4D                  LD      C,L
1372   0833 7E                  LD      A,(HL)          ; Get address of next line
1373   0834 23                  INC     HL
1374   0835 B6                  OR      (HL)            ; End of program found?
1375   0836 2B                  DEC     HL
1376   0837 C8                  RET     Z               ; Yes - Line not found
1377   0838 23                  INC     HL
1378   0839 23                  INC     HL
1379   083A 7E                  LD      A,(HL)          ; Get LSB of line number
1380   083B 23                  INC     HL
1381   083C 66                  LD      H,(HL)          ; Get MSB of line number
1382   083D 6F                  LD      L,A
1383   083E CD 0A 0A            CALL    CPDEHL          ; Compare with line in DE
1384   0841 60                  LD      H,B             ; HL = Start of this line
1385   0842 69                  LD      L,C
1386   0843 7E                  LD      A,(HL)          ; Get LSB of next line address
1387   0844 23                  INC     HL
1388   0845 66                  LD      H,(HL)          ; Get MSB of next line address
1389   0846 6F                  LD      L,A             ; Next line to HL
1390   0847 3F                  CCF
1391   0848 C8                  RET     Z               ; Lines found - Exit
1392   0849 3F                  CCF
1393   084A D0                  RET     NC              ; Line not found,at line after
1394   084B C3 31 08            JP      SRCHLP          ; Keep looking
1395   084E             
1396   084E C0          NEW:    RET     NZ              ; Return if any more on line
1397   084F 2A 0E 31    CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
1398   0852 AF                  XOR     A               ; Set program area to empty
1399   0853 77                  LD      (HL),A          ; Save LSB = 00
1400   0854 23                  INC     HL
1401   0855 77                  LD      (HL),A          ; Save MSB = 00
1402   0856 23                  INC     HL
1403   0857 22 86 31            LD      (PROGND),HL     ; Set program end
1404   085A             
1405   085A 2A 0E 31    RUNFST: LD      HL,(BASTXT)     ; Clear all variables
1406   085D 2B                  DEC     HL
1407   085E             
1408   085E 22 7E 31    INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
1409   0861 2A 5F 31            LD      HL,(LSTRAM)     ; Get end of RAM
1410   0864 22 73 31            LD      (STRBOT),HL     ; Clear string space
1411   0867 AF                  XOR     A
1412   0868 CD AA 0B            CALL    RESTOR          ; Reset DATA pointers
1413   086B 2A 86 31            LD      HL,(PROGND)     ; Get end of program
1414   086E 22 88 31            LD      (VAREND),HL     ; Clear variables
1415   0871 22 8A 31            LD      (ARREND),HL     ; Clear arrays
1416   0874             
1417   0874 C1          CLREG:  POP     BC              ; Save return address
1418   0875 2A 0A 31            LD      HL,(STRSPC)     ; Get end of working RAN
1419   0878 F9                  LD      SP,HL           ; Set stack
1420   0879 21 63 31            LD      HL,TMSTPL       ; Temporary string pool
1421   087C 22 61 31            LD      (TMSTPT),HL     ; Reset temporary string ptr
1422   087F AF                  XOR     A               ; A = 00
1423   0880 6F                  LD      L,A             ; HL = 0000
1424   0881 67                  LD      H,A
1425   0882 22 84 31            LD      (CONTAD),HL     ; No CONTinue
1426   0885 32 7B 31            LD      (FORFLG),A      ; Clear FOR flag
1427   0888 22 8E 31            LD      (FNRGNM),HL     ; Clear FN argument
1428   088B E5                  PUSH    HL              ; HL = 0000
1429   088C C5                  PUSH    BC              ; Put back return
1430   088D 2A 7E 31    DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
1431   0890 C9                  RET                     ; Return to execution driver
1432   0891             
1433   0891 3E 3F       PROMPT: LD      A,'?'           ; '?'
1434   0893 CD 1B 0A            CALL    OUTC            ; Output character
1435   0896 3E 20               LD      A,' '           ; Space
1436   0898 CD 1B 0A            CALL    OUTC            ; Output character
1437   089B C3 FE 30            JP      RINPUT          ; Get input line
1438   089E             
1439   089E AF          CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
1440   089F 32 5E 31            LD      (DATFLG),A      ; Reset literal flag
1441   08A2 0E 05               LD      C,2+3           ; 2 byte number and 3 nulls
1442   08A4 11 11 31            LD      DE,BUFFER       ; Start of input buffer
1443   08A7 7E          CRNCLP: LD      A,(HL)          ; Get byte
1444   08A8 FE 20               CP      ' '             ; Is it a space?
1445   08AA CA 26 09            JP      Z,MOVDIR        ; Yes - Copy direct
1446   08AD 47                  LD      B,A             ; Save character
1447   08AE FE 22               CP      '"'             ; Is it a quote?
1448   08B0 CA 46 09            JP      Z,CPYLIT        ; Yes - Copy literal string
1449   08B3 B7                  OR      A               ; Is it end of buffer?
1450   08B4 CA 4D 09            JP      Z,ENDBUF        ; Yes - End buffer
1451   08B7 3A 5E 31            LD      A,(DATFLG)      ; Get data type
1452   08BA B7                  OR      A               ; Literal?
1453   08BB 7E                  LD      A,(HL)          ; Get byte to copy
1454   08BC C2 26 09            JP      NZ,MOVDIR       ; Literal - Copy direct
1455   08BF FE 3F               CP      '?'             ; Is it '?' short for PRINT
1456   08C1 3E 9E               LD      A,ZPRINT        ; "PRINT" token
1457   08C3 CA 26 09            JP      Z,MOVDIR        ; Yes - replace it
1458   08C6 7E                  LD      A,(HL)          ; Get byte again
1459   08C7 FE 30               CP      '0'             ; Is it less than '0'
1460   08C9 DA D1 08            JP      C,FNDWRD        ; Yes - Look for reserved words
1461   08CC FE 3C               CP      60; ";"+1           ; Is it "0123456789:;" ?
1462   08CE DA 26 09            JP      C,MOVDIR        ; Yes - copy it direct
1463   08D1 D5          FNDWRD: PUSH    DE              ; Look for reserved words
1464   08D2 11 CA 04            LD      DE,WORDS-1      ; Point to table
1465   08D5 C5                  PUSH    BC              ; Save count
1466   08D6 01 22 09            LD      BC,RETNAD       ; Where to return to
1467   08D9 C5                  PUSH    BC              ; Save return address
1468   08DA 06 7F               LD      B,ZEND-1        ; First token value -1
1469   08DC 7E                  LD      A,(HL)          ; Get byte
1470   08DD FE 61               CP      'a'             ; Less than 'a' ?
1471   08DF DA EA 08            JP      C,SEARCH        ; Yes - search for words
1472   08E2 FE 7B               CP      'z'+1           ; Greater than 'z' ?
1473   08E4 D2 EA 08            JP      NC,SEARCH       ; Yes - search for words
1474   08E7 E6 5F               AND     01011111B       ; Force upper case
1475   08E9 77                  LD      (HL),A          ; Replace byte
1476   08EA 4E          SEARCH: LD      C,(HL)          ; Search for a word
1477   08EB EB                  EX      DE,HL
1478   08EC 23          GETNXT: INC     HL              ; Get next reserved word
1479   08ED B6                  OR      (HL)            ; Start of word?
1480   08EE F2 EC 08            JP      P,GETNXT        ; No - move on
1481   08F1 04                  INC     B               ; Increment token value
1482   08F2 7E                  LD      A, (HL)         ; Get byte from table
1483   08F3 E6 7F               AND     01111111B       ; Strip bit 7
1484   08F5 C8                  RET     Z               ; Return if end of list
1485   08F6 B9                  CP      C               ; Same character as in buffer?
1486   08F7 C2 EC 08            JP      NZ,GETNXT       ; No - get next word
1487   08FA EB                  EX      DE,HL
1488   08FB E5                  PUSH    HL              ; Save start of word
1489   08FC             
1490   08FC 13          NXTBYT: INC     DE              ; Look through rest of word
1491   08FD 1A                  LD      A,(DE)          ; Get byte from table
1492   08FE B7                  OR      A               ; End of word ?
1493   08FF FA 1E 09            JP      M,MATCH         ; Yes - Match found
1494   0902 4F                  LD      C,A             ; Save it
1495   0903 78                  LD      A,B             ; Get token value
1496   0904 FE 88               CP      ZGOTO           ; Is it "GOTO" token ?
1497   0906 C2 0D 09            JP      NZ,NOSPC        ; No - Don't allow spaces
1498   0909 CD 9A 0B            CALL    GETCHR          ; Get next character
1499   090C 2B                  DEC     HL              ; Cancel increment from GETCHR
1500   090D 23          NOSPC:  INC     HL              ; Next byte
1501   090E 7E                  LD      A,(HL)          ; Get byte
1502   090F FE 61               CP      'a'             ; Less than 'a' ?
1503   0911 DA 16 09            JP      C,NOCHNG        ; Yes - don't change
1504   0914 E6 5F               AND     01011111B       ; Make upper case
1505   0916 B9          NOCHNG: CP      C               ; Same as in buffer ?
1506   0917 CA FC 08            JP      Z,NXTBYT        ; Yes - keep testing
1507   091A E1                  POP     HL              ; Get back start of word
1508   091B C3 EA 08            JP      SEARCH          ; Look at next word
1509   091E             
1510   091E 48          MATCH:  LD      C,B             ; Word found - Save token value
1511   091F F1                  POP     AF              ; Throw away return
1512   0920 EB                  EX      DE,HL
1513   0921 C9                  RET                     ; Return to "RETNAD"
1514   0922 EB          RETNAD: EX      DE,HL           ; Get address in string
1515   0923 79                  LD      A,C             ; Get token value
1516   0924 C1                  POP     BC              ; Restore buffer length
1517   0925 D1                  POP     DE              ; Get destination address
1518   0926 23          MOVDIR: INC     HL              ; Next source in buffer
1519   0927 12                  LD      (DE),A          ; Put byte in buffer
1520   0928 13                  INC     DE              ; Move up buffer
1521   0929 0C                  INC     C               ; Increment length of buffer
1522   092A D6 3A               SUB     ':'             ; End of statement?
1523   092C CA 34 09            JP      Z,SETLIT        ; Jump if multi-statement line
1524   092F FE 49               CP      ZDATA-3AH       ; Is it DATA statement ?
1525   0931 C2 37 09            JP      NZ,TSTREM       ; No - see if REM
1526   0934 32 5E 31    SETLIT: LD      (DATFLG),A      ; Set literal flag
1527   0937 D6 54       TSTREM: SUB     ZREM-3AH        ; Is it REM?
1528   0939 C2 A7 08            JP      NZ,CRNCLP       ; No - Leave flag
1529   093C 47                  LD      B,A             ; Copy rest of buffer
1530   093D 7E          NXTCHR: LD      A,(HL)          ; Get byte
1531   093E B7                  OR      A               ; End of line ?
1532   093F CA 4D 09            JP      Z,ENDBUF        ; Yes - Terminate buffer
1533   0942 B8                  CP      B               ; End of statement ?
1534   0943 CA 26 09            JP      Z,MOVDIR        ; Yes - Get next one
1535   0946 23          CPYLIT: INC     HL              ; Move up source string
1536   0947 12                  LD      (DE),A          ; Save in destination
1537   0948 0C                  INC     C               ; Increment length
1538   0949 13                  INC     DE              ; Move up destination
1539   094A C3 3D 09            JP      NXTCHR          ; Repeat
1540   094D             
1541   094D 21 10 31    ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
1542   0950 12                  LD      (DE),A          ; Mark end of buffer (A = 00)
1543   0951 13                  INC     DE
1544   0952 12                  LD      (DE),A          ; A = 00
1545   0953 13                  INC     DE
1546   0954 12                  LD      (DE),A          ; A = 00
1547   0955 C9                  RET
1548   0956             
1549   0956 3A F4 30    DODEL:  LD      A,(NULFLG)      ; Get null flag status
1550   0959 B7                  OR      A               ; Is it zero?
1551   095A 3E 00               LD      A,0             ; Zero A - Leave flags
1552   095C 32 F4 30            LD      (NULFLG),A      ; Zero null flag
1553   095F C2 6A 09            JP      NZ,ECHDEL       ; Set - Echo it
1554   0962 05                  DEC     B               ; Decrement length
1555   0963 CA 87 09            JP      Z,GETLIN        ; Get line again if empty
1556   0966 CD 1B 0A            CALL    OUTC            ; Output null character
1557   0969 3E                  .BYTE   3EH             ; Skip "DEC B"
1558   096A 05          ECHDEL: DEC     B               ; Count bytes in buffer
1559   096B 2B                  DEC     HL              ; Back space buffer
1560   096C CA 7E 09            JP      Z,OTKLN         ; No buffer - Try again
1561   096F 7E                  LD      A,(HL)          ; Get deleted byte
1562   0970 CD 1B 0A            CALL    OUTC            ; Echo it
1563   0973 C3 90 09            JP      MORINP          ; Get more input
1564   0976             
1565   0976 05          DELCHR: DEC     B               ; Count bytes in buffer
1566   0977 2B                  DEC     HL              ; Back space buffer
1567   0978 CD 1B 0A            CALL    OUTC            ; Output character in A
1568   097B C2 90 09            JP      NZ,MORINP       ; Not end - Get more
1569   097E CD 1B 0A    OTKLN:  CALL    OUTC            ; Output character in A
1570   0981 CD 42 0E    KILIN:  CALL    PRNTCRLF        ; Output CRLF
1571   0984 C3 87 09            JP      TTYLIN          ; Get line again
1572   0987             
1573   0987             GETLIN:
1574   0987 21 11 31    TTYLIN: LD      HL,BUFFER       ; Get a line by character
1575   098A 06 01               LD      B,1             ; Set buffer as empty
1576   098C AF                  XOR     A
1577   098D 32 F4 30            LD      (NULFLG),A      ; Clear null flag
1578   0990 CD 45 0A    MORINP: CALL    CLOTST          ; Get character and test ^O
1579   0993 4F                  LD      C,A             ; Save character in C
1580   0994 FE 7F               CP      DEL             ; Delete character?
1581   0996 CA 56 09            JP      Z,DODEL         ; Yes - Process it
1582   0999 3A F4 30            LD      A,(NULFLG)      ; Get null flag
1583   099C B7                  OR      A               ; Test null flag status
1584   099D CA A9 09            JP      Z,PROCES        ; Reset - Process character
1585   09A0 3E 00               LD      A,0             ; Set a null
1586   09A2 CD 1B 0A            CALL    OUTC            ; Output null
1587   09A5 AF                  XOR     A               ; Clear A
1588   09A6 32 F4 30            LD      (NULFLG),A      ; Reset null flag
1589   09A9 79          PROCES: LD      A,C             ; Get character
1590   09AA FE 07               CP      CTRLG           ; Bell?
1591   09AC CA ED 09            JP      Z,PUTCTL        ; Yes - Save it
1592   09AF FE 03               CP      CTRLC           ; Is it control "C"?
1593   09B1 CC 42 0E            CALL    Z,PRNTCRLF      ; Yes - Output CRLF
1594   09B4 37                  SCF                     ; Flag break
1595   09B5 C8                  RET     Z               ; Return if control "C"
1596   09B6 FE 0D               CP      CR              ; Is it enter?
1597   09B8 CA 3D 0E            JP      Z,ENDINP        ; Yes - Terminate input
1598   09BB FE 15               CP      CTRLU           ; Is it control "U"?
1599   09BD CA 81 09            JP      Z,KILIN         ; Yes - Get another line
1600   09C0 FE 40               CP      '@'             ; Is it "kill line"?
1601   09C2 CA 7E 09            JP      Z,OTKLN         ; Yes - Kill line
1602   09C5 FE 5F               CP      '_'             ; Is it delete?
1603   09C7 CA 76 09            JP      Z,DELCHR        ; Yes - Delete character
1604   09CA FE 08               CP      BKSP            ; Is it backspace?
1605   09CC CA 76 09            JP      Z,DELCHR        ; Yes - Delete character
1606   09CF FE 12               CP      CTRLR           ; Is it control "R"?
1607   09D1 C2 E8 09            JP      NZ,PUTBUF       ; No - Put in buffer
1608   09D4 C5                  PUSH    BC              ; Save buffer length
1609   09D5 D5                  PUSH    DE              ; Save DE
1610   09D6 E5                  PUSH    HL              ; Save buffer address
1611   09D7 36 00               LD      (HL),0          ; Mark end of buffer
1612   09D9 CD F2 1F            CALL    OUTNCR          ; Output and do CRLF
1613   09DC 21 11 31            LD      HL,BUFFER       ; Point to buffer start
1614   09DF CD E0 14            CALL    PRS             ; Output buffer
1615   09E2 E1                  POP     HL              ; Restore buffer address
1616   09E3 D1                  POP     DE              ; Restore DE
1617   09E4 C1                  POP     BC              ; Restore buffer length
1618   09E5 C3 90 09            JP      MORINP          ; Get another character
1619   09E8             
1620   09E8 FE 20       PUTBUF: CP      ' '             ; Is it a control code?
1621   09EA DA 90 09            JP      C,MORINP        ; Yes - Ignore
1622   09ED 78          PUTCTL: LD      A,B             ; Get number of bytes in buffer
1623   09EE FE 49               CP      72+1            ; Test for line overflow
1624   09F0 3E 07               LD      A,CTRLG         ; Set a bell
1625   09F2 D2 02 0A            JP      NC,OUTNBS       ; Ring bell if buffer full
1626   09F5 79                  LD      A,C             ; Get character
1627   09F6 71                  LD      (HL),C          ; Save in buffer
1628   09F7 32 7C 31            LD      (LSTBIN),A      ; Save last input byte
1629   09FA 23                  INC     HL              ; Move up buffer
1630   09FB 04                  INC     B               ; Increment length
1631   09FC CD 1B 0A    OUTIT:  CALL    OUTC            ; Output the character entered
1632   09FF C3 90 09            JP      MORINP          ; Get another character
1633   0A02             
1634   0A02 CD 1B 0A    OUTNBS: CALL    OUTC            ; Output bell and back over it
1635   0A05 3E 08               LD      A,BKSP          ; Set back space
1636   0A07 C3 FC 09            JP      OUTIT           ; Output it and get more
1637   0A0A             
1638   0A0A 7C          CPDEHL: LD      A,H             ; Get H
1639   0A0B 92                  SUB     D               ; Compare with D
1640   0A0C C0                  RET     NZ              ; Different - Exit
1641   0A0D 7D                  LD      A,L             ; Get L
1642   0A0E 93                  SUB     E               ; Compare with E
1643   0A0F C9                  RET                     ; Return status
1644   0A10             
1645   0A10 7E          CHKSYN: LD      A,(HL)          ; Check syntax of character
1646   0A11 E3                  EX      (SP),HL         ; Address of test byte
1647   0A12 BE                  CP      (HL)            ; Same as in code string?
1648   0A13 23                  INC     HL              ; Return address
1649   0A14 E3                  EX      (SP),HL         ; Put it back
1650   0A15 CA 9A 0B            JP      Z,GETCHR        ; Yes - Get next character
1651   0A18 C3 42 07            JP      SNERR           ; Different - ?SN Error
1652   0A1B             
1653   0A1B F5          OUTC:   PUSH    AF              ; Save character
1654   0A1C 3A F5 30            LD      A,(CTLOFG)      ; Get control "O" flag
1655   0A1F B7                  OR      A               ; Is it set?
1656   0A20 C2 15 15            JP      NZ,POPAF        ; Yes - don't output
1657   0A23 F1                  POP     AF              ; Restore character
1658   0A24 C5                  PUSH    BC              ; Save buffer length
1659   0A25 F5                  PUSH    AF              ; Save character
1660   0A26 FE 20               CP      ' '             ; Is it a control code?
1661   0A28 DA 3F 0A            JP      C,DINPOS        ; Yes - Don't INC POS(X)
1662   0A2B 3A F2 30            LD      A,(LWIDTH)      ; Get line width
1663   0A2E 47                  LD      B,A             ; To B
1664   0A2F 3A 5B 31            LD      A,(CURPOS)      ; Get cursor position
1665   0A32 04                  INC     B               ; Width 255?
1666   0A33 CA 3B 0A            JP      Z,INCLEN        ; Yes - No width limit
1667   0A36 05                  DEC     B               ; Restore width
1668   0A37 B8                  CP      B               ; At end of line?
1669   0A38 CC 42 0E            CALL    Z,PRNTCRLF      ; Yes - output CRLF
1670   0A3B 3C          INCLEN: INC     A               ; Move on one character
1671   0A3C 32 5B 31            LD      (CURPOS),A      ; Save new position
1672   0A3F F1          DINPOS: POP     AF              ; Restore character
1673   0A40 C1                  POP     BC              ; Restore buffer length
1674   0A41 CD DB 1F            CALL    MONOUT          ; Send it
1675   0A44 C9                  RET
1676   0A45             
1677   0A45 CD 9F 1E    CLOTST: CALL    GETINP          ; Get input character
1678   0A48 E6 7F               AND     01111111B       ; Strip bit 7
1679   0A4A FE 0F               CP      CTRLO           ; Is it control "O"?
1680   0A4C C0                  RET     NZ              ; No don't flip flag
1681   0A4D 3A F5 30            LD      A,(CTLOFG)      ; Get flag
1682   0A50 2F                  CPL                     ; Flip it
1683   0A51 32 F5 30            LD      (CTLOFG),A      ; Put it back
1684   0A54 AF                  XOR     A               ; Null character
1685   0A55 C9                  RET
1686   0A56             
1687   0A56 CD 66 0C    LIST:   CALL    ATOH            ; ASCII number to DE
1688   0A59 C0                  RET     NZ              ; Return if anything extra
1689   0A5A C1                  POP     BC              ; Rubbish - Not needed
1690   0A5B CD 2E 08            CALL    SRCHLN          ; Search for line number in DE
1691   0A5E C5                  PUSH    BC              ; Save address of line
1692   0A5F CD AC 0A            CALL    SETLIN          ; Set up lines counter
1693   0A62 E1          LISTLP: POP     HL              ; Restore address of line
1694   0A63 4E                  LD      C,(HL)          ; Get LSB of next line
1695   0A64 23                  INC     HL
1696   0A65 46                  LD      B,(HL)          ; Get MSB of next line
1697   0A66 23                  INC     HL
1698   0A67 78                  LD      A,B             ; BC = 0 (End of program)?
1699   0A68 B1                  OR      C
1700   0A69 CA 8D 07            JP      Z,PRNTOK        ; Yes - Go to command mode
1701   0A6C CD B5 0A            CALL    COUNT           ; Count lines
1702   0A6F CD C5 0B            CALL    TSTBRK          ; Test for break key
1703   0A72 C5                  PUSH    BC              ; Save address of next line
1704   0A73 CD 42 0E            CALL    PRNTCRLF        ; Output CRLF
1705   0A76 5E                  LD      E,(HL)          ; Get LSB of line number
1706   0A77 23                  INC     HL
1707   0A78 56                  LD      D,(HL)          ; Get MSB of line number
1708   0A79 23                  INC     HL
1709   0A7A E5                  PUSH    HL              ; Save address of line start
1710   0A7B EB                  EX      DE,HL           ; Line number to HL
1711   0A7C CD 83 1B            CALL    PRNTHL          ; Output line number in decimal
1712   0A7F 3E 20               LD      A,' '           ; Space after line number
1713   0A81 E1                  POP     HL              ; Restore start of line address
1714   0A82 CD 1B 0A    LSTLP2: CALL    OUTC            ; Output character in A
1715   0A85 7E          LSTLP3: LD      A,(HL)          ; Get next byte in line
1716   0A86 B7                  OR      A               ; End of line?
1717   0A87 23                  INC     HL              ; To next byte in line
1718   0A88 CA 62 0A            JP      Z,LISTLP        ; Yes - get next line
1719   0A8B F2 82 0A            JP      P,LSTLP2        ; No token - output it
1720   0A8E D6 7F               SUB     ZEND-1          ; Find and output word
1721   0A90 4F                  LD      C,A             ; Token offset+1 to C
1722   0A91 11 CB 04            LD      DE,WORDS        ; Reserved word list
1723   0A94 1A          FNDTOK: LD      A,(DE)          ; Get character in list
1724   0A95 13                  INC     DE              ; Move on to next
1725   0A96 B7                  OR      A               ; Is it start of word?
1726   0A97 F2 94 0A            JP      P,FNDTOK        ; No - Keep looking for word
1727   0A9A 0D                  DEC     C               ; Count words
1728   0A9B C2 94 0A            JP      NZ,FNDTOK       ; Not there - keep looking
1729   0A9E E6 7F       OUTWRD: AND     01111111B       ; Strip bit 7
1730   0AA0 CD 1B 0A            CALL    OUTC            ; Output first character
1731   0AA3 1A                  LD      A,(DE)          ; Get next character
1732   0AA4 13                  INC     DE              ; Move on to next
1733   0AA5 B7                  OR      A               ; Is it end of word?
1734   0AA6 F2 9E 0A            JP      P,OUTWRD        ; No - output the rest
1735   0AA9 C3 85 0A            JP      LSTLP3          ; Next byte in line
1736   0AAC             
1737   0AAC E5          SETLIN: PUSH    HL              ; Set up LINES counter
1738   0AAD 2A F8 30            LD      HL,(LINESN)     ; Get LINES number
1739   0AB0 22 F6 30            LD      (LINESC),HL     ; Save in LINES counter
1740   0AB3 E1                  POP     HL
1741   0AB4 C9                  RET
1742   0AB5             
1743   0AB5 E5          COUNT:  PUSH    HL              ; Save code string address
1744   0AB6 D5                  PUSH    DE
1745   0AB7 2A F6 30            LD      HL,(LINESC)     ; Get LINES counter
1746   0ABA 11 FF FF            LD      DE,-1
1747   0ABD ED 5A               ADC     HL,DE           ; Decrement
1748   0ABF 22 F6 30            LD      (LINESC),HL     ; Put it back
1749   0AC2 D1                  POP     DE
1750   0AC3 E1                  POP     HL              ; Restore code string address
1751   0AC4 F0                  RET     P               ; Return if more lines to go
1752   0AC5 E5                  PUSH    HL              ; Save code string address
1753   0AC6 2A F8 30            LD      HL,(LINESN)     ; Get LINES number
1754   0AC9 22 F6 30            LD      (LINESC),HL     ; Reset LINES counter
1755   0ACC CD 9F 1E            CALL    GETINP          ; Get input character
1756   0ACF FE 03               CP      CTRLC           ; Is it control "C"?
1757   0AD1 CA D8 0A            JP      Z,RSLNBK        ; Yes - Reset LINES and break
1758   0AD4 E1                  POP     HL              ; Restore code string address
1759   0AD5 C3 B5 0A            JP      COUNT           ; Keep on counting
1760   0AD8             
1761   0AD8 2A F8 30    RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1762   0ADB 22 F6 30            LD      (LINESC),HL     ; Reset LINES counter
1763   0ADE C3 3C 04            JP      BRKRET          ; Go and output "Break"
1764   0AE1             
1765   0AE1 3E 64       FOR:    LD      A,64H           ; Flag "FOR" assignment
1766   0AE3 32 7B 31            LD      (FORFLG),A      ; Save "FOR" flag
1767   0AE6 CD 48 0D            CALL    LET             ; Set up initial index
1768   0AE9 C1                  POP     BC              ; Drop RETurn address
1769   0AEA E5                  PUSH    HL              ; Save code string address
1770   0AEB CD 31 0D            CALL    DATA            ; Get next statement address
1771   0AEE 22 77 31            LD      (LOOPST),HL     ; Save it for start of loop
1772   0AF1 21 02 00            LD      HL,2            ; Offset for "FOR" block
1773   0AF4 39                  ADD     HL,SP           ; Point to it
1774   0AF5 CD EF 06    FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1775   0AF8 D1                  POP     DE              ; Get code string address
1776   0AF9 C2 11 0B            JP      NZ,FORFND       ; No nesting found
1777   0AFC 09                  ADD     HL,BC           ; Move into "FOR" block
1778   0AFD D5                  PUSH    DE              ; Save code string address
1779   0AFE 2B                  DEC     HL
1780   0AFF 56                  LD      D,(HL)          ; Get MSB of loop statement
1781   0B00 2B                  DEC     HL
1782   0B01 5E                  LD      E,(HL)          ; Get LSB of loop statement
1783   0B02 23                  INC     HL
1784   0B03 23                  INC     HL
1785   0B04 E5                  PUSH    HL              ; Save block address
1786   0B05 2A 77 31            LD      HL,(LOOPST)     ; Get address of loop statement
1787   0B08 CD 0A 0A            CALL    CPDEHL          ; Compare the FOR loops
1788   0B0B E1                  POP     HL              ; Restore block address
1789   0B0C C2 F5 0A            JP      NZ,FORSLP       ; Different FORs - Find another
1790   0B0F D1                  POP     DE              ; Restore code string address
1791   0B10 F9                  LD      SP,HL           ; Remove all nested loops
1792   0B11             
1793   0B11 EB          FORFND: EX      DE,HL           ; Code string address to HL
1794   0B12 0E 08               LD      C,8
1795   0B14 CD 1F 07            CALL    CHKSTK          ; Check for 8 levels of stack
1796   0B17 E5                  PUSH    HL              ; Save code string address
1797   0B18 2A 77 31            LD      HL,(LOOPST)     ; Get first statement of loop
1798   0B1B E3                  EX      (SP),HL         ; Save and restore code string
1799   0B1C E5                  PUSH    HL              ; Re-save code string address
1800   0B1D 2A 0C 31            LD      HL,(LINEAT)     ; Get current line number
1801   0B20 E3                  EX      (SP),HL         ; Save and restore code string
1802   0B21 CD 0A 10            CALL    TSTNUM          ; Make sure it's a number
1803   0B24 CD 10 0A            CALL    CHKSYN          ; Make sure "TO" is next
1804   0B27 A6                  .BYTE   ZTO          ; "TO" token
1805   0B28 CD 07 10            CALL    GETNUM          ; Get "TO" expression value
1806   0B2B E5                  PUSH    HL              ; Save code string address
1807   0B2C CD 35 1A            CALL    BCDEFP          ; Move "TO" value to BCDE
1808   0B2F E1                  POP     HL              ; Restore code string address
1809   0B30 C5                  PUSH    BC              ; Save "TO" value in block
1810   0B31 D5                  PUSH    DE
1811   0B32 01 00 81            LD      BC,8100H        ; BCDE - 1 (default STEP)
1812   0B35 51                  LD      D,C             ; C=0
1813   0B36 5A                  LD      E,D             ; D=0
1814   0B37 7E                  LD      A,(HL)          ; Get next byte in code string
1815   0B38 FE AB               CP      ZSTEP           ; See if "STEP" is stated
1816   0B3A 3E 01               LD      A,1             ; Sign of step = 1
1817   0B3C C2 4D 0B            JP      NZ,SAVSTP       ; No STEP given - Default to 1
1818   0B3F CD 9A 0B            CALL    GETCHR          ; Jump over "STEP" token
1819   0B42 CD 07 10            CALL    GETNUM          ; Get step value
1820   0B45 E5                  PUSH    HL              ; Save code string address
1821   0B46 CD 35 1A            CALL    BCDEFP          ; Move STEP to BCDE
1822   0B49 CD E9 19            CALL    TSTSGN          ; Test sign of FPREG
1823   0B4C E1                  POP     HL              ; Restore code string address
1824   0B4D C5          SAVSTP: PUSH    BC              ; Save the STEP value in block
1825   0B4E D5                  PUSH    DE
1826   0B4F F5                  PUSH    AF              ; Save sign of STEP
1827   0B50 33                  INC     SP              ; Don't save flags
1828   0B51 E5                  PUSH    HL              ; Save code string address
1829   0B52 2A 7E 31            LD      HL,(BRKLIN)     ; Get address of index variable
1830   0B55 E3                  EX      (SP),HL         ; Save and restore code string
1831   0B56 06 81       PUTFID: LD      B,ZFOR          ; "FOR" block marker
1832   0B58 C5                  PUSH    BC              ; Save it
1833   0B59 33                  INC     SP              ; Don't save C
1834   0B5A             
1835   0B5A CD C5 0B    RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1836   0B5D 22 7E 31            LD      (BRKLIN),HL     ; Save code address for break
1837   0B60 7E                  LD      A,(HL)          ; Get next byte in code string
1838   0B61 FE 3A               CP      ':'             ; Multi statement line?
1839   0B63 CA 7A 0B            JP      Z,EXCUTE        ; Yes - Execute it
1840   0B66 B7                  OR      A               ; End of line?
1841   0B67 C2 42 07            JP      NZ,SNERR        ; No - Syntax error
1842   0B6A 23                  INC     HL              ; Point to address of next line
1843   0B6B 7E                  LD      A,(HL)          ; Get LSB of line pointer
1844   0B6C 23                  INC     HL
1845   0B6D B6                  OR      (HL)            ; Is it zero (End of prog)?
1846   0B6E CA EC 0B            JP      Z,ENDPRG        ; Yes - Terminate execution
1847   0B71 23                  INC     HL              ; Point to line number
1848   0B72 5E                  LD      E,(HL)          ; Get LSB of line number
1849   0B73 23                  INC     HL
1850   0B74 56                  LD      D,(HL)          ; Get MSB of line number
1851   0B75 EB                  EX      DE,HL           ; Line number to HL
1852   0B76 22 0C 31            LD      (LINEAT),HL     ; Save as current line number
1853   0B79 EB                  EX      DE,HL           ; Line number back to DE
1854   0B7A CD 9A 0B    EXCUTE: CALL    GETCHR          ; Get key word
1855   0B7D 11 5A 0B            LD      DE,RUNCNT       ; Where to RETurn to
1856   0B80 D5                  PUSH    DE              ; Save for RETurn
1857   0B81 C8          IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1858   0B82 D6 80       ONJMP:  SUB     ZEND            ; Is it a token?
1859   0B84 DA 48 0D            JP      C,LET           ; No - try to assign it
1860   0B87 FE 25               CP      ZNEW+1-ZEND     ; END to NEW ?
1861   0B89 D2 42 07            JP      NC,SNERR        ; Not a key word - ?SN Error
1862   0B8C 07                  RLCA                    ; Double it
1863   0B8D 4F                  LD      C,A             ; BC = Offset into table
1864   0B8E 06 00               LD      B,0
1865   0B90 EB                  EX      DE,HL           ; Save code string address
1866   0B91 21 EA 05            LD      HL,WORDTB       ; Keyword address table
1867   0B94 09                  ADD     HL,BC           ; Point to routine address
1868   0B95 4E                  LD      C,(HL)          ; Get LSB of routine address
1869   0B96 23                  INC     HL
1870   0B97 46                  LD      B,(HL)          ; Get MSB of routine address
1871   0B98 C5                  PUSH    BC              ; Save routine address
1872   0B99 EB                  EX      DE,HL           ; Restore code string address
1873   0B9A             
1874   0B9A 23          GETCHR: INC     HL              ; Point to next character
1875   0B9B 7E                  LD      A,(HL)          ; Get next code string byte
1876   0B9C FE 3A               CP      ':'             ; Z if ':'
1877   0B9E D0                  RET     NC              ; NC if > "9"
1878   0B9F FE 20               CP      ' '
1879   0BA1 CA 9A 0B            JP      Z,GETCHR        ; Skip over spaces
1880   0BA4 FE 30               CP      '0'
1881   0BA6 3F                  CCF                     ; NC if < '0'
1882   0BA7 3C                  INC     A               ; Test for zero - Leave carry
1883   0BA8 3D                  DEC     A               ; Z if Null
1884   0BA9 C9                  RET
1885   0BAA             
1886   0BAA EB          RESTOR: EX      DE,HL           ; Save code string address
1887   0BAB 2A 0E 31            LD      HL,(BASTXT)     ; Point to start of program
1888   0BAE CA BF 0B            JP      Z,RESTNL        ; Just RESTORE - reset pointer
1889   0BB1 EB                  EX      DE,HL           ; Restore code string address
1890   0BB2 CD 66 0C            CALL    ATOH            ; Get line number to DE
1891   0BB5 E5                  PUSH    HL              ; Save code string address
1892   0BB6 CD 2E 08            CALL    SRCHLN          ; Search for line number in DE
1893   0BB9 60                  LD      H,B             ; HL = Address of line
1894   0BBA 69                  LD      L,C
1895   0BBB D1                  POP     DE              ; Restore code string address
1896   0BBC D2 07 0D            JP      NC,ULERR        ; ?UL Error if not found
1897   0BBF 2B          RESTNL: DEC     HL              ; Byte before DATA statement
1898   0BC0 22 8C 31    UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1899   0BC3 EB                  EX      DE,HL           ; Restore code string address
1900   0BC4 C9                  RET
1901   0BC5             
1902   0BC5             
1903   0BC5 DF          TSTBRK: RST     18H             ; Check input status
1904   0BC6 C8                  RET     Z               ; No key, go back
1905   0BC7 D7                  RST     10H             ; Get the key into A
1906   0BC8 FE 1B               CP      ESC             ; Escape key?
1907   0BCA 28 11               JR      Z,BRK           ; Yes, break
1908   0BCC FE 03               CP      CTRLC           ; <Ctrl-C>
1909   0BCE 28 0D               JR      Z,BRK           ; Yes, break
1910   0BD0 FE 13               CP      CTRLS           ; Stop scrolling?
1911   0BD2 C0                  RET     NZ              ; Other key, ignore
1912   0BD3             
1913   0BD3             
1914   0BD3 D7          STALL:  RST     10H             ; Wait for key
1915   0BD4 FE 11               CP      CTRLQ           ; Resume scrolling?
1916   0BD6 C8                  RET      Z              ; Release the chokehold
1917   0BD7 FE 03               CP      CTRLC           ; Second break?
1918   0BD9 28 07               JR      Z,STOP          ; Break during hold exits prog
1919   0BDB 18 F6               JR      STALL           ; Loop until <Ctrl-Q> or <brk>
1920   0BDD             
1921   0BDD 3E FF       BRK     LD      A,$FF           ; Set BRKFLG
1922   0BDF 32 FD 30            LD      (BRKFLG),A      ; Store it
1923   0BE2             
1924   0BE2             
1925   0BE2 C0          STOP:   RET     NZ              ; Exit if anything else
1926   0BE3 F6                  .BYTE   0F6H            ; Flag "STOP"
1927   0BE4 C0          PEND:   RET     NZ              ; Exit if anything else
1928   0BE5 22 7E 31            LD      (BRKLIN),HL     ; Save point of break
1929   0BE8 21                  .BYTE   21H             ; Skip "OR 11111111B"
1930   0BE9 F6 FF       INPBRK: OR      11111111B       ; Flag "Break" wanted
1931   0BEB C1                  POP     BC              ; Return not needed and more
1932   0BEC 2A 0C 31    ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1933   0BEF F5                  PUSH    AF              ; Save STOP / END status
1934   0BF0 7D                  LD      A,L             ; Is it direct break?
1935   0BF1 A4                  AND     H
1936   0BF2 3C                  INC     A               ; Line is -1 if direct break
1937   0BF3 CA FF 0B            JP      Z,NOLIN         ; Yes - No line number
1938   0BF6 22 82 31            LD      (ERRLIN),HL     ; Save line of break
1939   0BF9 2A 7E 31            LD      HL,(BRKLIN)     ; Get point of break
1940   0BFC 22 84 31            LD      (CONTAD),HL     ; Save point to CONTinue
1941   0BFF AF          NOLIN:  XOR     A
1942   0C00 32 F5 30            LD      (CTLOFG),A      ; Enable output
1943   0C03 CD 35 0E            CALL    STTLIN          ; Start a new line
1944   0C06 F1                  POP     AF              ; Restore STOP / END status
1945   0C07 21 E5 06            LD      HL,BRKMSG       ; "Break" message
1946   0C0A C2 76 07            JP      NZ,ERRIN        ; "in line" wanted?
1947   0C0D C3 8D 07            JP      PRNTOK          ; Go to command mode
1948   0C10             
1949   0C10 2A 84 31    CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1950   0C13 7C                  LD      A,H             ; Is it zero?
1951   0C14 B5                  OR      L
1952   0C15 1E 20               LD      E,CN            ; ?CN Error
1953   0C17 CA 56 07            JP      Z,ERROR         ; Yes - output "?CN Error"
1954   0C1A EB                  EX      DE,HL           ; Save code string address
1955   0C1B 2A 82 31            LD      HL,(ERRLIN)     ; Get line of last break
1956   0C1E 22 0C 31            LD      (LINEAT),HL     ; Set up current line number
1957   0C21 EB                  EX      DE,HL           ; Restore code string address
1958   0C22 C9                  RET                     ; CONTinue where left off
1959   0C23             
1960   0C23 CD 68 17    NULL:   CALL    GETINT          ; Get integer 0-255
1961   0C26 C0                  RET     NZ              ; Return if bad value
1962   0C27 32 F1 30            LD      (NULLS),A       ; Set nulls number
1963   0C2A C9                  RET
1964   0C2B             
1965   0C2B             
1966   0C2B E5          ACCSUM: PUSH    HL              ; Save address in array
1967   0C2C 2A FA 30            LD      HL,(CHKSUM)     ; Get check sum
1968   0C2F 06 00               LD      B,0             ; BC - Value of byte
1969   0C31 4F                  LD      C,A
1970   0C32 09                  ADD     HL,BC           ; Add byte to check sum
1971   0C33 22 FA 30            LD      (CHKSUM),HL     ; Re-save check sum
1972   0C36 E1                  POP     HL              ; Restore address in array
1973   0C37 C9                  RET
1974   0C38             
1975   0C38 7E          CHKLTR: LD      A,(HL)          ; Get byte
1976   0C39 FE 41               CP      'A'             ; < 'a' ?
1977   0C3B D8                  RET     C               ; Carry set if not letter
1978   0C3C FE 5B               CP      'Z'+1           ; > 'z' ?
1979   0C3E 3F                  CCF
1980   0C3F C9                  RET                     ; Carry set if not letter
1981   0C40             
1982   0C40 CD 9A 0B    FPSINT: CALL    GETCHR          ; Get next character
1983   0C43 CD 07 10    POSINT: CALL    GETNUM          ; Get integer 0 to 32767
1984   0C46 CD E9 19    DEPINT: CALL    TSTSGN          ; Test sign of FPREG
1985   0C49 FA 61 0C            JP      M,FCERR         ; Negative - ?FC Error
1986   0C4C 3A 97 31    DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
1987   0C4F FE 90               CP      80H+16          ; Exponent in range (16 bits)?
1988   0C51 DA 91 1A            JP      C,FPINT         ; Yes - convert it
1989   0C54 01 80 90            LD      BC,9080H        ; BCDE = -32768
1990   0C57 11 00 00            LD      DE,0000
1991   0C5A E5                  PUSH    HL              ; Save code string address
1992   0C5B CD 64 1A            CALL    CMPNUM          ; Compare FPREG with BCDE
1993   0C5E E1                  POP     HL              ; Restore code string address
1994   0C5F 51                  LD      D,C             ; MSB to D
1995   0C60 C8                  RET     Z               ; Return if in range
1996   0C61 1E 08       FCERR:  LD      E,FC            ; ?FC Error
1997   0C63 C3 56 07            JP      ERROR           ; Output error-
1998   0C66             
1999   0C66 2B          ATOH:   DEC     HL              ; ASCII number to DE binary
2000   0C67 11 00 00    GETLN:  LD      DE,0            ; Get number to DE
2001   0C6A CD 9A 0B    GTLNLP: CALL    GETCHR          ; Get next character
2002   0C6D D0                  RET     NC              ; Exit if not a digit
2003   0C6E E5                  PUSH    HL              ; Save code string address
2004   0C6F F5                  PUSH    AF              ; Save digit
2005   0C70 21 98 19            LD      HL,65529/10     ; Largest number 65529
2006   0C73 CD 0A 0A            CALL    CPDEHL          ; Number in range?
2007   0C76 DA 42 07            JP      C,SNERR         ; No - ?SN Error
2008   0C79 62                  LD      H,D             ; HL = Number
2009   0C7A 6B                  LD      L,E
2010   0C7B 19                  ADD     HL,DE           ; Times 2
2011   0C7C 29                  ADD     HL,HL           ; Times 4
2012   0C7D 19                  ADD     HL,DE           ; Times 5
2013   0C7E 29                  ADD     HL,HL           ; Times 10
2014   0C7F F1                  POP     AF              ; Restore digit
2015   0C80 D6 30               SUB     '0'             ; Make it 0 to 9
2016   0C82 5F                  LD      E,A             ; DE = Value of digit
2017   0C83 16 00               LD      D,0
2018   0C85 19                  ADD     HL,DE           ; Add to number
2019   0C86 EB                  EX      DE,HL           ; Number to DE
2020   0C87 E1                  POP     HL              ; Restore code string address
2021   0C88 C3 6A 0C            JP      GTLNLP          ; Go to next character
2022   0C8B             
2023   0C8B CA 5E 08    CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
2024   0C8E CD 43 0C            CALL    POSINT          ; Get integer 0 to 32767 to DE
2025   0C91 2B                  DEC     HL              ; Cancel increment
2026   0C92 CD 9A 0B            CALL    GETCHR          ; Get next character
2027   0C95 E5                  PUSH    HL              ; Save code string address
2028   0C96 2A 5F 31            LD      HL,(LSTRAM)     ; Get end of RAM
2029   0C99 CA AE 0C            JP      Z,STORED        ; No value given - Use stored
2030   0C9C E1                  POP     HL              ; Restore code string address
2031   0C9D CD 10 0A            CALL    CHKSYN          ; Check for comma
2032   0CA0 2C                  .BYTE      ','
2033   0CA1 D5                  PUSH    DE              ; Save number
2034   0CA2 CD 43 0C            CALL    POSINT          ; Get integer 0 to 32767
2035   0CA5 2B                  DEC     HL              ; Cancel increment
2036   0CA6 CD 9A 0B            CALL    GETCHR          ; Get next character
2037   0CA9 C2 42 07            JP      NZ,SNERR        ; ?SN Error if more on line
2038   0CAC E3                  EX      (SP),HL         ; Save code string address
2039   0CAD EB                  EX      DE,HL           ; Number to DE
2040   0CAE 7D          STORED: LD      A,L             ; Get LSB of new RAM top
2041   0CAF 93                  SUB     E               ; Subtract LSB of string space
2042   0CB0 5F                  LD      E,A             ; Save LSB
2043   0CB1 7C                  LD      A,H             ; Get MSB of new RAM top
2044   0CB2 9A                  SBC     A,D             ; Subtract MSB of string space
2045   0CB3 57                  LD      D,A             ; Save MSB
2046   0CB4 DA 37 07            JP      C,OMERR         ; ?OM Error if not enough mem
2047   0CB7 E5                  PUSH    HL              ; Save RAM top
2048   0CB8 2A 86 31            LD      HL,(PROGND)     ; Get program end
2049   0CBB 01 28 00            LD      BC,40           ; 40 Bytes minimum working RAM
2050   0CBE 09                  ADD     HL,BC           ; Get lowest address
2051   0CBF CD 0A 0A            CALL    CPDEHL          ; Enough memory?
2052   0CC2 D2 37 07            JP      NC,OMERR        ; No - ?OM Error
2053   0CC5 EB                  EX      DE,HL           ; RAM top to HL
2054   0CC6 22 0A 31            LD      (STRSPC),HL     ; Set new string space
2055   0CC9 E1                  POP     HL              ; End of memory to use
2056   0CCA 22 5F 31            LD      (LSTRAM),HL     ; Set new top of RAM
2057   0CCD E1                  POP     HL              ; Restore code string address
2058   0CCE C3 5E 08            JP      INTVAR          ; Initialise variables
2059   0CD1             
2060   0CD1 CA 5A 08    RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
2061   0CD4 CD 5E 08            CALL    INTVAR          ; Initialise variables
2062   0CD7 01 5A 0B            LD      BC,RUNCNT       ; Execution driver loop
2063   0CDA C3 ED 0C            JP      RUNLIN          ; RUN from line number
2064   0CDD             
2065   0CDD 0E 03       GOSUB:  LD      C,3             ; 3 Levels of stack needed
2066   0CDF CD 1F 07            CALL    CHKSTK          ; Check for 3 levels of stack
2067   0CE2 C1                  POP     BC              ; Get return address
2068   0CE3 E5                  PUSH    HL              ; Save code string for RETURN
2069   0CE4 E5                  PUSH    HL              ; And for GOSUB routine
2070   0CE5 2A 0C 31            LD      HL,(LINEAT)     ; Get current line
2071   0CE8 E3                  EX      (SP),HL         ; Into stack - Code string out
2072   0CE9 3E 8C               LD      A,ZGOSUB        ; "GOSUB" token
2073   0CEB F5                  PUSH    AF              ; Save token
2074   0CEC 33                  INC     SP              ; Don't save flags
2075   0CED             
2076   0CED C5          RUNLIN: PUSH    BC              ; Save return address
2077   0CEE CD 66 0C    GOTO:   CALL    ATOH            ; ASCII number to DE binary
2078   0CF1 CD 33 0D            CALL    REM             ; Get end of line
2079   0CF4 E5                  PUSH    HL              ; Save end of line
2080   0CF5 2A 0C 31            LD      HL,(LINEAT)     ; Get current line
2081   0CF8 CD 0A 0A            CALL    CPDEHL          ; Line after current?
2082   0CFB E1                  POP     HL              ; Restore end of line
2083   0CFC 23                  INC     HL              ; Start of next line
2084   0CFD DC 31 08            CALL    C,SRCHLP        ; Line is after current line
2085   0D00 D4 2E 08            CALL    NC,SRCHLN       ; Line is before current line
2086   0D03 60                  LD      H,B             ; Set up code string address
2087   0D04 69                  LD      L,C
2088   0D05 2B                  DEC     HL              ; Incremented after
2089   0D06 D8                  RET     C               ; Line found
2090   0D07 1E 0E       ULERR:  LD      E,UL            ; ?UL Error
2091   0D09 C3 56 07            JP      ERROR           ; Output error message
2092   0D0C             
2093   0D0C C0          RETURN: RET     NZ              ; Return if not just RETURN
2094   0D0D 16 FF               LD      D,-1            ; Flag "GOSUB" search
2095   0D0F CD EB 06            CALL    BAKSTK          ; Look "GOSUB" block
2096   0D12 F9                  LD      SP,HL           ; Kill all FORs in subroutine
2097   0D13 FE 8C               CP      ZGOSUB          ; Test for "GOSUB" token
2098   0D15 1E 04               LD      E,RG            ; ?RG Error
2099   0D17 C2 56 07            JP      NZ,ERROR        ; Error if no "GOSUB" found
2100   0D1A E1                  POP     HL              ; Get RETURN line number
2101   0D1B 22 0C 31            LD      (LINEAT),HL     ; Save as current
2102   0D1E 23                  INC     HL              ; Was it from direct statement?
2103   0D1F 7C                  LD      A,H
2104   0D20 B5                  OR      L               ; Return to line
2105   0D21 C2 2B 0D            JP      NZ,RETLIN       ; No - Return to line
2106   0D24 3A 7C 31            LD      A,(LSTBIN)      ; Any INPUT in subroutine?
2107   0D27 B7                  OR      A               ; If so buffer is corrupted
2108   0D28 C2 8C 07            JP      NZ,POPNOK       ; Yes - Go to command mode
2109   0D2B 21 5A 0B    RETLIN: LD      HL,RUNCNT       ; Execution driver loop
2110   0D2E E3                  EX      (SP),HL         ; Into stack - Code string out
2111   0D2F 3E                  .BYTE      3EH             ; Skip "POP HL"
2112   0D30 E1          NXTDTA: POP     HL              ; Restore code string address
2113   0D31             
2114   0D31 01 3A       DATA:   .BYTE      01H,3AH         ; ':' End of statement
2115   0D33 0E 00       REM:    LD      C,0             ; 00  End of statement
2116   0D35 06 00               LD      B,0
2117   0D37 79          NXTSTL: LD      A,C             ; Statement and byte
2118   0D38 48                  LD      C,B
2119   0D39 47                  LD      B,A             ; Statement end byte
2120   0D3A 7E          NXTSTT: LD      A,(HL)          ; Get byte
2121   0D3B B7                  OR      A               ; End of line?
2122   0D3C C8                  RET     Z               ; Yes - Exit
2123   0D3D B8                  CP      B               ; End of statement?
2124   0D3E C8                  RET     Z               ; Yes - Exit
2125   0D3F 23                  INC     HL              ; Next byte
2126   0D40 FE 22               CP      '"'             ; Literal string?
2127   0D42 CA 37 0D            JP      Z,NXTSTL        ; Yes - Look for another '"'
2128   0D45 C3 3A 0D            JP      NXTSTT          ; Keep looking
2129   0D48             
2130   0D48 CD FD 11    LET:    CALL    GETVAR          ; Get variable name
2131   0D4B CD 10 0A            CALL    CHKSYN          ; Make sure "=" follows
2132   0D4E B4                  .BYTE      ZEQUAL          ; "=" token
2133   0D4F D5                  PUSH    DE              ; Save address of variable
2134   0D50 3A 5D 31            LD      A,(TYPE)        ; Get data type
2135   0D53 F5                  PUSH    AF              ; Save type
2136   0D54 CD 19 10            CALL    EVAL            ; Evaluate expression
2137   0D57 F1                  POP     AF              ; Restore type
2138   0D58 E3                  EX      (SP),HL         ; Save code - Get var addr
2139   0D59 22 7E 31            LD      (BRKLIN),HL     ; Save address of variable
2140   0D5C 1F                  RRA                     ; Adjust type
2141   0D5D CD 0C 10            CALL    CHKTYP          ; Check types are the same
2142   0D60 CA 9B 0D            JP      Z,LETNUM        ; Numeric - Move value
2143   0D63 E5          LETSTR: PUSH    HL              ; Save address of string var
2144   0D64 2A 94 31            LD      HL,(FPREG)      ; Pointer to string entry
2145   0D67 E5                  PUSH    HL              ; Save it on stack
2146   0D68 23                  INC     HL              ; Skip over length
2147   0D69 23                  INC     HL
2148   0D6A 5E                  LD      E,(HL)          ; LSB of string address
2149   0D6B 23                  INC     HL
2150   0D6C 56                  LD      D,(HL)          ; MSB of string address
2151   0D6D 2A 0E 31            LD      HL,(BASTXT)     ; Point to start of program
2152   0D70 CD 0A 0A            CALL    CPDEHL          ; Is string before program?
2153   0D73 D2 8A 0D            JP      NC,CRESTR       ; Yes - Create string entry
2154   0D76 2A 0A 31            LD      HL,(STRSPC)     ; Point to string space
2155   0D79 CD 0A 0A            CALL    CPDEHL          ; Is string literal in program?
2156   0D7C D1                  POP     DE              ; Restore address of string
2157   0D7D D2 92 0D            JP      NC,MVSTPT       ; Yes - Set up pointer
2158   0D80 21 6F 31            LD      HL,TMPSTR       ; Temporary string pool
2159   0D83 CD 0A 0A            CALL    CPDEHL          ; Is string in temporary pool?
2160   0D86 D2 92 0D            JP      NC,MVSTPT       ; No - Set up pointer
2161   0D89 3E                  .BYTE   3EH             ; Skip "POP DE"
2162   0D8A D1          CRESTR: POP     DE              ; Restore address of string
2163   0D8B CD 41 16            CALL    BAKTMP          ; Back to last tmp-str entry
2164   0D8E EB                  EX      DE,HL           ; Address of string entry
2165   0D8F CD 7A 14            CALL    SAVSTR          ; Save string in string area
2166   0D92 CD 41 16    MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
2167   0D95 E1                  POP     HL              ; Get string pointer
2168   0D96 CD 44 1A            CALL    DETHL4          ; Move string pointer to var
2169   0D99 E1                  POP     HL              ; Restore code string address
2170   0D9A C9                  RET
2171   0D9B             
2172   0D9B E5          LETNUM: PUSH    HL              ; Save address of variable
2173   0D9C CD 41 1A            CALL    FPTHL           ; Move value to variable
2174   0D9F D1                  POP     DE              ; Restore address of variable
2175   0DA0 E1                  POP     HL              ; Restore code string address
2176   0DA1 C9                  RET
2177   0DA2             
2178   0DA2 CD 68 17    ON:     CALL    GETINT          ; Get integer 0-255
2179   0DA5 7E                  LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
2180   0DA6 47                  LD      B,A             ; Save in B
2181   0DA7 FE 8C               CP      ZGOSUB          ; "GOSUB" token?
2182   0DA9 CA B1 0D            JP      Z,ONGO          ; Yes - Find line number
2183   0DAC CD 10 0A            CALL    CHKSYN          ; Make sure it's "GOTO"
2184   0DAF 88                  .BYTE   ZGOTO           ; "GOTO" token
2185   0DB0 2B                  DEC     HL              ; Cancel increment
2186   0DB1 4B          ONGO:   LD      C,E             ; Integer of branch value
2187   0DB2 0D          ONGOLP: DEC     C               ; Count branches
2188   0DB3 78                  LD      A,B             ; Get "GOTO" or "GOSUB" token
2189   0DB4 CA 82 0B            JP      Z,ONJMP         ; Go to that line if right one
2190   0DB7 CD 67 0C            CALL    GETLN           ; Get line number to DE
2191   0DBA FE 2C               CP      ','             ; Another line number?
2192   0DBC C0                  RET     NZ              ; No - Drop through
2193   0DBD C3 B2 0D            JP      ONGOLP          ; Yes - loop
2194   0DC0             
2195   0DC0 CD 19 10    IF:     CALL    EVAL            ; Evaluate expression
2196   0DC3 7E                  LD      A,(HL)          ; Get token
2197   0DC4 FE 88               CP      ZGOTO           ; "GOTO" token?
2198   0DC6 CA CE 0D            JP      Z,IFGO          ; Yes - Get line
2199   0DC9 CD 10 0A            CALL    CHKSYN          ; Make sure it's "THEN"
2200   0DCC A9                  .BYTE      ZTHEN           ; "THEN" token
2201   0DCD 2B                  DEC     HL              ; Cancel increment
2202   0DCE CD 0A 10    IFGO:   CALL    TSTNUM          ; Make sure it's numeric
2203   0DD1 CD E9 19            CALL    TSTSGN          ; Test state of expression
2204   0DD4 CA 33 0D            JP      Z,REM           ; False - Drop through
2205   0DD7 CD 9A 0B            CALL    GETCHR          ; Get next character
2206   0DDA DA EE 0C            JP      C,GOTO          ; Number - GOTO that line
2207   0DDD C3 81 0B            JP      IFJMP           ; Otherwise do statement
2208   0DE0             
2209   0DE0 2B          MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
2210   0DE1 CD 9A 0B            CALL    GETCHR          ; Get next character
2211   0DE4 CA 42 0E    PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
2212   0DE7 C8          PRNTLP: RET     Z               ; End of list - Exit
2213   0DE8 FE A5               CP      ZTAB            ; "TAB(" token?
2214   0DEA CA 75 0E            JP      Z,DOTAB         ; Yes - Do TAB routine
2215   0DED FE A8               CP      ZSPC            ; "SPC(" token?
2216   0DEF CA 75 0E            JP      Z,DOTAB         ; Yes - Do SPC routine
2217   0DF2 E5                  PUSH    HL              ; Save code string address
2218   0DF3 FE 2C               CP      ','             ; Comma?
2219   0DF5 CA 5E 0E            JP      Z,DOCOM         ; Yes - Move to next zone
2220   0DF8 FE 3B               CP      59 ;";"         ; Semi-colon?
2221   0DFA CA 98 0E            JP      Z,NEXITM        ; Do semi-colon routine
2222   0DFD C1                  POP     BC              ; Code string address to BC
2223   0DFE CD 19 10            CALL    EVAL            ; Evaluate expression
2224   0E01 E5                  PUSH    HL              ; Save code string address
2225   0E02 3A 5D 31            LD      A,(TYPE)        ; Get variable type
2226   0E05 B7                  OR      A               ; Is it a string variable?
2227   0E06 C2 2E 0E            JP      NZ,PRNTST       ; Yes - Output string contents
2228   0E09 CD 8E 1B            CALL    NUMASC          ; Convert number to text
2229   0E0C CD 9E 14            CALL    CRTST           ; Create temporary string
2230   0E0F 36 20               LD      (HL),' '        ; Followed by a space
2231   0E11 2A 94 31            LD      HL,(FPREG)      ; Get length of output
2232   0E14 34                  INC     (HL)            ; Plus 1 for the space
2233   0E15 2A 94 31            LD      HL,(FPREG)      ; < Not needed >
2234   0E18 3A F2 30            LD      A,(LWIDTH)      ; Get width of line
2235   0E1B 47                  LD      B,A             ; To B
2236   0E1C 04                  INC     B               ; Width 255 (No limit)?
2237   0E1D CA 2A 0E            JP      Z,PRNTNB        ; Yes - Output number string
2238   0E20 04                  INC     B               ; Adjust it
2239   0E21 3A 5B 31            LD      A,(CURPOS)      ; Get cursor position
2240   0E24 86                  ADD     A,(HL)          ; Add length of string
2241   0E25 3D                  DEC     A               ; Adjust it
2242   0E26 B8                  CP      B               ; Will output fit on this line?
2243   0E27 D4 42 0E            CALL    NC,PRNTCRLF     ; No - CRLF first
2244   0E2A CD E3 14    PRNTNB: CALL    PRS1            ; Output string at (HL)
2245   0E2D AF                  XOR     A               ; Skip CALL by setting 'z' flag
2246   0E2E C4 E3 14    PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
2247   0E31 E1                  POP     HL              ; Restore code string address
2248   0E32 C3 E0 0D            JP      MRPRNT          ; See if more to PRINT
2249   0E35             
2250   0E35 3A 5B 31    STTLIN: LD      A,(CURPOS)      ; Make sure on new line
2251   0E38 B7                  OR      A               ; Already at start?
2252   0E39 C8                  RET     Z               ; Yes - Do nothing
2253   0E3A C3 42 0E            JP      PRNTCRLF        ; Start a new line
2254   0E3D             
2255   0E3D 36 00       ENDINP: LD      (HL),0          ; Mark end of buffer
2256   0E3F 21 10 31            LD      HL,BUFFER-1     ; Point to buffer
2257   0E42 3E 0D       PRNTCRLF: LD    A,CR            ; Load a CR
2258   0E44 CD 1B 0A            CALL    OUTC            ; Output character
2259   0E47 3E 0A               LD      A,LF            ; Load a LF
2260   0E49 CD 1B 0A            CALL    OUTC            ; Output character
2261   0E4C AF          DONULL: XOR     A               ; Set to position 0
2262   0E4D 32 5B 31            LD      (CURPOS),A      ; Store it
2263   0E50 3A F1 30            LD      A,(NULLS)       ; Get number of nulls
2264   0E53 3D          NULLP:  DEC     A               ; Count them
2265   0E54 C8                  RET     Z               ; Return if done
2266   0E55 F5                  PUSH    AF              ; Save count
2267   0E56 AF                  XOR     A               ; Load a null
2268   0E57 CD 1B 0A            CALL    OUTC            ; Output it
2269   0E5A F1                  POP     AF              ; Restore count
2270   0E5B C3 53 0E            JP      NULLP           ; Keep counting
2271   0E5E             
2272   0E5E 3A F3 30    DOCOM:  LD      A,(COMMAN)      ; Get comma width
2273   0E61 47                  LD      B,A             ; Save in B
2274   0E62 3A 5B 31            LD      A,(CURPOS)      ; Get current position
2275   0E65 B8                  CP      B               ; Within the limit?
2276   0E66 D4 42 0E            CALL    NC,PRNTCRLF     ; No - output CRLF
2277   0E69 D2 98 0E            JP      NC,NEXITM       ; Get next item
2278   0E6C D6 0E       ZONELP: SUB     14              ; Next zone of 14 characters
2279   0E6E D2 6C 0E            JP      NC,ZONELP       ; Repeat if more zones
2280   0E71 2F                  CPL                     ; Number of spaces to output
2281   0E72 C3 8D 0E            JP      ASPCS           ; Output them
2282   0E75             
2283   0E75 F5          DOTAB:  PUSH    AF              ; Save token
2284   0E76 CD 65 17            CALL    FNDNUM          ; Evaluate expression
2285   0E79 CD 10 0A            CALL    CHKSYN          ; Make sure ")" follows
2286   0E7C 29                  .BYTE   ")"
2287   0E7D 2B                  DEC     HL              ; Back space on to ")"
2288   0E7E F1                  POP     AF              ; Restore token
2289   0E7F D6 A8               SUB     ZSPC            ; Was it "SPC(" ?
2290   0E81 E5                  PUSH    HL              ; Save code string address
2291   0E82 CA 88 0E            JP      Z,DOSPC         ; Yes - Do 'E' spaces
2292   0E85 3A 5B 31            LD      A,(CURPOS)      ; Get current position
2293   0E88 2F          DOSPC:  CPL                     ; Number of spaces to print to
2294   0E89 83                  ADD     A,E             ; Total number to print
2295   0E8A D2 98 0E            JP      NC,NEXITM       ; TAB < Current POS(X)
2296   0E8D 3C          ASPCS:  INC     A               ; Output A spaces
2297   0E8E 47                  LD      B,A             ; Save number to print
2298   0E8F 3E 20               LD      A,' '           ; Space
2299   0E91 CD 1B 0A    SPCLP:  CALL    OUTC            ; Output character in A
2300   0E94 05                  DEC     B               ; Count them
2301   0E95 C2 91 0E            JP      NZ,SPCLP        ; Repeat if more
2302   0E98 E1          NEXITM: POP     HL              ; Restore code string address
2303   0E99 CD 9A 0B            CALL    GETCHR          ; Get next character
2304   0E9C C3 E7 0D            JP      PRNTLP          ; More to print
2305   0E9F             
2306   0E9F 3F5265646F20REDO:   .BYTE   "?Redo from start",CR,LF,0
2306   0EA5 66726F6D2073746172740D0A00
2307   0EB2             
2308   0EB2 3A 7D 31    BADINP: LD      A,(READFG)      ; READ or INPUT?
2309   0EB5 B7                  OR      A
2310   0EB6 C2 3C 07            JP      NZ,DATSNR       ; READ - ?SN Error
2311   0EB9 C1                  POP     BC              ; Throw away code string addr
2312   0EBA 21 9F 0E            LD      HL,REDO         ; "Redo from start" message
2313   0EBD CD E0 14            CALL    PRS             ; Output string
2314   0EC0 C3 8D 08            JP      DOAGN           ; Do last INPUT again
2315   0EC3             
2316   0EC3 CD 4B 14    INPUT:  CALL    IDTEST          ; Test for illegal direct
2317   0EC6 7E                  LD      A,(HL)          ; Get character after "INPUT"
2318   0EC7 FE 22               CP      '"'             ; Is there a prompt string?
2319   0EC9 3E 00               LD      A,0             ; Clear A and leave flags
2320   0ECB 32 F5 30            LD      (CTLOFG),A      ; Enable output
2321   0ECE C2 DD 0E            JP      NZ,NOPMPT       ; No prompt - get input
2322   0ED1 CD 9F 14            CALL    QTSTR           ; Get string terminated by '"'
2323   0ED4 CD 10 0A            CALL    CHKSYN          ; Check for ';' after prompt
2324   0ED7 3B                  .BYTE   ';'
2325   0ED8 E5                  PUSH    HL              ; Save code string address
2326   0ED9 CD E3 14            CALL    PRS1            ; Output prompt string
2327   0EDC 3E                  .BYTE   3EH             ; Skip "PUSH HL"
2328   0EDD E5          NOPMPT: PUSH    HL              ; Save code string address
2329   0EDE CD 91 08            CALL    PROMPT          ; Get input with "? " prompt
2330   0EE1 C1                  POP     BC              ; Restore code string address
2331   0EE2 DA E9 0B            JP      C,INPBRK        ; Break pressed - Exit
2332   0EE5 23                  INC     HL              ; Next byte
2333   0EE6 7E                  LD      A,(HL)          ; Get it
2334   0EE7 B7                  OR      A               ; End of line?
2335   0EE8 2B                  DEC     HL              ; Back again
2336   0EE9 C5                  PUSH    BC              ; Re-save code string address
2337   0EEA CA 30 0D            JP      Z,NXTDTA        ; Yes - Find next DATA stmt
2338   0EED 36 2C               LD      (HL),','        ; Store comma as separator
2339   0EEF C3 F7 0E            JP      NXTITM          ; Get next item
2340   0EF2             
2341   0EF2 E5          READ:   PUSH    HL              ; Save code string address
2342   0EF3 2A 8C 31            LD      HL,(NXTDAT)     ; Next DATA statement
2343   0EF6 F6                  .BYTE   0F6H            ; Flag "READ"
2344   0EF7 AF          NXTITM: XOR     A               ; Flag "INPUT"
2345   0EF8 32 7D 31            LD      (READFG),A      ; Save "READ"/"INPUT" flag
2346   0EFB E3                  EX      (SP),HL         ; Get code str' , Save pointer
2347   0EFC C3 03 0F            JP      GTVLUS          ; Get values
2348   0EFF             
2349   0EFF CD 10 0A    NEDMOR: CALL    CHKSYN          ; Check for comma between items
2350   0F02 2C                  .BYTE      ','
2351   0F03 CD FD 11    GTVLUS: CALL    GETVAR          ; Get variable name
2352   0F06 E3                  EX      (SP),HL         ; Save code str" , Get pointer
2353   0F07 D5                  PUSH    DE              ; Save variable address
2354   0F08 7E                  LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
2355   0F09 FE 2C               CP      ','             ; Comma?
2356   0F0B CA 2B 0F            JP      Z,ANTVLU        ; Yes - Get another value
2357   0F0E 3A 7D 31            LD      A,(READFG)      ; Is it READ?
2358   0F11 B7                  OR      A
2359   0F12 C2 98 0F            JP      NZ,FDTLP        ; Yes - Find next DATA stmt
2360   0F15 3E 3F               LD      A,'?'           ; More INPUT needed
2361   0F17 CD 1B 0A            CALL    OUTC            ; Output character
2362   0F1A CD 91 08            CALL    PROMPT          ; Get INPUT with prompt
2363   0F1D D1                  POP     DE              ; Variable address
2364   0F1E C1                  POP     BC              ; Code string address
2365   0F1F DA E9 0B            JP      C,INPBRK        ; Break pressed
2366   0F22 23                  INC     HL              ; Point to next DATA byte
2367   0F23 7E                  LD      A,(HL)          ; Get byte
2368   0F24 B7                  OR      A               ; Is it zero (No input) ?
2369   0F25 2B                  DEC     HL              ; Back space INPUT pointer
2370   0F26 C5                  PUSH    BC              ; Save code string address
2371   0F27 CA 30 0D            JP      Z,NXTDTA        ; Find end of buffer
2372   0F2A D5                  PUSH    DE              ; Save variable address
2373   0F2B 3A 5D 31    ANTVLU: LD      A,(TYPE)        ; Check data type
2374   0F2E B7                  OR      A               ; Is it numeric?
2375   0F2F CA 55 0F            JP      Z,INPBIN        ; Yes - Convert to binary
2376   0F32 CD 9A 0B            CALL    GETCHR          ; Get next character
2377   0F35 57                  LD      D,A             ; Save input character
2378   0F36 47                  LD      B,A             ; Again
2379   0F37 FE 22               CP      '"'             ; Start of literal sting?
2380   0F39 CA 49 0F            JP      Z,STRENT        ; Yes - Create string entry
2381   0F3C 3A 7D 31            LD      A,(READFG)      ; "READ" or "INPUT" ?
2382   0F3F B7                  OR      A
2383   0F40 57                  LD      D,A             ; Save 00 if "INPUT"
2384   0F41 CA 46 0F            JP      Z,ITMSEP        ; "INPUT" - End with 00
2385   0F44 16 3A               LD      D,':'           ; "DATA" - End with 00 or ':'
2386   0F46 06 2C       ITMSEP: LD      B,','           ; Item separator
2387   0F48 2B                  DEC     HL              ; Back space for DTSTR
2388   0F49 CD A2 14    STRENT: CALL    DTSTR           ; Get string terminated by D
2389   0F4C EB                  EX      DE,HL           ; String address to DE
2390   0F4D 21 60 0F            LD      HL,LTSTND       ; Where to go after LETSTR
2391   0F50 E3                  EX      (SP),HL         ; Save HL , get input pointer
2392   0F51 D5                  PUSH    DE              ; Save address of string
2393   0F52 C3 63 0D            JP      LETSTR          ; Assign string to variable
2394   0F55             
2395   0F55 CD 9A 0B    INPBIN: CALL    GETCHR          ; Get next character
2396   0F58 CD F0 1A            CALL    ASCTFP          ; Convert ASCII to FP number
2397   0F5B E3                  EX      (SP),HL         ; Save input ptr, Get var addr
2398   0F5C CD 41 1A            CALL    FPTHL           ; Move FPREG to variable
2399   0F5F E1                  POP     HL              ; Restore input pointer
2400   0F60 2B          LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
2401   0F61 CD 9A 0B            CALL    GETCHR          ; Get next character
2402   0F64 CA 6C 0F            JP      Z,MORDT         ; End of line - More needed?
2403   0F67 FE 2C               CP      ','             ; Another value?
2404   0F69 C2 B2 0E            JP      NZ,BADINP       ; No - Bad input
2405   0F6C E3          MORDT:  EX      (SP),HL         ; Get code string address
2406   0F6D 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2407   0F6E CD 9A 0B            CALL    GETCHR          ; Get next character
2408   0F71 C2 FF 0E            JP      NZ,NEDMOR       ; More needed - Get it
2409   0F74 D1                  POP     DE              ; Restore DATA pointer
2410   0F75 3A 7D 31            LD      A,(READFG)      ; "READ" or "INPUT" ?
2411   0F78 B7                  OR      A
2412   0F79 EB                  EX      DE,HL           ; DATA pointer to HL
2413   0F7A C2 C0 0B            JP      NZ,UPDATA       ; Update DATA pointer if "READ"
2414   0F7D D5                  PUSH    DE              ; Save code string address
2415   0F7E B6                  OR      (HL)            ; More input given?
2416   0F7F 21 87 0F            LD      HL,EXTIG        ; "?Extra ignored" message
2417   0F82 C4 E0 14            CALL    NZ,PRS          ; Output string if extra given
2418   0F85 E1                  POP     HL              ; Restore code string address
2419   0F86 C9                  RET
2420   0F87             
2421   0F87 3F4578747261EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
2421   0F8D 2069676E6F7265640D0A00
2422   0F98             
2423   0F98 CD 31 0D    FDTLP:  CALL    DATA            ; Get next statement
2424   0F9B B7                  OR      A               ; End of line?
2425   0F9C C2 B1 0F            JP      NZ,FANDT        ; No - See if DATA statement
2426   0F9F 23                  INC     HL
2427   0FA0 7E                  LD      A,(HL)          ; End of program?
2428   0FA1 23                  INC     HL
2429   0FA2 B6                  OR      (HL)            ; 00 00 Ends program
2430   0FA3 1E 06               LD      E,OD            ; ?OD Error
2431   0FA5 CA 56 07            JP      Z,ERROR         ; Yes - Out of DATA
2432   0FA8 23                  INC     HL
2433   0FA9 5E                  LD      E,(HL)          ; LSB of line number
2434   0FAA 23                  INC     HL
2435   0FAB 56                  LD      D,(HL)          ; MSB of line number
2436   0FAC EB                  EX      DE,HL
2437   0FAD 22 79 31            LD      (DATLIN),HL     ; Set line of current DATA item
2438   0FB0 EB                  EX      DE,HL
2439   0FB1 CD 9A 0B    FANDT:  CALL    GETCHR          ; Get next character
2440   0FB4 FE 83               CP      ZDATA           ; "DATA" token
2441   0FB6 C2 98 0F            JP      NZ,FDTLP        ; No "DATA" - Keep looking
2442   0FB9 C3 2B 0F            JP      ANTVLU          ; Found - Convert input
2443   0FBC             
2444   0FBC 11 00 00    NEXT:   LD      DE,0            ; In case no index given
2445   0FBF C4 FD 11    NEXT1:  CALL    NZ,GETVAR       ; Get index address
2446   0FC2 22 7E 31            LD      (BRKLIN),HL     ; Save code string address
2447   0FC5 CD EB 06            CALL    BAKSTK          ; Look for "FOR" block
2448   0FC8 C2 48 07            JP      NZ,NFERR        ; No "FOR" - ?NF Error
2449   0FCB F9                  LD      SP,HL           ; Clear nested loops
2450   0FCC D5                  PUSH    DE              ; Save index address
2451   0FCD 7E                  LD      A,(HL)          ; Get sign of STEP
2452   0FCE 23                  INC     HL
2453   0FCF F5                  PUSH    AF              ; Save sign of STEP
2454   0FD0 D5                  PUSH    DE              ; Save index address
2455   0FD1 CD 27 1A            CALL    PHLTFP          ; Move index value to FPREG
2456   0FD4 E3                  EX      (SP),HL         ; Save address of TO value
2457   0FD5 E5                  PUSH    HL              ; Save address of index
2458   0FD6 CD 94 17            CALL    ADDPHL          ; Add STEP to index value
2459   0FD9 E1                  POP     HL              ; Restore address of index
2460   0FDA CD 41 1A            CALL    FPTHL           ; Move value to index variable
2461   0FDD E1                  POP     HL              ; Restore address of TO value
2462   0FDE CD 38 1A            CALL    LOADFP          ; Move TO value to BCDE
2463   0FE1 E5                  PUSH    HL              ; Save address of line of FOR
2464   0FE2 CD 64 1A            CALL    CMPNUM          ; Compare index with TO value
2465   0FE5 E1                  POP     HL              ; Restore address of line num
2466   0FE6 C1                  POP     BC              ; Address of sign of STEP
2467   0FE7 90                  SUB     B               ; Compare with expected sign
2468   0FE8 CD 38 1A            CALL    LOADFP          ; BC = Loop stmt,DE = Line num
2469   0FEB CA F7 0F            JP      Z,KILFOR        ; Loop finished - Terminate it
2470   0FEE EB                  EX      DE,HL           ; Loop statement line number
2471   0FEF 22 0C 31            LD      (LINEAT),HL     ; Set loop line number
2472   0FF2 69                  LD      L,C             ; Set code string to loop
2473   0FF3 60                  LD      H,B
2474   0FF4 C3 56 0B            JP      PUTFID          ; Put back "FOR" and continue
2475   0FF7             
2476   0FF7 F9          KILFOR: LD      SP,HL           ; Remove "FOR" block
2477   0FF8 2A 7E 31            LD      HL,(BRKLIN)     ; Code string after "NEXT"
2478   0FFB 7E                  LD      A,(HL)          ; Get next byte in code string
2479   0FFC FE 2C               CP      ','             ; More NEXTs ?
2480   0FFE C2 5A 0B            JP      NZ,RUNCNT       ; No - Do next statement
2481   1001 CD 9A 0B            CALL    GETCHR          ; Position to index name
2482   1004 CD BF 0F            CALL    NEXT1           ; Re-enter NEXT routine
2483   1007             ; < will not RETurn to here , Exit to RUNCNT or Loop >
2484   1007             
2485   1007 CD 19 10    GETNUM: CALL    EVAL            ; Get a numeric expression
2486   100A F6          TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
2487   100B 37          TSTSTR: SCF                     ; Set carry (string)
2488   100C 3A 5D 31    CHKTYP: LD      A,(TYPE)        ; Check types match
2489   100F 8F                  ADC     A,A             ; Expected + actual
2490   1010 B7                  OR      A               ; Clear carry , set parity
2491   1011 E8                  RET     PE              ; Even parity - Types match
2492   1012 C3 54 07            JP      TMERR           ; Different types - Error
2493   1015             
2494   1015 CD 10 0A    OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
2495   1018 28                  .BYTE   "("
2496   1019 2B          EVAL:   DEC     HL              ; Evaluate expression & save
2497   101A 16 00               LD      D,0             ; Precedence value
2498   101C D5          EVAL1:  PUSH    DE              ; Save precedence
2499   101D 0E 01               LD      C,1
2500   101F CD 1F 07            CALL    CHKSTK          ; Check for 1 level of stack
2501   1022 CD 90 10            CALL    OPRND           ; Get next expression value
2502   1025 22 80 31    EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
2503   1028 2A 80 31    EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
2504   102B C1                  POP     BC              ; Precedence value and operator
2505   102C 78                  LD      A,B             ; Get precedence value
2506   102D FE 78               CP      78H             ; "AND" or "OR" ?
2507   102F D4 0A 10            CALL    NC,TSTNUM       ; No - Make sure it's a number
2508   1032 7E                  LD      A,(HL)          ; Get next operator / function
2509   1033 16 00               LD      D,0             ; Clear Last relation
2510   1035 D6 B3       RLTLP:  SUB     ZGTR            ; ">" Token
2511   1037 DA 51 10            JP      C,FOPRND        ; + - * / ^ AND OR - Test it
2512   103A FE 03               CP      ZLTH+1-ZGTR     ; < = >
2513   103C D2 51 10            JP      NC,FOPRND       ; Function - Call it
2514   103F FE 01               CP      ZEQUAL-ZGTR     ; "="
2515   1041 17                  RLA                     ; <- Test for legal
2516   1042 AA                  XOR     D               ; <- combinations of < = >
2517   1043 BA                  CP      D               ; <- by combining last token
2518   1044 57                  LD      D,A             ; <- with current one
2519   1045 DA 42 07            JP      C,SNERR         ; Error if "<<' '==" or ">>"
2520   1048 22 75 31            LD      (CUROPR),HL     ; Save address of current token
2521   104B CD 9A 0B            CALL    GETCHR          ; Get next character
2522   104E C3 35 10            JP      RLTLP           ; Treat the two as one
2523   1051             
2524   1051 7A          FOPRND: LD      A,D             ; < = > found ?
2525   1052 B7                  OR      A
2526   1053 C2 78 11            JP      NZ,TSTRED       ; Yes - Test for reduction
2527   1056 7E                  LD      A,(HL)          ; Get operator token
2528   1057 22 75 31            LD      (CUROPR),HL     ; Save operator address
2529   105A D6 AC               SUB     ZPLUS           ; Operator or function?
2530   105C D8                  RET     C               ; Neither - Exit
2531   105D FE 07               CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
2532   105F D0                  RET     NC              ; No - Exit
2533   1060 5F                  LD      E,A             ; Coded operator
2534   1061 3A 5D 31            LD      A,(TYPE)        ; Get data type
2535   1064 3D                  DEC     A               ; FF = numeric , 00 = string
2536   1065 B3                  OR      E               ; Combine with coded operator
2537   1066 7B                  LD      A,E             ; Get coded operator
2538   1067 CA D6 15            JP      Z,CONCAT        ; String concatenation
2539   106A 07                  RLCA                    ; Times 2
2540   106B 83                  ADD     A,E             ; Times 3
2541   106C 5F                  LD      E,A             ; To DE (D is 0)
2542   106D 21 34 06            LD      HL,PRITAB       ; Precedence table
2543   1070 19                  ADD     HL,DE           ; To the operator concerned
2544   1071 78                  LD      A,B             ; Last operator precedence
2545   1072 56                  LD      D,(HL)          ; Get evaluation precedence
2546   1073 BA                  CP      D               ; Compare with eval precedence
2547   1074 D0                  RET     NC              ; Exit if higher precedence
2548   1075 23                  INC     HL              ; Point to routine address
2549   1076 CD 0A 10            CALL    TSTNUM          ; Make sure it's a number
2550   1079             
2551   1079 C5          STKTHS: PUSH    BC              ; Save last precedence & token
2552   107A 01 28 10            LD      BC,EVAL3        ; Where to go on prec' break
2553   107D C5                  PUSH    BC              ; Save on stack for return
2554   107E 43                  LD      B,E             ; Save operator
2555   107F 4A                  LD      C,D             ; Save precedence
2556   1080 CD 1A 1A            CALL    STAKFP          ; Move value to stack
2557   1083 58                  LD      E,B             ; Restore operator
2558   1084 51                  LD      D,C             ; Restore precedence
2559   1085 4E                  LD      C,(HL)          ; Get LSB of routine address
2560   1086 23                  INC     HL
2561   1087 46                  LD      B,(HL)          ; Get MSB of routine address
2562   1088 23                  INC     HL
2563   1089 C5                  PUSH    BC              ; Save routine address
2564   108A 2A 75 31            LD      HL,(CUROPR)     ; Address of current operator
2565   108D C3 1C 10            JP      EVAL1           ; Loop until prec' break
2566   1090             
2567   1090 AF          OPRND:  XOR     A               ; Get operand routine
2568   1091 32 5D 31            LD      (TYPE),A        ; Set numeric expected
2569   1094 CD 9A 0B            CALL    GETCHR          ; Get next character
2570   1097 1E 24               LD      E,MO            ; ?MO Error
2571   1099 CA 56 07            JP      Z,ERROR         ; No operand - Error
2572   109C DA F0 1A            JP      C,ASCTFP        ; Number - Get value
2573   109F CD 38 0C            CALL    CHKLTR          ; See if a letter
2574   10A2 D2 F7 10            JP      NC,CONVAR       ; Letter - Find variable
2575   10A5 FE 26               CP		'&'				; &H = HEX, &B = BINARY
2576   10A7 20 12               JR		NZ, NOTAMP
2577   10A9 CD 9A 0B            CALL    GETCHR          ; Get next character
2578   10AC FE 48               CP      'H'             ; Hex number indicated? [function added]
2579   10AE CA 34 1F            JP      Z,HEXTFP        ; Convert Hex to FPREG
2580   10B1 FE 42               CP      'B'             ; Binary number indicated? [function added]
2581   10B3 CA A4 1F            JP      Z,BINTFP        ; Convert Bin to FPREG
2582   10B6 1E 02               LD      E,SN            ; If neither then a ?SN Error
2583   10B8 CA 56 07            JP      Z,ERROR         ; 
2584   10BB FE AC       NOTAMP: CP      ZPLUS           ; '+' Token ?
2585   10BD CA 90 10            JP      Z,OPRND         ; Yes - Look for operand
2586   10C0 FE 2E               CP      '.'             ; '.' ?
2587   10C2 CA F0 1A            JP      Z,ASCTFP        ; Yes - Create FP number
2588   10C5 FE AD               CP      ZMINUS          ; '-' Token ?
2589   10C7 CA E6 10            JP      Z,MINUS         ; Yes - Do minus
2590   10CA FE 22               CP      '"'             ; Literal string ?
2591   10CC CA 9F 14            JP      Z,QTSTR         ; Get string terminated by '"'
2592   10CF FE AA               CP      ZNOT            ; "NOT" Token ?
2593   10D1 CA D8 11            JP      Z,EVNOT         ; Yes - Eval NOT expression
2594   10D4 FE A7               CP      ZFN             ; "FN" Token ?
2595   10D6 CA 03 14            JP      Z,DOFN          ; Yes - Do FN routine
2596   10D9 D6 B6               SUB     ZSGN            ; Is it a function?
2597   10DB D2 08 11            JP      NC,FNOFST       ; Yes - Evaluate function
2598   10DE CD 15 10    EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
2599   10E1 CD 10 0A            CALL    CHKSYN          ; Make sure ")" follows
2600   10E4 29                  .BYTE   ")"
2601   10E5 C9                  RET
2602   10E6             
2603   10E6 16 7D       MINUS:  LD      D,7DH           ; '-' precedence
2604   10E8 CD 1C 10            CALL    EVAL1           ; Evaluate until prec' break
2605   10EB 2A 80 31            LD      HL,(NXTOPR)     ; Get next operator address
2606   10EE E5                  PUSH    HL              ; Save next operator address
2607   10EF CD 12 1A            CALL    INVSGN          ; Negate value
2608   10F2 CD 0A 10    RETNUM: CALL    TSTNUM          ; Make sure it's a number
2609   10F5 E1                  POP     HL              ; Restore next operator address
2610   10F6 C9                  RET
2611   10F7             
2612   10F7 CD FD 11    CONVAR: CALL    GETVAR          ; Get variable address to DE
2613   10FA E5          FRMEVL: PUSH    HL              ; Save code string address
2614   10FB EB                  EX      DE,HL           ; Variable address to HL
2615   10FC 22 94 31            LD      (FPREG),HL      ; Save address of variable
2616   10FF 3A 5D 31            LD      A,(TYPE)        ; Get type
2617   1102 B7                  OR      A               ; Numeric?
2618   1103 CC 27 1A            CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
2619   1106 E1                  POP     HL              ; Restore code string address
2620   1107 C9                  RET
2621   1108             
2622   1108 06 00       FNOFST: LD      B,0             ; Get address of function
2623   110A 07                  RLCA                    ; Double function offset
2624   110B 4F                  LD      C,A             ; BC = Offset in function table
2625   110C C5                  PUSH    BC              ; Save adjusted token value
2626   110D CD 9A 0B            CALL    GETCHR          ; Get next character
2627   1110 79                  LD      A,C             ; Get adjusted token value
2628   1111 FE 31               CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
2629   1113 DA 2F 11            JP      C,FNVAL         ; No - Do function
2630   1116 CD 15 10            CALL    OPNPAR          ; Evaluate expression  (X,...
2631   1119 CD 10 0A            CALL    CHKSYN          ; Make sure ',' follows
2632   111C 2C                  .BYTE      ','
2633   111D CD 0B 10            CALL    TSTSTR          ; Make sure it's a string
2634   1120 EB                  EX      DE,HL           ; Save code string address
2635   1121 2A 94 31            LD      HL,(FPREG)      ; Get address of string
2636   1124 E3                  EX      (SP),HL         ; Save address of string
2637   1125 E5                  PUSH    HL              ; Save adjusted token value
2638   1126 EB                  EX      DE,HL           ; Restore code string address
2639   1127 CD 68 17            CALL    GETINT          ; Get integer 0-255
2640   112A EB                  EX      DE,HL           ; Save code string address
2641   112B E3                  EX      (SP),HL         ; Save integer,HL = adj' token
2642   112C C3 37 11            JP      GOFUNC          ; Jump to string function
2643   112F             
2644   112F CD DE 10    FNVAL:  CALL    EVLPAR          ; Evaluate expression
2645   1132 E3                  EX      (SP),HL         ; HL = Adjusted token value
2646   1133 11 F2 10            LD      DE,RETNUM       ; Return number from function
2647   1136 D5                  PUSH    DE              ; Save on stack
2648   1137 01 93 04    GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
2649   113A 09                  ADD     HL,BC           ; Point to right address
2650   113B 4E                  LD      C,(HL)          ; Get LSB of address
2651   113C 23                  INC     HL              ;
2652   113D 66                  LD      H,(HL)          ; Get MSB of address
2653   113E 69                  LD      L,C             ; Address to HL
2654   113F E9                  JP      (HL)            ; Jump to function
2655   1140             
2656   1140 15          SGNEXP: DEC     D               ; Dee to flag negative exponent
2657   1141 FE AD               CP      ZMINUS          ; '-' token ?
2658   1143 C8                  RET     Z               ; Yes - Return
2659   1144 FE 2D               CP      '-'             ; '-' ASCII ?
2660   1146 C8                  RET     Z               ; Yes - Return
2661   1147 14                  INC     D               ; Inc to flag positive exponent
2662   1148 FE 2B               CP      '+'             ; '+' ASCII ?
2663   114A C8                  RET     Z               ; Yes - Return
2664   114B FE AC               CP      ZPLUS           ; '+' token ?
2665   114D C8                  RET     Z               ; Yes - Return
2666   114E 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2667   114F C9                  RET                     ; Return "NZ"
2668   1150             
2669   1150 F6          POR:    .BYTE      0F6H            ; Flag "OR"
2670   1151 AF          PAND:   XOR     A               ; Flag "AND"
2671   1152 F5                  PUSH    AF              ; Save "AND" / "OR" flag
2672   1153 CD 0A 10            CALL    TSTNUM          ; Make sure it's a number
2673   1156 CD 4C 0C            CALL    DEINT           ; Get integer -32768 to 32767
2674   1159 F1                  POP     AF              ; Restore "AND" / "OR" flag
2675   115A EB                  EX      DE,HL           ; <- Get last
2676   115B C1                  POP     BC              ; <-  value
2677   115C E3                  EX      (SP),HL         ; <-  from
2678   115D EB                  EX      DE,HL           ; <-  stack
2679   115E CD 2A 1A            CALL    FPBCDE          ; Move last value to FPREG
2680   1161 F5                  PUSH    AF              ; Save "AND" / "OR" flag
2681   1162 CD 4C 0C            CALL    DEINT           ; Get integer -32768 to 32767
2682   1165 F1                  POP     AF              ; Restore "AND" / "OR" flag
2683   1166 C1                  POP     BC              ; Get value
2684   1167 79                  LD      A,C             ; Get LSB
2685   1168 21 C1 13            LD      HL,ACPASS       ; Address of save AC as current
2686   116B C2 73 11            JP      NZ,POR1         ; Jump if OR
2687   116E A3                  AND     E               ; "AND" LSBs
2688   116F 4F                  LD      C,A             ; Save LSB
2689   1170 78                  LD      A,B             ; Get MBS
2690   1171 A2                  AND     D               ; "AND" MSBs
2691   1172 E9                  JP      (HL)            ; Save AC as current (ACPASS)
2692   1173             
2693   1173 B3          POR1:   OR      E               ; "OR" LSBs
2694   1174 4F                  LD      C,A             ; Save LSB
2695   1175 78                  LD      A,B             ; Get MSB
2696   1176 B2                  OR      D               ; "OR" MSBs
2697   1177 E9                  JP      (HL)            ; Save AC as current (ACPASS)
2698   1178             
2699   1178 21 8A 11    TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2700   117B 3A 5D 31            LD      A,(TYPE)        ; Get data type
2701   117E 1F                  RRA                     ; Carry set = string
2702   117F 7A                  LD      A,D             ; Get last precedence value
2703   1180 17                  RLA                     ; Times 2 plus carry
2704   1181 5F                  LD      E,A             ; To E
2705   1182 16 64               LD      D,64H           ; Relational precedence
2706   1184 78                  LD      A,B             ; Get current precedence
2707   1185 BA                  CP      D               ; Compare with last
2708   1186 D0                  RET     NC              ; Eval if last was rel' or log'
2709   1187 C3 79 10            JP      STKTHS          ; Stack this one and get next
2710   118A             
2711   118A 8C 11       CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
2712   118C 79          CMPLG1: LD      A,C             ; Get data type
2713   118D B7                  OR      A
2714   118E 1F                  RRA
2715   118F C1                  POP     BC              ; Get last expression to BCDE
2716   1190 D1                  POP     DE
2717   1191 F5                  PUSH    AF              ; Save status
2718   1192 CD 0C 10            CALL    CHKTYP          ; Check that types match
2719   1195 21 CE 11            LD      HL,CMPRES       ; Result to comparison
2720   1198 E5                  PUSH    HL              ; Save for RETurn
2721   1199 CA 64 1A            JP      Z,CMPNUM        ; Compare values if numeric
2722   119C AF                  XOR     A               ; Compare two strings
2723   119D 32 5D 31            LD      (TYPE),A        ; Set type to numeric
2724   11A0 D5                  PUSH    DE              ; Save string name
2725   11A1 CD 23 16            CALL    GSTRCU          ; Get current string
2726   11A4 7E                  LD      A,(HL)          ; Get length of string
2727   11A5 23                  INC     HL
2728   11A6 23                  INC     HL
2729   11A7 4E                  LD      C,(HL)          ; Get LSB of address
2730   11A8 23                  INC     HL
2731   11A9 46                  LD      B,(HL)          ; Get MSB of address
2732   11AA D1                  POP     DE              ; Restore string name
2733   11AB C5                  PUSH    BC              ; Save address of string
2734   11AC F5                  PUSH    AF              ; Save length of string
2735   11AD CD 27 16            CALL    GSTRDE          ; Get second string
2736   11B0 CD 38 1A            CALL    LOADFP          ; Get address of second string
2737   11B3 F1                  POP     AF              ; Restore length of string 1
2738   11B4 57                  LD      D,A             ; Length to D
2739   11B5 E1                  POP     HL              ; Restore address of string 1
2740   11B6 7B          CMPSTR: LD      A,E             ; Bytes of string 2 to do
2741   11B7 B2                  OR      D               ; Bytes of string 1 to do
2742   11B8 C8                  RET     Z               ; Exit if all bytes compared
2743   11B9 7A                  LD      A,D             ; Get bytes of string 1 to do
2744   11BA D6 01               SUB     1
2745   11BC D8                  RET     C               ; Exit if end of string 1
2746   11BD AF                  XOR     A
2747   11BE BB                  CP      E               ; Bytes of string 2 to do
2748   11BF 3C                  INC     A
2749   11C0 D0                  RET     NC              ; Exit if end of string 2
2750   11C1 15                  DEC     D               ; Count bytes in string 1
2751   11C2 1D                  DEC     E               ; Count bytes in string 2
2752   11C3 0A                  LD      A,(BC)          ; Byte in string 2
2753   11C4 BE                  CP      (HL)            ; Compare to byte in string 1
2754   11C5 23                  INC     HL              ; Move up string 1
2755   11C6 03                  INC     BC              ; Move up string 2
2756   11C7 CA B6 11            JP      Z,CMPSTR        ; Same - Try next bytes
2757   11CA 3F                  CCF                     ; Flag difference (">" or "<")
2758   11CB C3 F4 19            JP      FLGDIF          ; "<" gives -1 , ">" gives +1
2759   11CE             
2760   11CE 3C          CMPRES: INC     A               ; Increment current value
2761   11CF 8F                  ADC     A,A             ; Double plus carry
2762   11D0 C1                  POP     BC              ; Get other value
2763   11D1 A0                  AND     B               ; Combine them
2764   11D2 C6 FF               ADD     A,-1            ; Carry set if different
2765   11D4 9F                  SBC     A,A             ; 00 - Equal , FF - Different
2766   11D5 C3 FB 19            JP      FLGREL          ; Set current value & continue
2767   11D8             
2768   11D8 16 5A       EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2769   11DA CD 1C 10            CALL    EVAL1           ; Eval until precedence break
2770   11DD CD 0A 10            CALL    TSTNUM          ; Make sure it's a number
2771   11E0 CD 4C 0C            CALL    DEINT           ; Get integer -32768 - 32767
2772   11E3 7B                  LD      A,E             ; Get LSB
2773   11E4 2F                  CPL                     ; Invert LSB
2774   11E5 4F                  LD      C,A             ; Save "NOT" of LSB
2775   11E6 7A                  LD      A,D             ; Get MSB
2776   11E7 2F                  CPL                     ; Invert MSB
2777   11E8 CD C1 13            CALL    ACPASS          ; Save AC as current
2778   11EB C1                  POP     BC              ; Clean up stack
2779   11EC C3 28 10            JP      EVAL3           ; Continue evaluation
2780   11EF             
2781   11EF 2B          DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2782   11F0 CD 9A 0B            CALL    GETCHR          ; Get next character
2783   11F3 C8                  RET     Z               ; End of DIM statement
2784   11F4 CD 10 0A            CALL    CHKSYN          ; Make sure ',' follows
2785   11F7 2C                  .BYTE      ','
2786   11F8 01 EF 11    DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2787   11FB C5                  PUSH    BC              ; Save on stack
2788   11FC F6                  .BYTE      0F6H            ; Flag "Create" variable
2789   11FD AF          GETVAR: XOR     A               ; Find variable address,to DE
2790   11FE 32 5C 31            LD      (LCRFLG),A      ; Set locate / create flag
2791   1201 46                  LD      B,(HL)          ; Get First byte of name
2792   1202 CD 38 0C    GTFNAM: CALL    CHKLTR          ; See if a letter
2793   1205 DA 42 07            JP      C,SNERR         ; ?SN Error if not a letter
2794   1208 AF                  XOR     A
2795   1209 4F                  LD      C,A             ; Clear second byte of name
2796   120A 32 5D 31            LD      (TYPE),A        ; Set type to numeric
2797   120D CD 9A 0B            CALL    GETCHR          ; Get next character
2798   1210 DA 19 12            JP      C,SVNAM2        ; Numeric - Save in name
2799   1213 CD 38 0C            CALL    CHKLTR          ; See if a letter
2800   1216 DA 26 12            JP      C,CHARTY        ; Not a letter - Check type
2801   1219 4F          SVNAM2: LD      C,A             ; Save second byte of name
2802   121A CD 9A 0B    ENDNAM: CALL    GETCHR          ; Get next character
2803   121D DA 1A 12            JP      C,ENDNAM        ; Numeric - Get another
2804   1220 CD 38 0C            CALL    CHKLTR          ; See if a letter
2805   1223 D2 1A 12            JP      NC,ENDNAM       ; Letter - Get another
2806   1226 D6 24       CHARTY: SUB     '$'             ; String variable?
2807   1228 C2 35 12            JP      NZ,NOTSTR       ; No - Numeric variable
2808   122B 3C                  INC     A               ; A = 1 (string type)
2809   122C 32 5D 31            LD      (TYPE),A        ; Set type to string
2810   122F 0F                  RRCA                    ; A = 80H , Flag for string
2811   1230 81                  ADD     A,C             ; 2nd byte of name has bit 7 on
2812   1231 4F                  LD      C,A             ; Resave second byte on name
2813   1232 CD 9A 0B            CALL    GETCHR          ; Get next character
2814   1235 3A 7B 31    NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2815   1238 3D                  DEC     A
2816   1239 CA E2 12            JP      Z,ARLDSV        ; Yes - Get array name
2817   123C F2 45 12            JP      P,NSCFOR        ; No array with "FOR" or "FN"
2818   123F 7E                  LD      A,(HL)          ; Get byte again
2819   1240 D6 28               SUB     '('             ; Subscripted variable?
2820   1242 CA BA 12            JP      Z,SBSCPT        ; Yes - Sort out subscript
2821   1245             
2822   1245 AF          NSCFOR: XOR     A               ; Simple variable
2823   1246 32 7B 31            LD      (FORFLG),A      ; Clear "FOR" flag
2824   1249 E5                  PUSH    HL              ; Save code string address
2825   124A 50                  LD      D,B             ; DE = Variable name to find
2826   124B 59                  LD      E,C
2827   124C 2A 8E 31            LD      HL,(FNRGNM)     ; FN argument name
2828   124F CD 0A 0A            CALL    CPDEHL          ; Is it the FN argument?
2829   1252 11 90 31            LD      DE,FNARG        ; Point to argument value
2830   1255 CA 2A 19            JP      Z,POPHRT        ; Yes - Return FN argument value
2831   1258 2A 88 31            LD      HL,(VAREND)     ; End of variables
2832   125B EB                  EX      DE,HL           ; Address of end of search
2833   125C 2A 86 31            LD      HL,(PROGND)     ; Start of variables address
2834   125F CD 0A 0A    FNDVAR: CALL    CPDEHL          ; End of variable list table?
2835   1262 CA 78 12            JP      Z,CFEVAL        ; Yes - Called from EVAL?
2836   1265 79                  LD      A,C             ; Get second byte of name
2837   1266 96                  SUB     (HL)            ; Compare with name in list
2838   1267 23                  INC     HL              ; Move on to first byte
2839   1268 C2 6D 12            JP      NZ,FNTHR        ; Different - Find another
2840   126B 78                  LD      A,B             ; Get first byte of name
2841   126C 96                  SUB     (HL)            ; Compare with name in list
2842   126D 23          FNTHR:  INC     HL              ; Move on to LSB of value
2843   126E CA AC 12            JP      Z,RETADR        ; Found - Return address
2844   1271 23                  INC     HL              ; <- Skip
2845   1272 23                  INC     HL              ; <- over
2846   1273 23                  INC     HL              ; <- F.P.
2847   1274 23                  INC     HL              ; <- value
2848   1275 C3 5F 12            JP      FNDVAR          ; Keep looking
2849   1278             
2850   1278 E1          CFEVAL: POP     HL              ; Restore code string address
2851   1279 E3                  EX      (SP),HL         ; Get return address
2852   127A D5                  PUSH    DE              ; Save address of variable
2853   127B 11 FA 10            LD      DE,FRMEVL       ; Return address in EVAL
2854   127E CD 0A 0A            CALL    CPDEHL          ; Called from EVAL ?
2855   1281 D1                  POP     DE              ; Restore address of variable
2856   1282 CA AF 12            JP      Z,RETNUL        ; Yes - Return null variable
2857   1285 E3                  EX      (SP),HL         ; Put back return
2858   1286 E5                  PUSH    HL              ; Save code string address
2859   1287 C5                  PUSH    BC              ; Save variable name
2860   1288 01 06 00            LD      BC,6            ; 2 byte name plus 4 byte data
2861   128B 2A 8A 31            LD      HL,(ARREND)     ; End of arrays
2862   128E E5                  PUSH    HL              ; Save end of arrays
2863   128F 09                  ADD     HL,BC           ; Move up 6 bytes
2864   1290 C1                  POP     BC              ; Source address in BC
2865   1291 E5                  PUSH    HL              ; Save new end address
2866   1292 CD 0E 07            CALL    MOVUP           ; Move arrays up
2867   1295 E1                  POP     HL              ; Restore new end address
2868   1296 22 8A 31            LD      (ARREND),HL     ; Set new end address
2869   1299 60                  LD      H,B             ; End of variables to HL
2870   129A 69                  LD      L,C
2871   129B 22 88 31            LD      (VAREND),HL     ; Set new end address
2872   129E             
2873   129E 2B          ZEROLP: DEC     HL              ; Back through to zero variable
2874   129F 36 00               LD      (HL),0          ; Zero byte in variable
2875   12A1 CD 0A 0A            CALL    CPDEHL          ; Done them all?
2876   12A4 C2 9E 12            JP      NZ,ZEROLP       ; No - Keep on going
2877   12A7 D1                  POP     DE              ; Get variable name
2878   12A8 73                  LD      (HL),E          ; Store second character
2879   12A9 23                  INC     HL
2880   12AA 72                  LD      (HL),D          ; Store first character
2881   12AB 23                  INC     HL
2882   12AC EB          RETADR: EX      DE,HL           ; Address of variable in DE
2883   12AD E1                  POP     HL              ; Restore code string address
2884   12AE C9                  RET
2885   12AF             
2886   12AF 32 97 31    RETNUL: LD      (FPEXP),A       ; Set result to zero
2887   12B2 21 DE 06            LD      HL,ZERBYT       ; Also set a null string
2888   12B5 22 94 31            LD      (FPREG),HL      ; Save for EVAL
2889   12B8 E1                  POP     HL              ; Restore code string address
2890   12B9 C9                  RET
2891   12BA             
2892   12BA E5          SBSCPT: PUSH    HL              ; Save code string address
2893   12BB 2A 5C 31            LD      HL,(LCRFLG)     ; Locate/Create and Type
2894   12BE E3                  EX      (SP),HL         ; Save and get code string
2895   12BF 57                  LD      D,A             ; Zero number of dimensions
2896   12C0 D5          SCPTLP: PUSH    DE              ; Save number of dimensions
2897   12C1 C5                  PUSH    BC              ; Save array name
2898   12C2 CD 40 0C            CALL    FPSINT          ; Get subscript (0-32767)
2899   12C5 C1                  POP     BC              ; Restore array name
2900   12C6 F1                  POP     AF              ; Get number of dimensions
2901   12C7 EB                  EX      DE,HL
2902   12C8 E3                  EX      (SP),HL         ; Save subscript value
2903   12C9 E5                  PUSH    HL              ; Save LCRFLG and TYPE
2904   12CA EB                  EX      DE,HL
2905   12CB 3C                  INC     A               ; Count dimensions
2906   12CC 57                  LD      D,A             ; Save in D
2907   12CD 7E                  LD      A,(HL)          ; Get next byte in code string
2908   12CE FE 2C               CP      ','             ; Comma (more to come)?
2909   12D0 CA C0 12            JP      Z,SCPTLP        ; Yes - More subscripts
2910   12D3 CD 10 0A            CALL    CHKSYN          ; Make sure ")" follows
2911   12D6 29                  .BYTE      ")"
2912   12D7 22 80 31            LD      (NXTOPR),HL     ; Save code string address
2913   12DA E1                  POP     HL              ; Get LCRFLG and TYPE
2914   12DB 22 5C 31            LD      (LCRFLG),HL     ; Restore Locate/create & type
2915   12DE 1E 00               LD      E,0             ; Flag not CSAVE* or CLOAD*
2916   12E0 D5                  PUSH    DE              ; Save number of dimensions (D)
2917   12E1 11                  .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
2918   12E2             
2919   12E2 E5          ARLDSV: PUSH    HL              ; Save code string address
2920   12E3 F5                  PUSH    AF              ; A = 00 , Flags set = Z,N
2921   12E4 2A 88 31            LD      HL,(VAREND)     ; Start of arrays
2922   12E7 3E                  .BYTE      3EH             ; Skip "ADD HL,DE"
2923   12E8 19          FNDARY: ADD     HL,DE           ; Move to next array start
2924   12E9 EB                  EX      DE,HL
2925   12EA 2A 8A 31            LD      HL,(ARREND)     ; End of arrays
2926   12ED EB                  EX      DE,HL           ; Current array pointer
2927   12EE CD 0A 0A            CALL    CPDEHL          ; End of arrays found?
2928   12F1 CA 1A 13            JP      Z,CREARY        ; Yes - Create array
2929   12F4 7E                  LD      A,(HL)          ; Get second byte of name
2930   12F5 B9                  CP      C               ; Compare with name given
2931   12F6 23                  INC     HL              ; Move on
2932   12F7 C2 FC 12            JP      NZ,NXTARY       ; Different - Find next array
2933   12FA 7E                  LD      A,(HL)          ; Get first byte of name
2934   12FB B8                  CP      B               ; Compare with name given
2935   12FC 23          NXTARY: INC     HL              ; Move on
2936   12FD 5E                  LD      E,(HL)          ; Get LSB of next array address
2937   12FE 23                  INC     HL
2938   12FF 56                  LD      D,(HL)          ; Get MSB of next array address
2939   1300 23                  INC     HL
2940   1301 C2 E8 12            JP      NZ,FNDARY       ; Not found - Keep looking
2941   1304 3A 5C 31            LD      A,(LCRFLG)      ; Found Locate or Create it?
2942   1307 B7                  OR      A
2943   1308 C2 4B 07            JP      NZ,DDERR        ; Create - ?DD Error
2944   130B F1                  POP     AF              ; Locate - Get number of dim'ns
2945   130C 44                  LD      B,H             ; BC Points to array dim'ns
2946   130D 4D                  LD      C,L
2947   130E CA 2A 19            JP      Z,POPHRT        ; Jump if array load/save
2948   1311 96                  SUB     (HL)            ; Same number of dimensions?
2949   1312 CA 78 13            JP      Z,FINDEL        ; Yes - Find element
2950   1315 1E 10       BSERR:  LD      E,BS            ; ?BS Error
2951   1317 C3 56 07            JP      ERROR           ; Output error
2952   131A             
2953   131A 11 04 00    CREARY: LD      DE,4            ; 4 Bytes per entry
2954   131D F1                  POP     AF              ; Array to save or 0 dim'ns?
2955   131E CA 61 0C            JP      Z,FCERR         ; Yes - ?FC Error
2956   1321 71                  LD      (HL),C          ; Save second byte of name
2957   1322 23                  INC     HL
2958   1323 70                  LD      (HL),B          ; Save first byte of name
2959   1324 23                  INC     HL
2960   1325 4F                  LD      C,A             ; Number of dimensions to C
2961   1326 CD 1F 07            CALL    CHKSTK          ; Check if enough memory
2962   1329 23                  INC     HL              ; Point to number of dimensions
2963   132A 23                  INC     HL
2964   132B 22 75 31            LD      (CUROPR),HL     ; Save address of pointer
2965   132E 71                  LD      (HL),C          ; Set number of dimensions
2966   132F 23                  INC     HL
2967   1330 3A 5C 31            LD      A,(LCRFLG)      ; Locate of Create?
2968   1333 17                  RLA                     ; Carry set = Create
2969   1334 79                  LD      A,C             ; Get number of dimensions
2970   1335 01 0B 00    CRARLP: LD      BC,10+1         ; Default dimension size 10
2971   1338 D2 3D 13            JP      NC,DEFSIZ       ; Locate - Set default size
2972   133B C1                  POP     BC              ; Get specified dimension size
2973   133C 03                  INC     BC              ; Include zero element
2974   133D 71          DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2975   133E 23                  INC     HL
2976   133F 70                  LD      (HL),B          ; Save MSB of dimension size
2977   1340 23                  INC     HL
2978   1341 F5                  PUSH    AF              ; Save num' of dim'ns an status
2979   1342 E5                  PUSH    HL              ; Save address of dim'n size
2980   1343 CD D5 1A            CALL    MLDEBC          ; Multiply DE by BC to find
2981   1346 EB                  EX      DE,HL           ; amount of mem needed (to DE)
2982   1347 E1                  POP     HL              ; Restore address of dimension
2983   1348 F1                  POP     AF              ; Restore number of dimensions
2984   1349 3D                  DEC     A               ; Count them
2985   134A C2 35 13            JP      NZ,CRARLP       ; Do next dimension if more
2986   134D F5                  PUSH    AF              ; Save locate/create flag
2987   134E 42                  LD      B,D             ; MSB of memory needed
2988   134F 4B                  LD      C,E             ; LSB of memory needed
2989   1350 EB                  EX      DE,HL
2990   1351 19                  ADD     HL,DE           ; Add bytes to array start
2991   1352 DA 37 07            JP      C,OMERR         ; Too big - Error
2992   1355 CD 28 07            CALL    ENFMEM          ; See if enough memory
2993   1358 22 8A 31            LD      (ARREND),HL     ; Save new end of array
2994   135B             
2995   135B 2B          ZERARY: DEC     HL              ; Back through array data
2996   135C 36 00               LD      (HL),0          ; Set array element to zero
2997   135E CD 0A 0A            CALL    CPDEHL          ; All elements zeroed?
2998   1361 C2 5B 13            JP      NZ,ZERARY       ; No - Keep on going
2999   1364 03                  INC     BC              ; Number of bytes + 1
3000   1365 57                  LD      D,A             ; A=0
3001   1366 2A 75 31            LD      HL,(CUROPR)     ; Get address of array
3002   1369 5E                  LD      E,(HL)          ; Number of dimensions
3003   136A EB                  EX      DE,HL           ; To HL
3004   136B 29                  ADD     HL,HL           ; Two bytes per dimension size
3005   136C 09                  ADD     HL,BC           ; Add number of bytes
3006   136D EB                  EX      DE,HL           ; Bytes needed to DE
3007   136E 2B                  DEC     HL
3008   136F 2B                  DEC     HL
3009   1370 73                  LD      (HL),E          ; Save LSB of bytes needed
3010   1371 23                  INC     HL
3011   1372 72                  LD      (HL),D          ; Save MSB of bytes needed
3012   1373 23                  INC     HL
3013   1374 F1                  POP     AF              ; Locate / Create?
3014   1375 DA 9C 13            JP      C,ENDDIM        ; A is 0 , End if create
3015   1378 47          FINDEL: LD      B,A             ; Find array element
3016   1379 4F                  LD      C,A
3017   137A 7E                  LD      A,(HL)          ; Number of dimensions
3018   137B 23                  INC     HL
3019   137C 16                  .BYTE      16H             ; Skip "POP HL"
3020   137D E1          FNDELP: POP     HL              ; Address of next dim' size
3021   137E 5E                  LD      E,(HL)          ; Get LSB of dim'n size
3022   137F 23                  INC     HL
3023   1380 56                  LD      D,(HL)          ; Get MSB of dim'n size
3024   1381 23                  INC     HL
3025   1382 E3                  EX      (SP),HL         ; Save address - Get index
3026   1383 F5                  PUSH    AF              ; Save number of dim'ns
3027   1384 CD 0A 0A            CALL    CPDEHL          ; Dimension too large?
3028   1387 D2 15 13            JP      NC,BSERR        ; Yes - ?BS Error
3029   138A E5                  PUSH    HL              ; Save index
3030   138B CD D5 1A            CALL    MLDEBC          ; Multiply previous by size
3031   138E D1                  POP     DE              ; Index supplied to DE
3032   138F 19                  ADD     HL,DE           ; Add index to pointer
3033   1390 F1                  POP     AF              ; Number of dimensions
3034   1391 3D                  DEC     A               ; Count them
3035   1392 44                  LD      B,H             ; MSB of pointer
3036   1393 4D                  LD      C,L             ; LSB of pointer
3037   1394 C2 7D 13            JP      NZ,FNDELP       ; More - Keep going
3038   1397 29                  ADD     HL,HL           ; 4 Bytes per element
3039   1398 29                  ADD     HL,HL
3040   1399 C1                  POP     BC              ; Start of array
3041   139A 09                  ADD     HL,BC           ; Point to element
3042   139B EB                  EX      DE,HL           ; Address of element to DE
3043   139C 2A 80 31    ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
3044   139F C9                  RET
3045   13A0             
3046   13A0 2A 8A 31    FRE:    LD      HL,(ARREND)     ; Start of free memory
3047   13A3 EB                  EX      DE,HL           ; To DE
3048   13A4 21 00 00            LD      HL,0            ; End of free memory
3049   13A7 39                  ADD     HL,SP           ; Current stack value
3050   13A8 3A 5D 31            LD      A,(TYPE)        ; Dummy argument type
3051   13AB B7                  OR      A
3052   13AC CA BC 13            JP      Z,FRENUM        ; Numeric - Free variable space
3053   13AF CD 23 16            CALL    GSTRCU          ; Current string to pool
3054   13B2 CD 23 15            CALL    GARBGE          ; Garbage collection
3055   13B5 2A 0A 31            LD      HL,(STRSPC)     ; Bottom of string space in use
3056   13B8 EB                  EX      DE,HL           ; To DE
3057   13B9 2A 73 31            LD      HL,(STRBOT)     ; Bottom of string space
3058   13BC 7D          FRENUM: LD      A,L             ; Get LSB of end
3059   13BD 93                  SUB     E               ; Subtract LSB of beginning
3060   13BE 4F                  LD      C,A             ; Save difference if C
3061   13BF 7C                  LD      A,H             ; Get MSB of end
3062   13C0 9A                  SBC     A,D             ; Subtract MSB of beginning
3063   13C1 41          ACPASS: LD      B,C             ; Return integer AC
3064   13C2 50          ABPASS: LD      D,B             ; Return integer AB
3065   13C3 1E 00               LD      E,0
3066   13C5 21 5D 31            LD      HL,TYPE         ; Point to type
3067   13C8 73                  LD      (HL),E          ; Set type to numeric
3068   13C9 06 90               LD      B,80H+16        ; 16 bit integer
3069   13CB C3 00 1A            JP      RETINT          ; Return the integr
3070   13CE             
3071   13CE 3A 5B 31    POS:    LD      A,(CURPOS)      ; Get cursor position
3072   13D1 47          PASSA:  LD      B,A             ; Put A into AB
3073   13D2 AF                  XOR     A               ; Zero A
3074   13D3 C3 C2 13            JP      ABPASS          ; Return integer AB
3075   13D6             
3076   13D6 CD 59 14    DEF:    CALL    CHEKFN          ; Get "FN" and name
3077   13D9 CD 4B 14            CALL    IDTEST          ; Test for illegal direct
3078   13DC 01 31 0D            LD      BC,DATA         ; To get next statement
3079   13DF C5                  PUSH    BC              ; Save address for RETurn
3080   13E0 D5                  PUSH    DE              ; Save address of function ptr
3081   13E1 CD 10 0A            CALL    CHKSYN          ; Make sure "(" follows
3082   13E4 28                  .BYTE      "("
3083   13E5 CD FD 11            CALL    GETVAR          ; Get argument variable name
3084   13E8 E5                  PUSH    HL              ; Save code string address
3085   13E9 EB                  EX      DE,HL           ; Argument address to HL
3086   13EA 2B                  DEC     HL
3087   13EB 56                  LD      D,(HL)          ; Get first byte of arg name
3088   13EC 2B                  DEC     HL
3089   13ED 5E                  LD      E,(HL)          ; Get second byte of arg name
3090   13EE E1                  POP     HL              ; Restore code string address
3091   13EF CD 0A 10            CALL    TSTNUM          ; Make sure numeric argument
3092   13F2 CD 10 0A            CALL    CHKSYN          ; Make sure ")" follows
3093   13F5 29                  .BYTE      ")"
3094   13F6 CD 10 0A            CALL    CHKSYN          ; Make sure "=" follows
3095   13F9 B4                  .BYTE      ZEQUAL          ; "=" token
3096   13FA 44                  LD      B,H             ; Code string address to BC
3097   13FB 4D                  LD      C,L
3098   13FC E3                  EX      (SP),HL         ; Save code str , Get FN ptr
3099   13FD 71                  LD      (HL),C          ; Save LSB of FN code string
3100   13FE 23                  INC     HL
3101   13FF 70                  LD      (HL),B          ; Save MSB of FN code string
3102   1400 C3 98 14            JP      SVSTAD          ; Save address and do function
3103   1403             
3104   1403 CD 59 14    DOFN:   CALL    CHEKFN          ; Make sure FN follows
3105   1406 D5                  PUSH    DE              ; Save function pointer address
3106   1407 CD DE 10            CALL    EVLPAR          ; Evaluate expression in "()"
3107   140A CD 0A 10            CALL    TSTNUM          ; Make sure numeric result
3108   140D E3                  EX      (SP),HL         ; Save code str , Get FN ptr
3109   140E 5E                  LD      E,(HL)          ; Get LSB of FN code string
3110   140F 23                  INC     HL
3111   1410 56                  LD      D,(HL)          ; Get MSB of FN code string
3112   1411 23                  INC     HL
3113   1412 7A                  LD      A,D             ; And function DEFined?
3114   1413 B3                  OR      E
3115   1414 CA 4E 07            JP      Z,UFERR         ; No - ?UF Error
3116   1417 7E                  LD      A,(HL)          ; Get LSB of argument address
3117   1418 23                  INC     HL
3118   1419 66                  LD      H,(HL)          ; Get MSB of argument address
3119   141A 6F                  LD      L,A             ; HL = Arg variable address
3120   141B E5                  PUSH    HL              ; Save it
3121   141C 2A 8E 31            LD      HL,(FNRGNM)     ; Get old argument name
3122   141F E3                  EX      (SP),HL ;       ; Save old , Get new
3123   1420 22 8E 31            LD      (FNRGNM),HL     ; Set new argument name
3124   1423 2A 92 31            LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
3125   1426 E5                  PUSH    HL              ; Save it
3126   1427 2A 90 31            LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
3127   142A E5                  PUSH    HL              ; Save it
3128   142B 21 90 31            LD      HL,FNARG        ; HL = Value of argument
3129   142E D5                  PUSH    DE              ; Save FN code string address
3130   142F CD 41 1A            CALL    FPTHL           ; Move FPREG to argument
3131   1432 E1                  POP     HL              ; Get FN code string address
3132   1433 CD 07 10            CALL    GETNUM          ; Get value from function
3133   1436 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
3134   1437 CD 9A 0B            CALL    GETCHR          ; Get next character
3135   143A C2 42 07            JP      NZ,SNERR        ; Bad character in FN - Error
3136   143D E1                  POP     HL              ; Get MSB,EXP of old arg
3137   143E 22 90 31            LD      (FNARG),HL      ; Restore it
3138   1441 E1                  POP     HL              ; Get LSB,NLSB of old arg
3139   1442 22 92 31            LD      (FNARG+2),HL    ; Restore it
3140   1445 E1                  POP     HL              ; Get name of old arg
3141   1446 22 8E 31            LD      (FNRGNM),HL     ; Restore it
3142   1449 E1                  POP     HL              ; Restore code string address
3143   144A C9                  RET
3144   144B             
3145   144B E5          IDTEST: PUSH    HL              ; Save code string address
3146   144C 2A 0C 31            LD      HL,(LINEAT)     ; Get current line number
3147   144F 23                  INC     HL              ; -1 means direct statement
3148   1450 7C                  LD      A,H
3149   1451 B5                  OR      L
3150   1452 E1                  POP     HL              ; Restore code string address
3151   1453 C0                  RET     NZ              ; Return if in program
3152   1454 1E 16               LD      E,ID            ; ?ID Error
3153   1456 C3 56 07            JP      ERROR
3154   1459             
3155   1459 CD 10 0A    CHEKFN: CALL    CHKSYN          ; Make sure FN follows
3156   145C A7                  .BYTE      ZFN             ; "FN" token
3157   145D 3E 80               LD      A,80H
3158   145F 32 7B 31            LD      (FORFLG),A      ; Flag FN name to find
3159   1462 B6                  OR      (HL)            ; FN name has bit 7 set
3160   1463 47                  LD      B,A             ; in first byte of name
3161   1464 CD 02 12            CALL    GTFNAM          ; Get FN name
3162   1467 C3 0A 10            JP      TSTNUM          ; Make sure numeric function
3163   146A             
3164   146A CD 0A 10    STR:    CALL    TSTNUM          ; Make sure it's a number
3165   146D CD 8E 1B            CALL    NUMASC          ; Turn number into text
3166   1470 CD 9E 14    STR1:   CALL    CRTST           ; Create string entry for it
3167   1473 CD 23 16            CALL    GSTRCU          ; Current string to pool
3168   1476 01 7E 16            LD      BC,TOPOOL       ; Save in string pool
3169   1479 C5                  PUSH    BC              ; Save address on stack
3170   147A             
3171   147A 7E          SAVSTR: LD      A,(HL)          ; Get string length
3172   147B 23                  INC     HL
3173   147C 23                  INC     HL
3174   147D E5                  PUSH    HL              ; Save pointer to string
3175   147E CD F9 14            CALL    TESTR           ; See if enough string space
3176   1481 E1                  POP     HL              ; Restore pointer to string
3177   1482 4E                  LD      C,(HL)          ; Get LSB of address
3178   1483 23                  INC     HL
3179   1484 46                  LD      B,(HL)          ; Get MSB of address
3180   1485 CD 92 14            CALL    CRTMST          ; Create string entry
3181   1488 E5                  PUSH    HL              ; Save pointer to MSB of addr
3182   1489 6F                  LD      L,A             ; Length of string
3183   148A CD 16 16            CALL    TOSTRA          ; Move to string area
3184   148D D1                  POP     DE              ; Restore pointer to MSB
3185   148E C9                  RET
3186   148F             
3187   148F CD F9 14    MKTMST: CALL    TESTR           ; See if enough string space
3188   1492 21 6F 31    CRTMST: LD      HL,TMPSTR       ; Temporary string
3189   1495 E5                  PUSH    HL              ; Save it
3190   1496 77                  LD      (HL),A          ; Save length of string
3191   1497 23                  INC     HL
3192   1498 23          SVSTAD: INC     HL
3193   1499 73                  LD      (HL),E          ; Save LSB of address
3194   149A 23                  INC     HL
3195   149B 72                  LD      (HL),D          ; Save MSB of address
3196   149C E1                  POP     HL              ; Restore pointer
3197   149D C9                  RET
3198   149E             
3199   149E 2B          CRTST:  DEC     HL              ; DEC - INCed after
3200   149F 06 22       QTSTR:  LD      B,'"'           ; Terminating quote
3201   14A1 50                  LD      D,B             ; Quote to D
3202   14A2 E5          DTSTR:  PUSH    HL              ; Save start
3203   14A3 0E FF               LD      C,-1            ; Set counter to -1
3204   14A5 23          QTSTLP: INC     HL              ; Move on
3205   14A6 7E                  LD      A,(HL)          ; Get byte
3206   14A7 0C                  INC     C               ; Count bytes
3207   14A8 B7                  OR      A               ; End of line?
3208   14A9 CA B4 14            JP      Z,CRTSTE        ; Yes - Create string entry
3209   14AC BA                  CP      D               ; Terminator D found?
3210   14AD CA B4 14            JP      Z,CRTSTE        ; Yes - Create string entry
3211   14B0 B8                  CP      B               ; Terminator B found?
3212   14B1 C2 A5 14            JP      NZ,QTSTLP       ; No - Keep looking
3213   14B4 FE 22       CRTSTE: CP      '"'             ; End with '"'?
3214   14B6 CC 9A 0B            CALL    Z,GETCHR        ; Yes - Get next character
3215   14B9 E3                  EX      (SP),HL         ; Starting quote
3216   14BA 23                  INC     HL              ; First byte of string
3217   14BB EB                  EX      DE,HL           ; To DE
3218   14BC 79                  LD      A,C             ; Get length
3219   14BD CD 92 14            CALL    CRTMST          ; Create string entry
3220   14C0 11 6F 31    TSTOPL: LD      DE,TMPSTR       ; Temporary string
3221   14C3 2A 61 31            LD      HL,(TMSTPT)     ; Temporary string pool pointer
3222   14C6 22 94 31            LD      (FPREG),HL      ; Save address of string ptr
3223   14C9 3E 01               LD      A,1
3224   14CB 32 5D 31            LD      (TYPE),A        ; Set type to string
3225   14CE CD 44 1A            CALL    DETHL4          ; Move string to pool
3226   14D1 CD 0A 0A            CALL    CPDEHL          ; Out of string pool?
3227   14D4 22 61 31            LD      (TMSTPT),HL     ; Save new pointer
3228   14D7 E1                  POP     HL              ; Restore code string address
3229   14D8 7E                  LD      A,(HL)          ; Get next code byte
3230   14D9 C0                  RET     NZ              ; Return if pool OK
3231   14DA 1E 1E               LD      E,ST            ; ?ST Error
3232   14DC C3 56 07            JP      ERROR           ; String pool overflow
3233   14DF             
3234   14DF 23          PRNUMS: INC     HL              ; Skip leading space
3235   14E0 CD 9E 14    PRS:    CALL    CRTST           ; Create string entry for it
3236   14E3 CD 23 16    PRS1:   CALL    GSTRCU          ; Current string to pool
3237   14E6 CD 38 1A            CALL    LOADFP          ; Move string block to BCDE
3238   14E9 1C                  INC     E               ; Length + 1
3239   14EA 1D          PRSLP:  DEC     E               ; Count characters
3240   14EB C8                  RET     Z               ; End of string
3241   14EC 0A                  LD      A,(BC)          ; Get byte to output
3242   14ED CD 1B 0A            CALL    OUTC            ; Output character in A
3243   14F0 FE 0D               CP      CR              ; Return?
3244   14F2 CC 4C 0E            CALL    Z,DONULL        ; Yes - Do nulls
3245   14F5 03                  INC     BC              ; Next byte in string
3246   14F6 C3 EA 14            JP      PRSLP           ; More characters to output
3247   14F9             
3248   14F9 B7          TESTR:  OR      A               ; Test if enough room
3249   14FA 0E                  .BYTE      0EH             ; No garbage collection done
3250   14FB F1          GRBDON: POP     AF              ; Garbage collection done
3251   14FC F5                  PUSH    AF              ; Save status
3252   14FD 2A 0A 31            LD      HL,(STRSPC)     ; Bottom of string space in use
3253   1500 EB                  EX      DE,HL           ; To DE
3254   1501 2A 73 31            LD      HL,(STRBOT)     ; Bottom of string area
3255   1504 2F                  CPL                     ; Negate length (Top down)
3256   1505 4F                  LD      C,A             ; -Length to BC
3257   1506 06 FF               LD      B,-1            ; BC = -ve length of string
3258   1508 09                  ADD     HL,BC           ; Add to bottom of space in use
3259   1509 23                  INC     HL              ; Plus one for 2's complement
3260   150A CD 0A 0A            CALL    CPDEHL          ; Below string RAM area?
3261   150D DA 17 15            JP      C,TESTOS        ; Tidy up if not done else err
3262   1510 22 73 31            LD      (STRBOT),HL     ; Save new bottom of area
3263   1513 23                  INC     HL              ; Point to first byte of string
3264   1514 EB                  EX      DE,HL           ; Address to DE
3265   1515 F1          POPAF:  POP     AF              ; Throw away status push
3266   1516 C9                  RET
3267   1517             
3268   1517 F1          TESTOS: POP     AF              ; Garbage collect been done?
3269   1518 1E 1A               LD      E,OS            ; ?OS Error
3270   151A CA 56 07            JP      Z,ERROR         ; Yes - Not enough string apace
3271   151D BF                  CP      A               ; Flag garbage collect done
3272   151E F5                  PUSH    AF              ; Save status
3273   151F 01 FB 14            LD      BC,GRBDON       ; Garbage collection done
3274   1522 C5                  PUSH    BC              ; Save for RETurn
3275   1523 2A 5F 31    GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
3276   1526 22 73 31    GARBLP: LD      (STRBOT),HL     ; Reset string pointer
3277   1529 21 00 00            LD      HL,0
3278   152C E5                  PUSH    HL              ; Flag no string found
3279   152D 2A 0A 31            LD      HL,(STRSPC)     ; Get bottom of string space
3280   1530 E5                  PUSH    HL              ; Save bottom of string space
3281   1531 21 63 31            LD      HL,TMSTPL       ; Temporary string pool
3282   1534 EB          GRBLP:  EX      DE,HL
3283   1535 2A 61 31            LD      HL,(TMSTPT)     ; Temporary string pool pointer
3284   1538 EB                  EX      DE,HL
3285   1539 CD 0A 0A            CALL    CPDEHL          ; Temporary string pool done?
3286   153C 01 34 15            LD      BC,GRBLP        ; Loop until string pool done
3287   153F C2 88 15            JP      NZ,STPOOL       ; No - See if in string area
3288   1542 2A 86 31            LD      HL,(PROGND)     ; Start of simple variables
3289   1545 EB          SMPVAR: EX      DE,HL
3290   1546 2A 88 31            LD      HL,(VAREND)     ; End of simple variables
3291   1549 EB                  EX      DE,HL
3292   154A CD 0A 0A            CALL    CPDEHL          ; All simple strings done?
3293   154D CA 5B 15            JP      Z,ARRLP         ; Yes - Do string arrays
3294   1550 7E                  LD      A,(HL)          ; Get type of variable
3295   1551 23                  INC     HL
3296   1552 23                  INC     HL
3297   1553 B7                  OR      A               ; "S" flag set if string
3298   1554 CD 8B 15            CALL    STRADD          ; See if string in string area
3299   1557 C3 45 15            JP      SMPVAR          ; Loop until simple ones done
3300   155A             
3301   155A C1          GNXARY: POP     BC              ; Scrap address of this array
3302   155B EB          ARRLP:  EX      DE,HL
3303   155C 2A 8A 31            LD      HL,(ARREND)     ; End of string arrays
3304   155F EB                  EX      DE,HL
3305   1560 CD 0A 0A            CALL    CPDEHL          ; All string arrays done?
3306   1563 CA B1 15            JP      Z,SCNEND        ; Yes - Move string if found
3307   1566 CD 38 1A            CALL    LOADFP          ; Get array name to BCDE
3308   1569 7B                  LD      A,E             ; Get type of array     
3309   156A E5                  PUSH    HL              ; Save address of num of dim'ns
3310   156B 09                  ADD     HL,BC           ; Start of next array
3311   156C B7                  OR      A               ; Test type of array
3312   156D F2 5A 15            JP      P,GNXARY        ; Numeric array - Ignore it
3313   1570 22 75 31            LD      (CUROPR),HL     ; Save address of next array
3314   1573 E1                  POP     HL              ; Get address of num of dim'ns
3315   1574 4E                  LD      C,(HL)          ; BC = Number of dimensions
3316   1575 06 00               LD      B,0
3317   1577 09                  ADD     HL,BC           ; Two bytes per dimension size
3318   1578 09                  ADD     HL,BC
3319   1579 23                  INC     HL              ; Plus one for number of dim'ns
3320   157A EB          GRBARY: EX      DE,HL
3321   157B 2A 75 31            LD      HL,(CUROPR)     ; Get address of next array
3322   157E EB                  EX      DE,HL
3323   157F CD 0A 0A            CALL    CPDEHL          ; Is this array finished?
3324   1582 CA 5B 15            JP      Z,ARRLP         ; Yes - Get next one
3325   1585 01 7A 15            LD      BC,GRBARY       ; Loop until array all done
3326   1588 C5          STPOOL: PUSH    BC              ; Save return address
3327   1589 F6 80               OR      80H             ; Flag string type
3328   158B 7E          STRADD: LD      A,(HL)          ; Get string length
3329   158C 23                  INC     HL
3330   158D 23                  INC     HL
3331   158E 5E                  LD      E,(HL)          ; Get LSB of string address
3332   158F 23                  INC     HL
3333   1590 56                  LD      D,(HL)          ; Get MSB of string address
3334   1591 23                  INC     HL
3335   1592 F0                  RET     P               ; Not a string - Return
3336   1593 B7                  OR      A               ; Set flags on string length
3337   1594 C8                  RET     Z               ; Null string - Return
3338   1595 44                  LD      B,H             ; Save variable pointer
3339   1596 4D                  LD      C,L
3340   1597 2A 73 31            LD      HL,(STRBOT)     ; Bottom of new area
3341   159A CD 0A 0A            CALL    CPDEHL          ; String been done?
3342   159D 60                  LD      H,B             ; Restore variable pointer
3343   159E 69                  LD      L,C
3344   159F D8                  RET     C               ; String done - Ignore
3345   15A0 E1                  POP     HL              ; Return address
3346   15A1 E3                  EX      (SP),HL         ; Lowest available string area
3347   15A2 CD 0A 0A            CALL    CPDEHL          ; String within string area?
3348   15A5 E3                  EX      (SP),HL         ; Lowest available string area
3349   15A6 E5                  PUSH    HL              ; Re-save return address
3350   15A7 60                  LD      H,B             ; Restore variable pointer
3351   15A8 69                  LD      L,C
3352   15A9 D0                  RET     NC              ; Outside string area - Ignore
3353   15AA C1                  POP     BC              ; Get return , Throw 2 away
3354   15AB F1                  POP     AF              ; 
3355   15AC F1                  POP     AF              ; 
3356   15AD E5                  PUSH    HL              ; Save variable pointer
3357   15AE D5                  PUSH    DE              ; Save address of current
3358   15AF C5                  PUSH    BC              ; Put back return address
3359   15B0 C9                  RET                     ; Go to it
3360   15B1             
3361   15B1 D1          SCNEND: POP     DE              ; Addresses of strings
3362   15B2 E1                  POP     HL              ; 
3363   15B3 7D                  LD      A,L             ; HL = 0 if no more to do
3364   15B4 B4                  OR      H
3365   15B5 C8                  RET     Z               ; No more to do - Return
3366   15B6 2B                  DEC     HL
3367   15B7 46                  LD      B,(HL)          ; MSB of address of string
3368   15B8 2B                  DEC     HL
3369   15B9 4E                  LD      C,(HL)          ; LSB of address of string
3370   15BA E5                  PUSH    HL              ; Save variable address
3371   15BB 2B                  DEC     HL
3372   15BC 2B                  DEC     HL
3373   15BD 6E                  LD      L,(HL)          ; HL = Length of string
3374   15BE 26 00               LD      H,0
3375   15C0 09                  ADD     HL,BC           ; Address of end of string+1
3376   15C1 50                  LD      D,B             ; String address to DE
3377   15C2 59                  LD      E,C
3378   15C3 2B                  DEC     HL              ; Last byte in string
3379   15C4 44                  LD      B,H             ; Address to BC
3380   15C5 4D                  LD      C,L
3381   15C6 2A 73 31            LD      HL,(STRBOT)     ; Current bottom of string area
3382   15C9 CD 11 07            CALL    MOVSTR          ; Move string to new address
3383   15CC E1                  POP     HL              ; Restore variable address
3384   15CD 71                  LD      (HL),C          ; Save new LSB of address
3385   15CE 23                  INC     HL
3386   15CF 70                  LD      (HL),B          ; Save new MSB of address
3387   15D0 69                  LD      L,C             ; Next string area+1 to HL
3388   15D1 60                  LD      H,B
3389   15D2 2B                  DEC     HL              ; Next string area address
3390   15D3 C3 26 15            JP      GARBLP          ; Look for more strings
3391   15D6             
3392   15D6 C5          CONCAT: PUSH    BC              ; Save prec' opr & code string
3393   15D7 E5                  PUSH    HL              ; 
3394   15D8 2A 94 31            LD      HL,(FPREG)      ; Get first string
3395   15DB E3                  EX      (SP),HL         ; Save first string
3396   15DC CD 90 10            CALL    OPRND           ; Get second string
3397   15DF E3                  EX      (SP),HL         ; Restore first string
3398   15E0 CD 0B 10            CALL    TSTSTR          ; Make sure it's a string
3399   15E3 7E                  LD      A,(HL)          ; Get length of second string
3400   15E4 E5                  PUSH    HL              ; Save first string
3401   15E5 2A 94 31            LD      HL,(FPREG)      ; Get second string
3402   15E8 E5                  PUSH    HL              ; Save second string
3403   15E9 86                  ADD     A,(HL)          ; Add length of second string
3404   15EA 1E 1C               LD      E,LS            ; ?LS Error
3405   15EC DA 56 07            JP      C,ERROR         ; String too long - Error
3406   15EF CD 8F 14            CALL    MKTMST          ; Make temporary string
3407   15F2 D1                  POP     DE              ; Get second string to DE
3408   15F3 CD 27 16            CALL    GSTRDE          ; Move to string pool if needed
3409   15F6 E3                  EX      (SP),HL         ; Get first string
3410   15F7 CD 26 16            CALL    GSTRHL          ; Move to string pool if needed
3411   15FA E5                  PUSH    HL              ; Save first string
3412   15FB 2A 71 31            LD      HL,(TMPSTR+2)   ; Temporary string address
3413   15FE EB                  EX      DE,HL           ; To DE
3414   15FF CD 0D 16            CALL    SSTSA           ; First string to string area
3415   1602 CD 0D 16            CALL    SSTSA           ; Second string to string area
3416   1605 21 25 10            LD      HL,EVAL2        ; Return to evaluation loop
3417   1608 E3                  EX      (SP),HL         ; Save return,get code string
3418   1609 E5                  PUSH    HL              ; Save code string address
3419   160A C3 C0 14            JP      TSTOPL          ; To temporary string to pool
3420   160D             
3421   160D E1          SSTSA:  POP     HL              ; Return address
3422   160E E3                  EX      (SP),HL         ; Get string block,save return
3423   160F 7E                  LD      A,(HL)          ; Get length of string
3424   1610 23                  INC     HL
3425   1611 23                  INC     HL
3426   1612 4E                  LD      C,(HL)          ; Get LSB of string address
3427   1613 23                  INC     HL
3428   1614 46                  LD      B,(HL)          ; Get MSB of string address
3429   1615 6F                  LD      L,A             ; Length to L
3430   1616 2C          TOSTRA: INC     L               ; INC - DECed after
3431   1617 2D          TSALP:  DEC     L               ; Count bytes moved
3432   1618 C8                  RET     Z               ; End of string - Return
3433   1619 0A                  LD      A,(BC)          ; Get source
3434   161A 12                  LD      (DE),A          ; Save destination
3435   161B 03                  INC     BC              ; Next source
3436   161C 13                  INC     DE              ; Next destination
3437   161D C3 17 16            JP      TSALP           ; Loop until string moved
3438   1620             
3439   1620 CD 0B 10    GETSTR: CALL    TSTSTR          ; Make sure it's a string
3440   1623 2A 94 31    GSTRCU: LD      HL,(FPREG)      ; Get current string
3441   1626 EB          GSTRHL: EX      DE,HL           ; Save DE
3442   1627 CD 41 16    GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
3443   162A EB                  EX      DE,HL           ; Restore DE
3444   162B C0                  RET     NZ              ; No - Return
3445   162C D5                  PUSH    DE              ; Save string
3446   162D 50                  LD      D,B             ; String block address to DE
3447   162E 59                  LD      E,C
3448   162F 1B                  DEC     DE              ; Point to length
3449   1630 4E                  LD      C,(HL)          ; Get string length
3450   1631 2A 73 31            LD      HL,(STRBOT)     ; Current bottom of string area
3451   1634 CD 0A 0A            CALL    CPDEHL          ; Last one in string area?
3452   1637 C2 3F 16            JP      NZ,POPHL        ; No - Return
3453   163A 47                  LD      B,A             ; Clear B (A=0)
3454   163B 09                  ADD     HL,BC           ; Remove string from str' area
3455   163C 22 73 31            LD      (STRBOT),HL     ; Save new bottom of str' area
3456   163F E1          POPHL:  POP     HL              ; Restore string
3457   1640 C9                  RET
3458   1641             
3459   1641 2A 61 31    BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
3460   1644 2B                  DEC     HL              ; Back
3461   1645 46                  LD      B,(HL)          ; Get MSB of address
3462   1646 2B                  DEC     HL              ; Back
3463   1647 4E                  LD      C,(HL)          ; Get LSB of address
3464   1648 2B                  DEC     HL              ; Back
3465   1649 2B                  DEC     HL              ; Back
3466   164A CD 0A 0A            CALL    CPDEHL          ; String last in string pool?
3467   164D C0                  RET     NZ              ; Yes - Leave it
3468   164E 22 61 31            LD      (TMSTPT),HL     ; Save new string pool top
3469   1651 C9                  RET
3470   1652             
3471   1652 01 D1 13    LEN:    LD      BC,PASSA        ; To return integer A
3472   1655 C5                  PUSH    BC              ; Save address
3473   1656 CD 20 16    GETLEN: CALL    GETSTR          ; Get string and its length
3474   1659 AF                  XOR     A
3475   165A 57                  LD      D,A             ; Clear D
3476   165B 32 5D 31            LD      (TYPE),A        ; Set type to numeric
3477   165E 7E                  LD      A,(HL)          ; Get length of string
3478   165F B7                  OR      A               ; Set status flags
3479   1660 C9                  RET
3480   1661             
3481   1661 01 D1 13    ASC:    LD      BC,PASSA        ; To return integer A
3482   1664 C5                  PUSH    BC              ; Save address
3483   1665 CD 56 16    GTFLNM: CALL    GETLEN          ; Get length of string
3484   1668 CA 61 0C            JP      Z,FCERR         ; Null string - Error
3485   166B 23                  INC     HL
3486   166C 23                  INC     HL
3487   166D 5E                  LD      E,(HL)          ; Get LSB of address
3488   166E 23                  INC     HL
3489   166F 56                  LD      D,(HL)          ; Get MSB of address
3490   1670 1A                  LD      A,(DE)          ; Get first byte of string
3491   1671 C9                  RET
3492   1672             
3493   1672 3E 01       CHR:    LD      A,1             ; One character string
3494   1674 CD 8F 14            CALL    MKTMST          ; Make a temporary string
3495   1677 CD 6B 17            CALL    MAKINT          ; Make it integer A
3496   167A 2A 71 31            LD      HL,(TMPSTR+2)   ; Get address of string
3497   167D 73                  LD      (HL),E          ; Save character
3498   167E C1          TOPOOL: POP     BC              ; Clean up stack
3499   167F C3 C0 14            JP      TSTOPL          ; Temporary string to pool
3500   1682             
3501   1682 CD 1B 17    LEFT:   CALL    LFRGNM          ; Get number and ending ")"
3502   1685 AF                  XOR     A               ; Start at first byte in string
3503   1686 E3          RIGHT1: EX      (SP),HL         ; Save code string,Get string
3504   1687 4F                  LD      C,A             ; Starting position in string
3505   1688 E5          MID1:   PUSH    HL              ; Save string block address
3506   1689 7E                  LD      A,(HL)          ; Get length of string
3507   168A B8                  CP      B               ; Compare with number given
3508   168B DA 90 16            JP      C,ALLFOL        ; All following bytes required
3509   168E 78                  LD      A,B             ; Get new length
3510   168F 11                  .BYTE      11H             ; Skip "LD C,0"
3511   1690 0E 00       ALLFOL: LD      C,0             ; First byte of string
3512   1692 C5                  PUSH    BC              ; Save position in string
3513   1693 CD F9 14            CALL    TESTR           ; See if enough string space
3514   1696 C1                  POP     BC              ; Get position in string
3515   1697 E1                  POP     HL              ; Restore string block address
3516   1698 E5                  PUSH    HL              ; And re-save it
3517   1699 23                  INC     HL
3518   169A 23                  INC     HL
3519   169B 46                  LD      B,(HL)          ; Get LSB of address
3520   169C 23                  INC     HL
3521   169D 66                  LD      H,(HL)          ; Get MSB of address
3522   169E 68                  LD      L,B             ; HL = address of string
3523   169F 06 00               LD      B,0             ; BC = starting address
3524   16A1 09                  ADD     HL,BC           ; Point to that byte
3525   16A2 44                  LD      B,H             ; BC = source string
3526   16A3 4D                  LD      C,L
3527   16A4 CD 92 14            CALL    CRTMST          ; Create a string entry
3528   16A7 6F                  LD      L,A             ; Length of new string
3529   16A8 CD 16 16            CALL    TOSTRA          ; Move string to string area
3530   16AB D1                  POP     DE              ; Clear stack
3531   16AC CD 27 16            CALL    GSTRDE          ; Move to string pool if needed
3532   16AF C3 C0 14            JP      TSTOPL          ; Temporary string to pool
3533   16B2             
3534   16B2 CD 1B 17    RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
3535   16B5 D1                  POP     DE              ; Get string length
3536   16B6 D5                  PUSH    DE              ; And re-save
3537   16B7 1A                  LD      A,(DE)          ; Get length
3538   16B8 90                  SUB     B               ; Move back N bytes
3539   16B9 C3 86 16            JP      RIGHT1          ; Go and get sub-string
3540   16BC             
3541   16BC EB          MID:    EX      DE,HL           ; Get code string address
3542   16BD 7E                  LD      A,(HL)          ; Get next byte ',' or ")"
3543   16BE CD 20 17            CALL    MIDNUM          ; Get number supplied
3544   16C1 04                  INC     B               ; Is it character zero?
3545   16C2 05                  DEC     B
3546   16C3 CA 61 0C            JP      Z,FCERR         ; Yes - Error
3547   16C6 C5                  PUSH    BC              ; Save starting position
3548   16C7 1E FF               LD      E,255           ; All of string
3549   16C9 FE 29               CP      ')'             ; Any length given?
3550   16CB CA D5 16            JP      Z,RSTSTR        ; No - Rest of string
3551   16CE CD 10 0A            CALL    CHKSYN          ; Make sure ',' follows
3552   16D1 2C                  .BYTE      ','
3553   16D2 CD 68 17            CALL    GETINT          ; Get integer 0-255
3554   16D5 CD 10 0A    RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
3555   16D8 29                  .BYTE      ")"
3556   16D9 F1                  POP     AF              ; Restore starting position
3557   16DA E3                  EX      (SP),HL         ; Get string,8ave code string
3558   16DB 01 88 16            LD      BC,MID1         ; Continuation of MID$ routine
3559   16DE C5                  PUSH    BC              ; Save for return
3560   16DF 3D                  DEC     A               ; Starting position-1
3561   16E0 BE                  CP      (HL)            ; Compare with length
3562   16E1 06 00               LD      B,0             ; Zero bytes length
3563   16E3 D0                  RET     NC              ; Null string if start past end
3564   16E4 4F                  LD      C,A             ; Save starting position-1
3565   16E5 7E                  LD      A,(HL)          ; Get length of string
3566   16E6 91                  SUB     C               ; Subtract start
3567   16E7 BB                  CP      E               ; Enough string for it?
3568   16E8 47                  LD      B,A             ; Save maximum length available
3569   16E9 D8                  RET     C               ; Truncate string if needed
3570   16EA 43                  LD      B,E             ; Set specified length
3571   16EB C9                  RET                     ; Go and create string
3572   16EC             
3573   16EC CD 56 16    VAL:    CALL    GETLEN          ; Get length of string
3574   16EF CA 09 18            JP      Z,RESZER        ; Result zero
3575   16F2 5F                  LD      E,A             ; Save length
3576   16F3 23                  INC     HL
3577   16F4 23                  INC     HL
3578   16F5 7E                  LD      A,(HL)          ; Get LSB of address
3579   16F6 23                  INC     HL
3580   16F7 66                  LD      H,(HL)          ; Get MSB of address
3581   16F8 6F                  LD      L,A             ; HL = String address
3582   16F9 E5                  PUSH    HL              ; Save string address
3583   16FA 19                  ADD     HL,DE
3584   16FB 46                  LD      B,(HL)          ; Get end of string+1 byte
3585   16FC 72                  LD      (HL),D          ; Zero it to terminate
3586   16FD E3                  EX      (SP),HL         ; Save string end,get start
3587   16FE C5                  PUSH    BC              ; Save end+1 byte
3588   16FF 7E                  LD      A,(HL)          ; Get starting byte
3589   1700 FE 24           CP	'$'		; Hex number indicated? [function added]
3590   1702 C2 0A 17        JP	NZ,VAL1
3591   1705 CD 34 1F        CALL	HEXTFP		; Convert Hex to FPREG
3592   1708 18 0D           JR	VAL3
3593   170A FE 25       VAL1:	CP	'%'		; Binary number indicated? [function added]
3594   170C C2 14 17        JP	NZ,VAL2
3595   170F CD A4 1F        CALL	BINTFP		; Convert Bin to FPREG
3596   1712 18 03           JR	VAL3
3597   1714 CD F0 1A    VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
3598   1717 C1          VAL3:   POP     BC              ; Restore end+1 byte
3599   1718 E1                  POP     HL              ; Restore end+1 address
3600   1719 70                  LD      (HL),B          ; Put back original byte
3601   171A C9                  RET
3602   171B             
3603   171B EB          LFRGNM: EX      DE,HL           ; Code string address to HL
3604   171C CD 10 0A            CALL    CHKSYN          ; Make sure ")" follows
3605   171F 29                  .BYTE      ")"
3606   1720 C1          MIDNUM: POP     BC              ; Get return address
3607   1721 D1                  POP     DE              ; Get number supplied
3608   1722 C5                  PUSH    BC              ; Re-save return address
3609   1723 43                  LD      B,E             ; Number to B
3610   1724 C9                  RET
3611   1725             
3612   1725 CD 6B 17    INP:    CALL    MAKINT          ; Make it integer A
3613   1728 32 EF 30            LD      (INPORT),A      ; Set input port
3614   172B CD EE 30            CALL    INPSUB          ; Get input from port
3615   172E C3 D1 13            JP      PASSA           ; Return integer A
3616   1731             
3617   1731 CD 55 17    POUT:   CALL    SETIO           ; Set up port number
3618   1734 C3 B6 30            JP      OUTSUB          ; Output data and return
3619   1737             
3620   1737 CD 55 17    WAIT:   CALL    SETIO           ; Set up port number
3621   173A F5                  PUSH    AF              ; Save AND mask
3622   173B 1E 00               LD      E,0             ; Assume zero if none given
3623   173D 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
3624   173E CD 9A 0B            CALL    GETCHR          ; Get next character
3625   1741 CA 4B 17            JP      Z,NOXOR         ; No XOR byte given
3626   1744 CD 10 0A            CALL    CHKSYN          ; Make sure ',' follows
3627   1747 2C                  .BYTE      ','
3628   1748 CD 68 17            CALL    GETINT          ; Get integer 0-255 to XOR with
3629   174B C1          NOXOR:  POP     BC              ; Restore AND mask
3630   174C CD EE 30    WAITLP: CALL    INPSUB          ; Get input
3631   174F AB                  XOR     E               ; Flip selected bits
3632   1750 A0                  AND     B               ; Result non-zero?
3633   1751 CA 4C 17            JP      Z,WAITLP        ; No = keep waiting
3634   1754 C9                  RET
3635   1755             
3636   1755 CD 68 17    SETIO:  CALL    GETINT          ; Get integer 0-255
3637   1758 32 EF 30            LD      (INPORT),A      ; Set input port
3638   175B 32 B7 30            LD      (OTPORT),A      ; Set output port
3639   175E CD 10 0A            CALL    CHKSYN          ; Make sure ',' follows
3640   1761 2C                  .BYTE      ','
3641   1762 C3 68 17            JP      GETINT          ; Get integer 0-255 and return
3642   1765             
3643   1765 CD 9A 0B    FNDNUM: CALL    GETCHR          ; Get next character
3644   1768 CD 07 10    GETINT: CALL    GETNUM          ; Get a number from 0 to 255
3645   176B CD 46 0C    MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
3646   176E 7A                  LD      A,D             ; Get MSB of number
3647   176F B7                  OR      A               ; Zero?
3648   1770 C2 61 0C            JP      NZ,FCERR        ; No - Error
3649   1773 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
3650   1774 CD 9A 0B            CALL    GETCHR          ; Get next character
3651   1777 7B                  LD      A,E             ; Get number to A
3652   1778 C9                  RET
3653   1779             
3654   1779 CD 4C 0C    PEEK:   CALL    DEINT           ; Get memory address
3655   177C 1A                  LD      A,(DE)          ; Get byte in memory
3656   177D C3 D1 13            JP      PASSA           ; Return integer A
3657   1780             
3658   1780 CD 07 10    POKE:   CALL    GETNUM          ; Get memory address
3659   1783 CD 4C 0C            CALL    DEINT           ; Get integer -32768 to 3276
3660   1786 D5                  PUSH    DE              ; Save memory address
3661   1787 CD 10 0A            CALL    CHKSYN          ; Make sure ',' follows
3662   178A 2C                  .BYTE      ','
3663   178B CD 68 17            CALL    GETINT          ; Get integer 0-255
3664   178E D1                  POP     DE              ; Restore memory address
3665   178F 12                  LD      (DE),A          ; Load it into memory
3666   1790 C9                  RET
3667   1791             
3668   1791 21 67 1C    ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
3669   1794 CD 38 1A    ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
3670   1797 C3 A3 17            JP      FPADD           ; Add BCDE to FPREG
3671   179A             
3672   179A CD 38 1A    SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3673   179D 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3674   179E C1          PSUB:   POP     BC              ; Get FP number from stack
3675   179F D1                  POP     DE
3676   17A0 CD 12 1A    SUBCDE: CALL    INVSGN          ; Negate FPREG
3677   17A3 78          FPADD:  LD      A,B             ; Get FP exponent
3678   17A4 B7                  OR      A               ; Is number zero?
3679   17A5 C8                  RET     Z               ; Yes - Nothing to add
3680   17A6 3A 97 31            LD      A,(FPEXP)       ; Get FPREG exponent
3681   17A9 B7                  OR      A               ; Is this number zero?
3682   17AA CA 2A 1A            JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3683   17AD 90                  SUB     B               ; BCDE number larger?
3684   17AE D2 BD 17            JP      NC,NOSWAP       ; No - Don't swap them
3685   17B1 2F                  CPL                     ; Two's complement
3686   17B2 3C                  INC     A               ;  FP exponent
3687   17B3 EB                  EX      DE,HL
3688   17B4 CD 1A 1A            CALL    STAKFP          ; Put FPREG on stack
3689   17B7 EB                  EX      DE,HL
3690   17B8 CD 2A 1A            CALL    FPBCDE          ; Move BCDE to FPREG
3691   17BB C1                  POP     BC              ; Restore number from stack
3692   17BC D1                  POP     DE
3693   17BD FE 19       NOSWAP: CP      24+1            ; Second number insignificant?
3694   17BF D0                  RET     NC              ; Yes - First number is result
3695   17C0 F5                  PUSH    AF              ; Save number of bits to scale
3696   17C1 CD 4F 1A            CALL    SIGNS           ; Set MSBs & sign of result
3697   17C4 67                  LD      H,A             ; Save sign of result
3698   17C5 F1                  POP     AF              ; Restore scaling factor
3699   17C6 CD 68 18            CALL    SCALE           ; Scale BCDE to same exponent
3700   17C9 B4                  OR      H               ; Result to be positive?
3701   17CA 21 94 31            LD      HL,FPREG        ; Point to FPREG
3702   17CD F2 E3 17            JP      P,MINCDE        ; No - Subtract FPREG from CDE
3703   17D0 CD 48 18            CALL    PLUCDE          ; Add FPREG to CDE
3704   17D3 D2 29 18            JP      NC,RONDUP       ; No overflow - Round it up
3705   17D6 23                  INC     HL              ; Point to exponent
3706   17D7 34                  INC     (HL)            ; Increment it
3707   17D8 CA 51 07            JP      Z,OVERR         ; Number overflowed - Error
3708   17DB 2E 01               LD      L,1             ; 1 bit to shift right
3709   17DD CD 7E 18            CALL    SHRT1           ; Shift result right
3710   17E0 C3 29 18            JP      RONDUP          ; Round it up
3711   17E3             
3712   17E3 AF          MINCDE: XOR     A               ; Clear A and carry
3713   17E4 90                  SUB     B               ; Negate exponent
3714   17E5 47                  LD      B,A             ; Re-save exponent
3715   17E6 7E                  LD      A,(HL)          ; Get LSB of FPREG
3716   17E7 9B                  SBC     A, E            ; Subtract LSB of BCDE
3717   17E8 5F                  LD      E,A             ; Save LSB of BCDE
3718   17E9 23                  INC     HL
3719   17EA 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3720   17EB 9A                  SBC     A,D             ; Subtract NMSB of BCDE
3721   17EC 57                  LD      D,A             ; Save NMSB of BCDE
3722   17ED 23                  INC     HL
3723   17EE 7E                  LD      A,(HL)          ; Get MSB of FPREG
3724   17EF 99                  SBC     A,C             ; Subtract MSB of BCDE
3725   17F0 4F                  LD      C,A             ; Save MSB of BCDE
3726   17F1 DC 54 18    CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
3727   17F4             
3728   17F4 68          BNORM:  LD      L,B             ; L = Exponent
3729   17F5 63                  LD      H,E             ; H = LSB
3730   17F6 AF                  XOR     A
3731   17F7 47          BNRMLP: LD      B,A             ; Save bit count
3732   17F8 79                  LD      A,C             ; Get MSB
3733   17F9 B7                  OR      A               ; Is it zero?
3734   17FA C2 16 18            JP      NZ,PNORM        ; No - Do it bit at a time
3735   17FD 4A                  LD      C,D             ; MSB = NMSB
3736   17FE 54                  LD      D,H             ; NMSB= LSB
3737   17FF 65                  LD      H,L             ; LSB = VLSB
3738   1800 6F                  LD      L,A             ; VLSB= 0
3739   1801 78                  LD      A,B             ; Get exponent
3740   1802 D6 08               SUB     8               ; Count 8 bits
3741   1804 FE E0               CP      -24-8           ; Was number zero?
3742   1806 C2 F7 17            JP      NZ,BNRMLP       ; No - Keep normalising
3743   1809 AF          RESZER: XOR     A               ; Result is zero
3744   180A 32 97 31    SAVEXP: LD      (FPEXP),A       ; Save result as zero
3745   180D C9                  RET
3746   180E             
3747   180E 05          NORMAL: DEC     B               ; Count bits
3748   180F 29                  ADD     HL,HL           ; Shift HL left
3749   1810 7A                  LD      A,D             ; Get NMSB
3750   1811 17                  RLA                     ; Shift left with last bit
3751   1812 57                  LD      D,A             ; Save NMSB
3752   1813 79                  LD      A,C             ; Get MSB
3753   1814 8F                  ADC     A,A             ; Shift left with last bit
3754   1815 4F                  LD      C,A             ; Save MSB
3755   1816 F2 0E 18    PNORM:  JP      P,NORMAL        ; Not done - Keep going
3756   1819 78                  LD      A,B             ; Number of bits shifted
3757   181A 5C                  LD      E,H             ; Save HL in EB
3758   181B 45                  LD      B,L
3759   181C B7                  OR      A               ; Any shifting done?
3760   181D CA 29 18            JP      Z,RONDUP        ; No - Round it up
3761   1820 21 97 31            LD      HL,FPEXP        ; Point to exponent
3762   1823 86                  ADD     A,(HL)          ; Add shifted bits
3763   1824 77                  LD      (HL),A          ; Re-save exponent
3764   1825 D2 09 18            JP      NC,RESZER       ; Underflow - Result is zero
3765   1828 C8                  RET     Z               ; Result is zero
3766   1829 78          RONDUP: LD      A,B             ; Get VLSB of number
3767   182A 21 97 31    RONDB:  LD      HL,FPEXP        ; Point to exponent
3768   182D B7                  OR      A               ; Any rounding?
3769   182E FC 3B 18            CALL    M,FPROND        ; Yes - Round number up
3770   1831 46                  LD      B,(HL)          ; B = Exponent
3771   1832 23                  INC     HL
3772   1833 7E                  LD      A,(HL)          ; Get sign of result
3773   1834 E6 80               AND     10000000B       ; Only bit 7 needed
3774   1836 A9                  XOR     C               ; Set correct sign
3775   1837 4F                  LD      C,A             ; Save correct sign in number
3776   1838 C3 2A 1A            JP      FPBCDE          ; Move BCDE to FPREG
3777   183B             
3778   183B 1C          FPROND: INC     E               ; Round LSB
3779   183C C0                  RET     NZ              ; Return if ok
3780   183D 14                  INC     D               ; Round NMSB
3781   183E C0                  RET     NZ              ; Return if ok
3782   183F 0C                  INC     C               ; Round MSB
3783   1840 C0                  RET     NZ              ; Return if ok
3784   1841 0E 80               LD      C,80H           ; Set normal value
3785   1843 34                  INC     (HL)            ; Increment exponent
3786   1844 C0                  RET     NZ              ; Return if ok
3787   1845 C3 51 07            JP      OVERR           ; Overflow error
3788   1848             
3789   1848 7E          PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
3790   1849 83                  ADD     A,E             ; Add LSB of BCDE
3791   184A 5F                  LD      E,A             ; Save LSB of BCDE
3792   184B 23                  INC     HL
3793   184C 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3794   184D 8A                  ADC     A,D             ; Add NMSB of BCDE
3795   184E 57                  LD      D,A             ; Save NMSB of BCDE
3796   184F 23                  INC     HL
3797   1850 7E                  LD      A,(HL)          ; Get MSB of FPREG
3798   1851 89                  ADC     A,C             ; Add MSB of BCDE
3799   1852 4F                  LD      C,A             ; Save MSB of BCDE
3800   1853 C9                  RET
3801   1854             
3802   1854 21 98 31    COMPL:  LD      HL,SGNRES       ; Sign of result
3803   1857 7E                  LD      A,(HL)          ; Get sign of result
3804   1858 2F                  CPL                     ; Negate it
3805   1859 77                  LD      (HL),A          ; Put it back
3806   185A AF                  XOR     A
3807   185B 6F                  LD      L,A             ; Set L to zero
3808   185C 90                  SUB     B               ; Negate exponent,set carry
3809   185D 47                  LD      B,A             ; Re-save exponent
3810   185E 7D                  LD      A,L             ; Load zero
3811   185F 9B                  SBC     A,E             ; Negate LSB
3812   1860 5F                  LD      E,A             ; Re-save LSB
3813   1861 7D                  LD      A,L             ; Load zero
3814   1862 9A                  SBC     A,D             ; Negate NMSB
3815   1863 57                  LD      D,A             ; Re-save NMSB
3816   1864 7D                  LD      A,L             ; Load zero
3817   1865 99                  SBC     A,C             ; Negate MSB
3818   1866 4F                  LD      C,A             ; Re-save MSB
3819   1867 C9                  RET
3820   1868             
3821   1868 06 00       SCALE:  LD      B,0             ; Clear underflow
3822   186A D6 08       SCALLP: SUB     8               ; 8 bits (a whole byte)?
3823   186C DA 77 18            JP      C,SHRITE        ; No - Shift right A bits
3824   186F 43                  LD      B,E             ; <- Shift
3825   1870 5A                  LD      E,D             ; <- right
3826   1871 51                  LD      D,C             ; <- eight
3827   1872 0E 00               LD      C,0             ; <- bits
3828   1874 C3 6A 18            JP      SCALLP          ; More bits to shift
3829   1877             
3830   1877 C6 09       SHRITE: ADD     A,8+1           ; Adjust count
3831   1879 6F                  LD      L,A             ; Save bits to shift
3832   187A AF          SHRLP:  XOR     A               ; Flag for all done
3833   187B 2D                  DEC     L               ; All shifting done?
3834   187C C8                  RET     Z               ; Yes - Return
3835   187D 79                  LD      A,C             ; Get MSB
3836   187E 1F          SHRT1:  RRA                     ; Shift it right
3837   187F 4F                  LD      C,A             ; Re-save
3838   1880 7A                  LD      A,D             ; Get NMSB
3839   1881 1F                  RRA                     ; Shift right with last bit
3840   1882 57                  LD      D,A             ; Re-save it
3841   1883 7B                  LD      A,E             ; Get LSB
3842   1884 1F                  RRA                     ; Shift right with last bit
3843   1885 5F                  LD      E,A             ; Re-save it
3844   1886 78                  LD      A,B             ; Get underflow
3845   1887 1F                  RRA                     ; Shift right with last bit
3846   1888 47                  LD      B,A             ; Re-save underflow
3847   1889 C3 7A 18            JP      SHRLP           ; More bits to do
3848   188C             
3849   188C 00 00 00 81 UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
3850   1890             
3851   1890 03          LOGTAB: .BYTE      3                       ; Table used by LOG
3852   1891 AA 56 19 80         .BYTE      0AAH,056H,019H,080H     ; 0.59898
3853   1895 F1 22 76 80         .BYTE      0F1H,022H,076H,080H     ; 0.96147
3854   1899 45 AA 38 82         .BYTE      045H,0AAH,038H,082H     ; 2.88539
3855   189D             
3856   189D CD E9 19    LOG:    CALL    TSTSGN          ; Test sign of value
3857   18A0 B7                  OR      A
3858   18A1 EA 61 0C            JP      PE,FCERR        ; ?FC Error if <= zero
3859   18A4 21 97 31            LD      HL,FPEXP        ; Point to exponent
3860   18A7 7E                  LD      A,(HL)          ; Get exponent
3861   18A8 01 35 80            LD      BC,8035H        ; BCDE = SQR(1/2)
3862   18AB 11 F3 04            LD      DE,04F3H
3863   18AE 90                  SUB     B               ; Scale value to be < 1
3864   18AF F5                  PUSH    AF              ; Save scale factor
3865   18B0 70                  LD      (HL),B          ; Save new exponent
3866   18B1 D5                  PUSH    DE              ; Save SQR(1/2)
3867   18B2 C5                  PUSH    BC
3868   18B3 CD A3 17            CALL    FPADD           ; Add SQR(1/2) to value
3869   18B6 C1                  POP     BC              ; Restore SQR(1/2)
3870   18B7 D1                  POP     DE
3871   18B8 04                  INC     B               ; Make it SQR(2)
3872   18B9 CD 3F 19            CALL    DVBCDE          ; Divide by SQR(2)
3873   18BC 21 8C 18            LD      HL,UNITY        ; Point to 1.
3874   18BF CD 9A 17            CALL    SUBPHL          ; Subtract FPREG from 1
3875   18C2 21 90 18            LD      HL,LOGTAB       ; Coefficient table
3876   18C5 CD 31 1D            CALL    SUMSER          ; Evaluate sum of series
3877   18C8 01 80 80            LD      BC,8080H        ; BCDE = -0.5
3878   18CB 11 00 00            LD      DE,0000H
3879   18CE CD A3 17            CALL    FPADD           ; Subtract 0.5 from FPREG
3880   18D1 F1                  POP     AF              ; Restore scale factor
3881   18D2 CD 64 1B            CALL    RSCALE          ; Re-scale number
3882   18D5 01 31 80    MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3883   18D8 11 18 72            LD      DE,7218H
3884   18DB 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3885   18DC             
3886   18DC C1          MULT:   POP     BC              ; Get number from stack
3887   18DD D1                  POP     DE
3888   18DE CD E9 19    FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3889   18E1 C8                  RET     Z               ; Return zero if zero
3890   18E2 2E 00               LD      L,0             ; Flag add exponents
3891   18E4 CD A7 19            CALL    ADDEXP          ; Add exponents
3892   18E7 79                  LD      A,C             ; Get MSB of multiplier
3893   18E8 32 A6 31            LD      (MULVAL),A      ; Save MSB of multiplier
3894   18EB EB                  EX      DE,HL
3895   18EC 22 A7 31            LD      (MULVAL+1),HL   ; Save rest of multiplier
3896   18EF 01 00 00            LD      BC,0            ; Partial product (BCDE) = zero
3897   18F2 50                  LD      D,B
3898   18F3 58                  LD      E,B
3899   18F4 21 F4 17            LD      HL,BNORM        ; Address of normalise
3900   18F7 E5                  PUSH    HL              ; Save for return
3901   18F8 21 00 19            LD      HL,MULT8        ; Address of 8 bit multiply
3902   18FB E5                  PUSH    HL              ; Save for NMSB,MSB
3903   18FC E5                  PUSH    HL              ; 
3904   18FD 21 94 31            LD      HL,FPREG        ; Point to number
3905   1900 7E          MULT8:  LD      A,(HL)          ; Get LSB of number
3906   1901 23                  INC     HL              ; Point to NMSB
3907   1902 B7                  OR      A               ; Test LSB
3908   1903 CA 2C 19            JP      Z,BYTSFT        ; Zero - shift to next byte
3909   1906 E5                  PUSH    HL              ; Save address of number
3910   1907 2E 08               LD      L,8             ; 8 bits to multiply by
3911   1909 1F          MUL8LP: RRA                     ; Shift LSB right
3912   190A 67                  LD      H,A             ; Save LSB
3913   190B 79                  LD      A,C             ; Get MSB
3914   190C D2 1A 19            JP      NC,NOMADD       ; Bit was zero - Don't add
3915   190F E5                  PUSH    HL              ; Save LSB and count
3916   1910 2A A7 31            LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3917   1913 19                  ADD     HL,DE           ; Add NMSB and LSB
3918   1914 EB                  EX      DE,HL           ; Leave sum in DE
3919   1915 E1                  POP     HL              ; Restore MSB and count
3920   1916 3A A6 31            LD      A,(MULVAL)      ; Get MSB of multiplier
3921   1919 89                  ADC     A,C             ; Add MSB
3922   191A 1F          NOMADD: RRA                     ; Shift MSB right
3923   191B 4F                  LD      C,A             ; Re-save MSB
3924   191C 7A                  LD      A,D             ; Get NMSB
3925   191D 1F                  RRA                     ; Shift NMSB right
3926   191E 57                  LD      D,A             ; Re-save NMSB
3927   191F 7B                  LD      A,E             ; Get LSB
3928   1920 1F                  RRA                     ; Shift LSB right
3929   1921 5F                  LD      E,A             ; Re-save LSB
3930   1922 78                  LD      A,B             ; Get VLSB
3931   1923 1F                  RRA                     ; Shift VLSB right
3932   1924 47                  LD      B,A             ; Re-save VLSB
3933   1925 2D                  DEC     L               ; Count bits multiplied
3934   1926 7C                  LD      A,H             ; Get LSB of multiplier
3935   1927 C2 09 19            JP      NZ,MUL8LP       ; More - Do it
3936   192A E1          POPHRT: POP     HL              ; Restore address of number
3937   192B C9                  RET
3938   192C             
3939   192C 43          BYTSFT: LD      B,E             ; Shift partial product left
3940   192D 5A                  LD      E,D
3941   192E 51                  LD      D,C
3942   192F 4F                  LD      C,A
3943   1930 C9                  RET
3944   1931             
3945   1931 CD 1A 1A    DIV10:  CALL    STAKFP          ; Save FPREG on stack
3946   1934 01 20 84            LD      BC,8420H        ; BCDE = 10.
3947   1937 11 00 00            LD      DE,0000H
3948   193A CD 2A 1A            CALL    FPBCDE          ; Move 10 to FPREG
3949   193D             
3950   193D C1          DIV:    POP     BC              ; Get number from stack
3951   193E D1                  POP     DE
3952   193F CD E9 19    DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
3953   1942 CA 45 07            JP      Z,DZERR         ; Error if division by zero
3954   1945 2E FF               LD      L,-1            ; Flag subtract exponents
3955   1947 CD A7 19            CALL    ADDEXP          ; Subtract exponents
3956   194A 34                  INC     (HL)            ; Add 2 to exponent to adjust
3957   194B 34                  INC     (HL)
3958   194C 2B                  DEC     HL              ; Point to MSB
3959   194D 7E                  LD      A,(HL)          ; Get MSB of dividend
3960   194E 32 C2 30            LD      (DIV3),A        ; Save for subtraction
3961   1951 2B                  DEC     HL
3962   1952 7E                  LD      A,(HL)          ; Get NMSB of dividend
3963   1953 32 BE 30            LD      (DIV2),A        ; Save for subtraction
3964   1956 2B                  DEC     HL
3965   1957 7E                  LD      A,(HL)          ; Get MSB of dividend
3966   1958 32 BA 30            LD      (DIV1),A        ; Save for subtraction
3967   195B 41                  LD      B,C             ; Get MSB
3968   195C EB                  EX      DE,HL           ; NMSB,LSB to HL
3969   195D AF                  XOR     A
3970   195E 4F                  LD      C,A             ; Clear MSB of quotient
3971   195F 57                  LD      D,A             ; Clear NMSB of quotient
3972   1960 5F                  LD      E,A             ; Clear LSB of quotient
3973   1961 32 C5 30            LD      (DIV4),A        ; Clear overflow count
3974   1964 E5          DIVLP:  PUSH    HL              ; Save divisor
3975   1965 C5                  PUSH    BC
3976   1966 7D                  LD      A,L             ; Get LSB of number
3977   1967 CD B9 30            CALL    DIVSUP          ; Subt' divisor from dividend
3978   196A DE 00               SBC     A,0             ; Count for overflows
3979   196C 3F                  CCF
3980   196D D2 77 19            JP      NC,RESDIV       ; Restore divisor if borrow
3981   1970 32 C5 30            LD      (DIV4),A        ; Re-save overflow count
3982   1973 F1                  POP     AF              ; Scrap divisor
3983   1974 F1                  POP     AF
3984   1975 37                  SCF                     ; Set carry to
3985   1976 D2                  .BYTE      0D2H            ; Skip "POP BC" and "POP HL"
3986   1977             
3987   1977 C1          RESDIV: POP     BC              ; Restore divisor
3988   1978 E1                  POP     HL
3989   1979 79                  LD      A,C             ; Get MSB of quotient
3990   197A 3C                  INC     A
3991   197B 3D                  DEC     A
3992   197C 1F                  RRA                     ; Bit 0 to bit 7
3993   197D FA 2A 18            JP      M,RONDB         ; Done - Normalise result
3994   1980 17                  RLA                     ; Restore carry
3995   1981 7B                  LD      A,E             ; Get LSB of quotient
3996   1982 17                  RLA                     ; Double it
3997   1983 5F                  LD      E,A             ; Put it back
3998   1984 7A                  LD      A,D             ; Get NMSB of quotient
3999   1985 17                  RLA                     ; Double it
4000   1986 57                  LD      D,A             ; Put it back
4001   1987 79                  LD      A,C             ; Get MSB of quotient
4002   1988 17                  RLA                     ; Double it
4003   1989 4F                  LD      C,A             ; Put it back
4004   198A 29                  ADD     HL,HL           ; Double NMSB,LSB of divisor
4005   198B 78                  LD      A,B             ; Get MSB of divisor
4006   198C 17                  RLA                     ; Double it
4007   198D 47                  LD      B,A             ; Put it back
4008   198E 3A C5 30            LD      A,(DIV4)        ; Get VLSB of quotient
4009   1991 17                  RLA                     ; Double it
4010   1992 32 C5 30            LD      (DIV4),A        ; Put it back
4011   1995 79                  LD      A,C             ; Get MSB of quotient
4012   1996 B2                  OR      D               ; Merge NMSB
4013   1997 B3                  OR      E               ; Merge LSB
4014   1998 C2 64 19            JP      NZ,DIVLP        ; Not done - Keep dividing
4015   199B E5                  PUSH    HL              ; Save divisor
4016   199C 21 97 31            LD      HL,FPEXP        ; Point to exponent
4017   199F 35                  DEC     (HL)            ; Divide by 2
4018   19A0 E1                  POP     HL              ; Restore divisor
4019   19A1 C2 64 19            JP      NZ,DIVLP        ; Ok - Keep going
4020   19A4 C3 51 07            JP      OVERR           ; Overflow error
4021   19A7             
4022   19A7 78          ADDEXP: LD      A,B             ; Get exponent of dividend
4023   19A8 B7                  OR      A               ; Test it
4024   19A9 CA CB 19            JP      Z,OVTST3        ; Zero - Result zero
4025   19AC 7D                  LD      A,L             ; Get add/subtract flag
4026   19AD 21 97 31            LD      HL,FPEXP        ; Point to exponent
4027   19B0 AE                  XOR     (HL)            ; Add or subtract it
4028   19B1 80                  ADD     A,B             ; Add the other exponent
4029   19B2 47                  LD      B,A             ; Save new exponent
4030   19B3 1F                  RRA                     ; Test exponent for overflow
4031   19B4 A8                  XOR     B
4032   19B5 78                  LD      A,B             ; Get exponent
4033   19B6 F2 CA 19            JP      P,OVTST2        ; Positive - Test for overflow
4034   19B9 C6 80               ADD     A,80H           ; Add excess 128
4035   19BB 77                  LD      (HL),A          ; Save new exponent
4036   19BC CA 2A 19            JP      Z,POPHRT        ; Zero - Result zero
4037   19BF CD 4F 1A            CALL    SIGNS           ; Set MSBs and sign of result
4038   19C2 77                  LD      (HL),A          ; Save new exponent
4039   19C3 2B                  DEC     HL              ; Point to MSB
4040   19C4 C9                  RET
4041   19C5             
4042   19C5 CD E9 19    OVTST1: CALL    TSTSGN          ; Test sign of FPREG
4043   19C8 2F                  CPL                     ; Invert sign
4044   19C9 E1                  POP     HL              ; Clean up stack
4045   19CA B7          OVTST2: OR      A               ; Test if new exponent zero
4046   19CB E1          OVTST3: POP     HL              ; Clear off return address
4047   19CC F2 09 18            JP      P,RESZER        ; Result zero
4048   19CF C3 51 07            JP      OVERR           ; Overflow error
4049   19D2             
4050   19D2 CD 35 1A    MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
4051   19D5 78                  LD      A,B             ; Get exponent
4052   19D6 B7                  OR      A               ; Is it zero?
4053   19D7 C8                  RET     Z               ; Yes - Result is zero
4054   19D8 C6 02               ADD     A,2             ; Multiply by 4
4055   19DA DA 51 07            JP      C,OVERR         ; Overflow - ?OV Error
4056   19DD 47                  LD      B,A             ; Re-save exponent
4057   19DE CD A3 17            CALL    FPADD           ; Add BCDE to FPREG (Times 5)
4058   19E1 21 97 31            LD      HL,FPEXP        ; Point to exponent
4059   19E4 34                  INC     (HL)            ; Double number (Times 10)
4060   19E5 C0                  RET     NZ              ; Ok - Return
4061   19E6 C3 51 07            JP      OVERR           ; Overflow error
4062   19E9             
4063   19E9 3A 97 31    TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
4064   19EC B7                  OR      A
4065   19ED C8                  RET     Z               ; RETurn if number is zero
4066   19EE 3A 96 31            LD      A,(FPREG+2)     ; Get MSB of FPREG
4067   19F1 FE                  .BYTE      0FEH            ; Test sign
4068   19F2 2F          RETREL: CPL                     ; Invert sign
4069   19F3 17                  RLA                     ; Sign bit to carry
4070   19F4 9F          FLGDIF: SBC     A,A             ; Carry to all bits of A
4071   19F5 C0                  RET     NZ              ; Return -1 if negative
4072   19F6 3C                  INC     A               ; Bump to +1
4073   19F7 C9                  RET                     ; Positive - Return +1
4074   19F8             
4075   19F8 CD E9 19    SGN:    CALL    TSTSGN          ; Test sign of FPREG
4076   19FB 06 88       FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
4077   19FD 11 00 00            LD      DE,0            ; Zero NMSB and LSB
4078   1A00 21 97 31    RETINT: LD      HL,FPEXP        ; Point to exponent
4079   1A03 4F                  LD      C,A             ; CDE = MSB,NMSB and LSB
4080   1A04 70                  LD      (HL),B          ; Save exponent
4081   1A05 06 00               LD      B,0             ; CDE = integer to normalise
4082   1A07 23                  INC     HL              ; Point to sign of result
4083   1A08 36 80               LD      (HL),80H        ; Set sign of result
4084   1A0A 17                  RLA                     ; Carry = sign of integer
4085   1A0B C3 F1 17            JP      CONPOS          ; Set sign of result
4086   1A0E             
4087   1A0E CD E9 19    ABS:    CALL    TSTSGN          ; Test sign of FPREG
4088   1A11 F0                  RET     P               ; Return if positive
4089   1A12 21 96 31    INVSGN: LD      HL,FPREG+2      ; Point to MSB
4090   1A15 7E                  LD      A,(HL)          ; Get sign of mantissa
4091   1A16 EE 80               XOR     80H             ; Invert sign of mantissa
4092   1A18 77                  LD      (HL),A          ; Re-save sign of mantissa
4093   1A19 C9                  RET
4094   1A1A             
4095   1A1A EB          STAKFP: EX      DE,HL           ; Save code string address
4096   1A1B 2A 94 31            LD      HL,(FPREG)      ; LSB,NLSB of FPREG
4097   1A1E E3                  EX      (SP),HL         ; Stack them,get return
4098   1A1F E5                  PUSH    HL              ; Re-save return
4099   1A20 2A 96 31            LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
4100   1A23 E3                  EX      (SP),HL         ; Stack them,get return
4101   1A24 E5                  PUSH    HL              ; Re-save return
4102   1A25 EB                  EX      DE,HL           ; Restore code string address
4103   1A26 C9                  RET
4104   1A27             
4105   1A27 CD 38 1A    PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
4106   1A2A EB          FPBCDE: EX      DE,HL           ; Save code string address
4107   1A2B 22 94 31            LD      (FPREG),HL      ; Save LSB,NLSB of number
4108   1A2E 60                  LD      H,B             ; Exponent of number
4109   1A2F 69                  LD      L,C             ; MSB of number
4110   1A30 22 96 31            LD      (FPREG+2),HL    ; Save MSB and exponent
4111   1A33 EB                  EX      DE,HL           ; Restore code string address
4112   1A34 C9                  RET
4113   1A35             
4114   1A35 21 94 31    BCDEFP: LD      HL,FPREG        ; Point to FPREG
4115   1A38 5E          LOADFP: LD      E,(HL)          ; Get LSB of number
4116   1A39 23                  INC     HL
4117   1A3A 56                  LD      D,(HL)          ; Get NMSB of number
4118   1A3B 23                  INC     HL
4119   1A3C 4E                  LD      C,(HL)          ; Get MSB of number
4120   1A3D 23                  INC     HL
4121   1A3E 46                  LD      B,(HL)          ; Get exponent of number
4122   1A3F 23          INCHL:  INC     HL              ; Used for conditional "INC HL"
4123   1A40 C9                  RET
4124   1A41             
4125   1A41 11 94 31    FPTHL:  LD      DE,FPREG        ; Point to FPREG
4126   1A44 06 04       DETHL4: LD      B,4             ; 4 bytes to move
4127   1A46 1A          DETHLB: LD      A,(DE)          ; Get source
4128   1A47 77                  LD      (HL),A          ; Save destination
4129   1A48 13                  INC     DE              ; Next source
4130   1A49 23                  INC     HL              ; Next destination
4131   1A4A 05                  DEC     B               ; Count bytes
4132   1A4B C2 46 1A            JP      NZ,DETHLB       ; Loop if more
4133   1A4E C9                  RET
4134   1A4F             
4135   1A4F 21 96 31    SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
4136   1A52 7E                  LD      A,(HL)          ; Get MSB
4137   1A53 07                  RLCA                    ; Old sign to carry
4138   1A54 37                  SCF                     ; Set MSBit
4139   1A55 1F                  RRA                     ; Set MSBit of MSB
4140   1A56 77                  LD      (HL),A          ; Save new MSB
4141   1A57 3F                  CCF                     ; Complement sign
4142   1A58 1F                  RRA                     ; Old sign to carry
4143   1A59 23                  INC     HL
4144   1A5A 23                  INC     HL
4145   1A5B 77                  LD      (HL),A          ; Set sign of result
4146   1A5C 79                  LD      A,C             ; Get MSB
4147   1A5D 07                  RLCA                    ; Old sign to carry
4148   1A5E 37                  SCF                     ; Set MSBit
4149   1A5F 1F                  RRA                     ; Set MSBit of MSB
4150   1A60 4F                  LD      C,A             ; Save MSB
4151   1A61 1F                  RRA
4152   1A62 AE                  XOR     (HL)            ; New sign of result
4153   1A63 C9                  RET
4154   1A64             
4155   1A64 78          CMPNUM: LD      A,B             ; Get exponent of number
4156   1A65 B7                  OR      A
4157   1A66 CA E9 19            JP      Z,TSTSGN        ; Zero - Test sign of FPREG
4158   1A69 21 F2 19            LD      HL,RETREL       ; Return relation routine
4159   1A6C E5                  PUSH    HL              ; Save for return
4160   1A6D CD E9 19            CALL    TSTSGN          ; Test sign of FPREG
4161   1A70 79                  LD      A,C             ; Get MSB of number
4162   1A71 C8                  RET     Z               ; FPREG zero - Number's MSB
4163   1A72 21 96 31            LD      HL,FPREG+2      ; MSB of FPREG
4164   1A75 AE                  XOR     (HL)            ; Combine signs
4165   1A76 79                  LD      A,C             ; Get MSB of number
4166   1A77 F8                  RET     M               ; Exit if signs different
4167   1A78 CD 7E 1A            CALL    CMPFP           ; Compare FP numbers
4168   1A7B 1F                  RRA                     ; Get carry to sign
4169   1A7C A9                  XOR     C               ; Combine with MSB of number
4170   1A7D C9                  RET
4171   1A7E             
4172   1A7E 23          CMPFP:  INC     HL              ; Point to exponent
4173   1A7F 78                  LD      A,B             ; Get exponent
4174   1A80 BE                  CP      (HL)            ; Compare exponents
4175   1A81 C0                  RET     NZ              ; Different
4176   1A82 2B                  DEC     HL              ; Point to MBS
4177   1A83 79                  LD      A,C             ; Get MSB
4178   1A84 BE                  CP      (HL)            ; Compare MSBs
4179   1A85 C0                  RET     NZ              ; Different
4180   1A86 2B                  DEC     HL              ; Point to NMSB
4181   1A87 7A                  LD      A,D             ; Get NMSB
4182   1A88 BE                  CP      (HL)            ; Compare NMSBs
4183   1A89 C0                  RET     NZ              ; Different
4184   1A8A 2B                  DEC     HL              ; Point to LSB
4185   1A8B 7B                  LD      A,E             ; Get LSB
4186   1A8C 96                  SUB     (HL)            ; Compare LSBs
4187   1A8D C0                  RET     NZ              ; Different
4188   1A8E E1                  POP     HL              ; Drop RETurn
4189   1A8F E1                  POP     HL              ; Drop another RETurn
4190   1A90 C9                  RET
4191   1A91             
4192   1A91 47          FPINT:  LD      B,A             ; <- Move
4193   1A92 4F                  LD      C,A             ; <- exponent
4194   1A93 57                  LD      D,A             ; <- to all
4195   1A94 5F                  LD      E,A             ; <- bits
4196   1A95 B7                  OR      A               ; Test exponent
4197   1A96 C8                  RET     Z               ; Zero - Return zero
4198   1A97 E5                  PUSH    HL              ; Save pointer to number
4199   1A98 CD 35 1A            CALL    BCDEFP          ; Move FPREG to BCDE
4200   1A9B CD 4F 1A            CALL    SIGNS           ; Set MSBs & sign of result
4201   1A9E AE                  XOR     (HL)            ; Combine with sign of FPREG
4202   1A9F 67                  LD      H,A             ; Save combined signs
4203   1AA0 FC B5 1A            CALL    M,DCBCDE        ; Negative - Decrement BCDE
4204   1AA3 3E 98               LD      A,80H+24        ; 24 bits
4205   1AA5 90                  SUB     B               ; Bits to shift
4206   1AA6 CD 68 18            CALL    SCALE           ; Shift BCDE
4207   1AA9 7C                  LD      A,H             ; Get combined sign
4208   1AAA 17                  RLA                     ; Sign to carry
4209   1AAB DC 3B 18            CALL    C,FPROND        ; Negative - Round number up
4210   1AAE 06 00               LD      B,0             ; Zero exponent
4211   1AB0 DC 54 18            CALL    C,COMPL         ; If negative make positive
4212   1AB3 E1                  POP     HL              ; Restore pointer to number
4213   1AB4 C9                  RET
4214   1AB5             
4215   1AB5 1B          DCBCDE: DEC     DE              ; Decrement BCDE
4216   1AB6 7A                  LD      A,D             ; Test LSBs
4217   1AB7 A3                  AND     E
4218   1AB8 3C                  INC     A
4219   1AB9 C0                  RET     NZ              ; Exit if LSBs not FFFF
4220   1ABA 0B                  DEC     BC              ; Decrement MSBs
4221   1ABB C9                  RET
4222   1ABC             
4223   1ABC 21 97 31    INT:    LD      HL,FPEXP        ; Point to exponent
4224   1ABF 7E                  LD      A,(HL)          ; Get exponent
4225   1AC0 FE 98               CP      80H+24          ; Integer accuracy only?
4226   1AC2 3A 94 31            LD      A,(FPREG)       ; Get LSB
4227   1AC5 D0                  RET     NC              ; Yes - Already integer
4228   1AC6 7E                  LD      A,(HL)          ; Get exponent
4229   1AC7 CD 91 1A            CALL    FPINT           ; F.P to integer
4230   1ACA 36 98               LD      (HL),80H+24     ; Save 24 bit integer
4231   1ACC 7B                  LD      A,E             ; Get LSB of number
4232   1ACD F5                  PUSH    AF              ; Save LSB
4233   1ACE 79                  LD      A,C             ; Get MSB of number
4234   1ACF 17                  RLA                     ; Sign to carry
4235   1AD0 CD F1 17            CALL    CONPOS          ; Set sign of result
4236   1AD3 F1                  POP     AF              ; Restore LSB of number
4237   1AD4 C9                  RET
4238   1AD5             
4239   1AD5 21 00 00    MLDEBC: LD      HL,0            ; Clear partial product
4240   1AD8 78                  LD      A,B             ; Test multiplier
4241   1AD9 B1                  OR      C
4242   1ADA C8                  RET     Z               ; Return zero if zero
4243   1ADB 3E 10               LD      A,16            ; 16 bits
4244   1ADD 29          MLDBLP: ADD     HL,HL           ; Shift P.P left
4245   1ADE DA 15 13            JP      C,BSERR         ; ?BS Error if overflow
4246   1AE1 EB                  EX      DE,HL
4247   1AE2 29                  ADD     HL,HL           ; Shift multiplier left
4248   1AE3 EB                  EX      DE,HL
4249   1AE4 D2 EB 1A            JP      NC,NOMLAD       ; Bit was zero - No add
4250   1AE7 09                  ADD     HL,BC           ; Add multiplicand
4251   1AE8 DA 15 13            JP      C,BSERR         ; ?BS Error if overflow
4252   1AEB 3D          NOMLAD: DEC     A               ; Count bits
4253   1AEC C2 DD 1A            JP      NZ,MLDBLP       ; More
4254   1AEF C9                  RET
4255   1AF0             
4256   1AF0 FE 2D       ASCTFP: CP      '-'             ; Negative?
4257   1AF2 F5                  PUSH    AF              ; Save it and flags
4258   1AF3 CA FC 1A            JP      Z,CNVNUM        ; Yes - Convert number
4259   1AF6 FE 2B               CP      '+'             ; Positive?
4260   1AF8 CA FC 1A            JP      Z,CNVNUM        ; Yes - Convert number
4261   1AFB 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
4262   1AFC CD 09 18    CNVNUM: CALL    RESZER          ; Set result to zero
4263   1AFF 47                  LD      B,A             ; Digits after point counter
4264   1B00 57                  LD      D,A             ; Sign of exponent
4265   1B01 5F                  LD      E,A             ; Exponent of ten
4266   1B02 2F                  CPL
4267   1B03 4F                  LD      C,A             ; Before or after point flag
4268   1B04 CD 9A 0B    MANLP:  CALL    GETCHR          ; Get next character
4269   1B07 DA 4D 1B            JP      C,ADDIG         ; Digit - Add to number
4270   1B0A FE 2E               CP      '.'
4271   1B0C CA 28 1B            JP      Z,DPOINT        ; '.' - Flag point
4272   1B0F FE 45               CP      'E'
4273   1B11 C2 2C 1B            JP      NZ,CONEXP       ; Not 'E' - Scale number
4274   1B14 CD 9A 0B            CALL    GETCHR          ; Get next character
4275   1B17 CD 40 11            CALL    SGNEXP          ; Get sign of exponent
4276   1B1A CD 9A 0B    EXPLP:  CALL    GETCHR          ; Get next character
4277   1B1D DA 6F 1B            JP      C,EDIGIT        ; Digit - Add to exponent
4278   1B20 14                  INC     D               ; Is sign negative?
4279   1B21 C2 2C 1B            JP      NZ,CONEXP       ; No - Scale number
4280   1B24 AF                  XOR     A
4281   1B25 93                  SUB     E               ; Negate exponent
4282   1B26 5F                  LD      E,A             ; And re-save it
4283   1B27 0C                  INC     C               ; Flag end of number
4284   1B28 0C          DPOINT: INC     C               ; Flag point passed
4285   1B29 CA 04 1B            JP      Z,MANLP         ; Zero - Get another digit
4286   1B2C E5          CONEXP: PUSH    HL              ; Save code string address
4287   1B2D 7B                  LD      A,E             ; Get exponent
4288   1B2E 90                  SUB     B               ; Subtract digits after point
4289   1B2F F4 45 1B    SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
4290   1B32 F2 3B 1B            JP      P,ENDCON        ; Positive - All done
4291   1B35 F5                  PUSH    AF              ; Save number of times to /10
4292   1B36 CD 31 19            CALL    DIV10           ; Divide by 10
4293   1B39 F1                  POP     AF              ; Restore count
4294   1B3A 3C                  INC     A               ; Count divides
4295   1B3B             
4296   1B3B C2 2F 1B    ENDCON: JP      NZ,SCALMI       ; More to do
4297   1B3E D1                  POP     DE              ; Restore code string address
4298   1B3F F1                  POP     AF              ; Restore sign of number
4299   1B40 CC 12 1A            CALL    Z,INVSGN        ; Negative - Negate number
4300   1B43 EB                  EX      DE,HL           ; Code string address to HL
4301   1B44 C9                  RET
4302   1B45             
4303   1B45 C8          SCALPL: RET     Z               ; Exit if no scaling needed
4304   1B46 F5          MULTEN: PUSH    AF              ; Save count
4305   1B47 CD D2 19            CALL    MLSP10          ; Multiply number by 10
4306   1B4A F1                  POP     AF              ; Restore count
4307   1B4B 3D                  DEC     A               ; Count multiplies
4308   1B4C C9                  RET
4309   1B4D             
4310   1B4D D5          ADDIG:  PUSH    DE              ; Save sign of exponent
4311   1B4E 57                  LD      D,A             ; Save digit
4312   1B4F 78                  LD      A,B             ; Get digits after point
4313   1B50 89                  ADC     A,C             ; Add one if after point
4314   1B51 47                  LD      B,A             ; Re-save counter
4315   1B52 C5                  PUSH    BC              ; Save point flags
4316   1B53 E5                  PUSH    HL              ; Save code string address
4317   1B54 D5                  PUSH    DE              ; Save digit
4318   1B55 CD D2 19            CALL    MLSP10          ; Multiply number by 10
4319   1B58 F1                  POP     AF              ; Restore digit
4320   1B59 D6 30               SUB     '0'             ; Make it absolute
4321   1B5B CD 64 1B            CALL    RSCALE          ; Re-scale number
4322   1B5E E1                  POP     HL              ; Restore code string address
4323   1B5F C1                  POP     BC              ; Restore point flags
4324   1B60 D1                  POP     DE              ; Restore sign of exponent
4325   1B61 C3 04 1B            JP      MANLP           ; Get another digit
4326   1B64             
4327   1B64 CD 1A 1A    RSCALE: CALL    STAKFP          ; Put number on stack
4328   1B67 CD FB 19            CALL    FLGREL          ; Digit to add to FPREG
4329   1B6A C1          PADD:   POP     BC              ; Restore number
4330   1B6B D1                  POP     DE
4331   1B6C C3 A3 17            JP      FPADD           ; Add BCDE to FPREG and return
4332   1B6F             
4333   1B6F 7B          EDIGIT: LD      A,E             ; Get digit
4334   1B70 07                  RLCA                    ; Times 2
4335   1B71 07                  RLCA                    ; Times 4
4336   1B72 83                  ADD     A,E             ; Times 5
4337   1B73 07                  RLCA                    ; Times 10
4338   1B74 86                  ADD     A,(HL)          ; Add next digit
4339   1B75 D6 30               SUB     '0'             ; Make it absolute
4340   1B77 5F                  LD      E,A             ; Save new digit
4341   1B78 C3 1A 1B            JP      EXPLP           ; Look for another digit
4342   1B7B             
4343   1B7B E5          LINEIN: PUSH    HL              ; Save code string address
4344   1B7C 21 DA 06            LD      HL,INMSG        ; Output " in "
4345   1B7F CD E0 14            CALL    PRS             ; Output string at HL
4346   1B82 E1                  POP     HL              ; Restore code string address
4347   1B83 EB          PRNTHL: EX      DE,HL           ; Code string address to DE
4348   1B84 AF                  XOR     A
4349   1B85 06 98               LD      B,80H+24        ; 24 bits
4350   1B87 CD 00 1A            CALL    RETINT          ; Return the integer
4351   1B8A 21 DF 14            LD      HL,PRNUMS       ; Print number string
4352   1B8D E5                  PUSH    HL              ; Save for return
4353   1B8E 21 99 31    NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
4354   1B91 E5                  PUSH    HL              ; Save for return
4355   1B92 CD E9 19            CALL    TSTSGN          ; Test sign of FPREG
4356   1B95 36 20               LD      (HL),' '        ; Space at start
4357   1B97 F2 9C 1B            JP      P,SPCFST        ; Positive - Space to start
4358   1B9A 36 2D               LD      (HL),'-'        ; '-' sign at start
4359   1B9C 23          SPCFST: INC     HL              ; First byte of number
4360   1B9D 36 30               LD      (HL),'0'        ; '0' if zero
4361   1B9F CA 52 1C            JP      Z,JSTZER        ; Return '0' if zero
4362   1BA2 E5                  PUSH    HL              ; Save buffer address
4363   1BA3 FC 12 1A            CALL    M,INVSGN        ; Negate FPREG if negative
4364   1BA6 AF                  XOR     A               ; Zero A
4365   1BA7 F5                  PUSH    AF              ; Save it
4366   1BA8 CD 58 1C            CALL    RNGTST          ; Test number is in range
4367   1BAB 01 43 91    SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
4368   1BAE 11 F8 4F            LD      DE,4FF8H
4369   1BB1 CD 64 1A            CALL    CMPNUM          ; Compare numbers
4370   1BB4 B7                  OR      A
4371   1BB5 E2 C9 1B            JP      PO,INRNG        ; > 99999.9 - Sort it out
4372   1BB8 F1                  POP     AF              ; Restore count
4373   1BB9 CD 46 1B            CALL    MULTEN          ; Multiply by ten
4374   1BBC F5                  PUSH    AF              ; Re-save count
4375   1BBD C3 AB 1B            JP      SIXDIG          ; Test it again
4376   1BC0             
4377   1BC0 CD 31 19    GTSIXD: CALL    DIV10           ; Divide by 10
4378   1BC3 F1                  POP     AF              ; Get count
4379   1BC4 3C                  INC     A               ; Count divides
4380   1BC5 F5                  PUSH    AF              ; Re-save count
4381   1BC6 CD 58 1C            CALL    RNGTST          ; Test number is in range
4382   1BC9 CD 91 17    INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
4383   1BCC 3C                  INC     A
4384   1BCD CD 91 1A            CALL    FPINT           ; F.P to integer
4385   1BD0 CD 2A 1A            CALL    FPBCDE          ; Move BCDE to FPREG
4386   1BD3 01 06 03            LD      BC,0306H        ; 1E+06 to 1E-03 range
4387   1BD6 F1                  POP     AF              ; Restore count
4388   1BD7 81                  ADD     A,C             ; 6 digits before point
4389   1BD8 3C                  INC     A               ; Add one
4390   1BD9 FA E5 1B            JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
4391   1BDC FE 08               CP      6+1+1           ; More than 999999 ?
4392   1BDE D2 E5 1B            JP      NC,MAKNUM       ; Yes - Do it in 'E' form
4393   1BE1 3C                  INC     A               ; Adjust for exponent
4394   1BE2 47                  LD      B,A             ; Exponent of number
4395   1BE3 3E 02               LD      A,2             ; Make it zero after
4396   1BE5             
4397   1BE5 3D          MAKNUM: DEC     A               ; Adjust for digits to do
4398   1BE6 3D                  DEC     A
4399   1BE7 E1                  POP     HL              ; Restore buffer address
4400   1BE8 F5                  PUSH    AF              ; Save count
4401   1BE9 11 6B 1C            LD      DE,POWERS       ; Powers of ten
4402   1BEC 05                  DEC     B               ; Count digits before point
4403   1BED C2 F6 1B            JP      NZ,DIGTXT       ; Not zero - Do number
4404   1BF0 36 2E               LD      (HL),'.'        ; Save point
4405   1BF2 23                  INC     HL              ; Move on
4406   1BF3 36 30               LD      (HL),'0'        ; Save zero
4407   1BF5 23                  INC     HL              ; Move on
4408   1BF6 05          DIGTXT: DEC     B               ; Count digits before point
4409   1BF7 36 2E               LD      (HL),'.'        ; Save point in case
4410   1BF9 CC 3F 1A            CALL    Z,INCHL         ; Last digit - move on
4411   1BFC C5                  PUSH    BC              ; Save digits before point
4412   1BFD E5                  PUSH    HL              ; Save buffer address
4413   1BFE D5                  PUSH    DE              ; Save powers of ten
4414   1BFF CD 35 1A            CALL    BCDEFP          ; Move FPREG to BCDE
4415   1C02 E1                  POP     HL              ; Powers of ten table
4416   1C03 06 2F               LD      B, '0'-1        ; ASCII '0' - 1
4417   1C05 04          TRYAGN: INC     B               ; Count subtractions
4418   1C06 7B                  LD      A,E             ; Get LSB
4419   1C07 96                  SUB     (HL)            ; Subtract LSB
4420   1C08 5F                  LD      E,A             ; Save LSB
4421   1C09 23                  INC     HL
4422   1C0A 7A                  LD      A,D             ; Get NMSB
4423   1C0B 9E                  SBC     A,(HL)          ; Subtract NMSB
4424   1C0C 57                  LD      D,A             ; Save NMSB
4425   1C0D 23                  INC     HL
4426   1C0E 79                  LD      A,C             ; Get MSB
4427   1C0F 9E                  SBC     A,(HL)          ; Subtract MSB
4428   1C10 4F                  LD      C,A             ; Save MSB
4429   1C11 2B                  DEC     HL              ; Point back to start
4430   1C12 2B                  DEC     HL
4431   1C13 D2 05 1C            JP      NC,TRYAGN       ; No overflow - Try again
4432   1C16 CD 48 18            CALL    PLUCDE          ; Restore number
4433   1C19 23                  INC     HL              ; Start of next number
4434   1C1A CD 2A 1A            CALL    FPBCDE          ; Move BCDE to FPREG
4435   1C1D EB                  EX      DE,HL           ; Save point in table
4436   1C1E E1                  POP     HL              ; Restore buffer address
4437   1C1F 70                  LD      (HL),B          ; Save digit in buffer
4438   1C20 23                  INC     HL              ; And move on
4439   1C21 C1                  POP     BC              ; Restore digit count
4440   1C22 0D                  DEC     C               ; Count digits
4441   1C23 C2 F6 1B            JP      NZ,DIGTXT       ; More - Do them
4442   1C26 05                  DEC     B               ; Any decimal part?
4443   1C27 CA 36 1C            JP      Z,DOEBIT        ; No - Do 'E' bit
4444   1C2A 2B          SUPTLZ: DEC     HL              ; Move back through buffer
4445   1C2B 7E                  LD      A,(HL)          ; Get character
4446   1C2C FE 30               CP      '0'             ; '0' character?
4447   1C2E CA 2A 1C            JP      Z,SUPTLZ        ; Yes - Look back for more
4448   1C31 FE 2E               CP      '.'             ; A decimal point?
4449   1C33 C4 3F 1A            CALL    NZ,INCHL        ; Move back over digit
4450   1C36             
4451   1C36 F1          DOEBIT: POP     AF              ; Get 'E' flag
4452   1C37 CA 55 1C            JP      Z,NOENED        ; No 'E' needed - End buffer
4453   1C3A 36 45               LD      (HL),'E'        ; Put 'E' in buffer
4454   1C3C 23                  INC     HL              ; And move on
4455   1C3D 36 2B               LD      (HL),'+'        ; Put '+' in buffer
4456   1C3F F2 46 1C            JP      P,OUTEXP        ; Positive - Output exponent
4457   1C42 36 2D               LD      (HL),'-'        ; Put '-' in buffer
4458   1C44 2F                  CPL                     ; Negate exponent
4459   1C45 3C                  INC     A
4460   1C46 06 2F       OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
4461   1C48 04          EXPTEN: INC     B               ; Count subtractions
4462   1C49 D6 0A               SUB     10              ; Tens digit
4463   1C4B D2 48 1C            JP      NC,EXPTEN       ; More to do
4464   1C4E C6 3A               ADD     A,'0'+10        ; Restore and make ASCII
4465   1C50 23                  INC     HL              ; Move on
4466   1C51 70                  LD      (HL),B          ; Save MSB of exponent
4467   1C52 23          JSTZER: INC     HL              ;
4468   1C53 77                  LD      (HL),A          ; Save LSB of exponent
4469   1C54 23                  INC     HL
4470   1C55 71          NOENED: LD      (HL),C          ; Mark end of buffer
4471   1C56 E1                  POP     HL              ; Restore code string address
4472   1C57 C9                  RET
4473   1C58             
4474   1C58 01 74 94    RNGTST: LD      BC,9474H        ; BCDE = 999999.
4475   1C5B 11 F7 23            LD      DE,23F7H
4476   1C5E CD 64 1A            CALL    CMPNUM          ; Compare numbers
4477   1C61 B7                  OR      A
4478   1C62 E1                  POP     HL              ; Return address to HL
4479   1C63 E2 C0 1B            JP      PO,GTSIXD       ; Too big - Divide by ten
4480   1C66 E9                  JP      (HL)            ; Otherwise return to caller
4481   1C67             
4482   1C67 00 00 00 80 HALF:   .BYTE      00H,00H,00H,80H ; 0.5
4483   1C6B             
4484   1C6B A0 86 01    POWERS: .BYTE      0A0H,086H,001H  ; 100000
4485   1C6E 10 27 00            .BYTE      010H,027H,000H  ;  10000
4486   1C71 E8 03 00            .BYTE      0E8H,003H,000H  ;   1000
4487   1C74 64 00 00            .BYTE      064H,000H,000H  ;    100
4488   1C77 0A 00 00            .BYTE      00AH,000H,000H  ;     10
4489   1C7A 01 00 00            .BYTE      001H,000H,000H  ;      1
4490   1C7D             
4491   1C7D 21 12 1A    NEGAFT: LD  HL,INVSGN           ; Negate result
4492   1C80 E3                  EX      (SP),HL         ; To be done after caller
4493   1C81 E9                  JP      (HL)            ; Return to caller
4494   1C82             
4495   1C82 CD 1A 1A    SQR:    CALL    STAKFP          ; Put value on stack
4496   1C85 21 67 1C            LD      HL,HALF         ; Set power to 1/2
4497   1C88 CD 27 1A            CALL    PHLTFP          ; Move 1/2 to FPREG
4498   1C8B             
4499   1C8B C1          POWER:  POP     BC              ; Get base
4500   1C8C D1                  POP     DE
4501   1C8D CD E9 19            CALL    TSTSGN          ; Test sign of power
4502   1C90 78                  LD      A,B             ; Get exponent of base
4503   1C91 CA D0 1C            JP      Z,EXP           ; Make result 1 if zero
4504   1C94 F2 9B 1C            JP      P,POWER1        ; Positive base - Ok
4505   1C97 B7                  OR      A               ; Zero to negative power?
4506   1C98 CA 45 07            JP      Z,DZERR         ; Yes - ?/0 Error
4507   1C9B B7          POWER1: OR      A               ; Base zero?
4508   1C9C CA 0A 18            JP      Z,SAVEXP        ; Yes - Return zero
4509   1C9F D5                  PUSH    DE              ; Save base
4510   1CA0 C5                  PUSH    BC
4511   1CA1 79                  LD      A,C             ; Get MSB of base
4512   1CA2 F6 7F               OR      01111111B       ; Get sign status
4513   1CA4 CD 35 1A            CALL    BCDEFP          ; Move power to BCDE
4514   1CA7 F2 B8 1C            JP      P,POWER2        ; Positive base - Ok
4515   1CAA D5                  PUSH    DE              ; Save power
4516   1CAB C5                  PUSH    BC
4517   1CAC CD BC 1A            CALL    INT             ; Get integer of power
4518   1CAF C1                  POP     BC              ; Restore power
4519   1CB0 D1                  POP     DE
4520   1CB1 F5                  PUSH    AF              ; MSB of base
4521   1CB2 CD 64 1A            CALL    CMPNUM          ; Power an integer?
4522   1CB5 E1                  POP     HL              ; Restore MSB of base
4523   1CB6 7C                  LD      A,H             ; but don't affect flags
4524   1CB7 1F                  RRA                     ; Exponent odd or even?
4525   1CB8 E1          POWER2: POP     HL              ; Restore MSB and exponent
4526   1CB9 22 96 31            LD      (FPREG+2),HL    ; Save base in FPREG
4527   1CBC E1                  POP     HL              ; LSBs of base
4528   1CBD 22 94 31            LD      (FPREG),HL      ; Save in FPREG
4529   1CC0 DC 7D 1C            CALL    C,NEGAFT        ; Odd power - Negate result
4530   1CC3 CC 12 1A            CALL    Z,INVSGN        ; Negative base - Negate it
4531   1CC6 D5                  PUSH    DE              ; Save power
4532   1CC7 C5                  PUSH    BC
4533   1CC8 CD 9D 18            CALL    LOG             ; Get LOG of base
4534   1CCB C1                  POP     BC              ; Restore power
4535   1CCC D1                  POP     DE
4536   1CCD CD DE 18            CALL    FPMULT          ; Multiply LOG by power
4537   1CD0             
4538   1CD0 CD 1A 1A    EXP:    CALL    STAKFP          ; Put value on stack
4539   1CD3 01 38 81            LD      BC,08138H       ; BCDE = 1/Ln(2)
4540   1CD6 11 3B AA            LD      DE,0AA3BH
4541   1CD9 CD DE 18            CALL    FPMULT          ; Multiply value by 1/LN(2)
4542   1CDC 3A 97 31            LD      A,(FPEXP)       ; Get exponent
4543   1CDF FE 88               CP      80H+8           ; Is it in range?
4544   1CE1 D2 C5 19            JP      NC,OVTST1       ; No - Test for overflow
4545   1CE4 CD BC 1A            CALL    INT             ; Get INT of FPREG
4546   1CE7 C6 80               ADD     A,80H           ; For excess 128
4547   1CE9 C6 02               ADD     A,2             ; Exponent > 126?
4548   1CEB DA C5 19            JP      C,OVTST1        ; Yes - Test for overflow
4549   1CEE F5                  PUSH    AF              ; Save scaling factor
4550   1CEF 21 8C 18            LD      HL,UNITY        ; Point to 1.
4551   1CF2 CD 94 17            CALL    ADDPHL          ; Add 1 to FPREG
4552   1CF5 CD D5 18            CALL    MULLN2          ; Multiply by LN(2)
4553   1CF8 F1                  POP     AF              ; Restore scaling factor
4554   1CF9 C1                  POP     BC              ; Restore exponent
4555   1CFA D1                  POP     DE
4556   1CFB F5                  PUSH    AF              ; Save scaling factor
4557   1CFC CD A0 17            CALL    SUBCDE          ; Subtract exponent from FPREG
4558   1CFF CD 12 1A            CALL    INVSGN          ; Negate result
4559   1D02 21 10 1D            LD      HL,EXPTAB       ; Coefficient table
4560   1D05 CD 40 1D            CALL    SMSER1          ; Sum the series
4561   1D08 11 00 00            LD      DE,0            ; Zero LSBs
4562   1D0B C1                  POP     BC              ; Scaling factor
4563   1D0C 4A                  LD      C,D             ; Zero MSB
4564   1D0D C3 DE 18            JP      FPMULT          ; Scale result to correct value
4565   1D10             
4566   1D10 08          EXPTAB: .BYTE      8                       ; Table used by EXP
4567   1D11 40 2E 94 74         .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
4568   1D15 70 4F 2E 77         .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
4569   1D19 6E 02 88 7A         .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
4570   1D1D E6 A0 2A 7C         .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
4571   1D21 50 AA AA 7E         .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
4572   1D25 FF FF 7F 7F         .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
4573   1D29 00 00 80 81         .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
4574   1D2D 00 00 00 81         .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
4575   1D31             
4576   1D31 CD 1A 1A    SUMSER: CALL    STAKFP          ; Put FPREG on stack
4577   1D34 11 DC 18            LD      DE,MULT         ; Multiply by "X"
4578   1D37 D5                  PUSH    DE              ; To be done after
4579   1D38 E5                  PUSH    HL              ; Save address of table
4580   1D39 CD 35 1A            CALL    BCDEFP          ; Move FPREG to BCDE
4581   1D3C CD DE 18            CALL    FPMULT          ; Square the value
4582   1D3F E1                  POP     HL              ; Restore address of table
4583   1D40 CD 1A 1A    SMSER1: CALL    STAKFP          ; Put value on stack
4584   1D43 7E                  LD      A,(HL)          ; Get number of coefficients
4585   1D44 23                  INC     HL              ; Point to start of table
4586   1D45 CD 27 1A            CALL    PHLTFP          ; Move coefficient to FPREG
4587   1D48 06                  .BYTE      06H             ; Skip "POP AF"
4588   1D49 F1          SUMLP:  POP     AF              ; Restore count
4589   1D4A C1                  POP     BC              ; Restore number
4590   1D4B D1                  POP     DE
4591   1D4C 3D                  DEC     A               ; Cont coefficients
4592   1D4D C8                  RET     Z               ; All done
4593   1D4E D5                  PUSH    DE              ; Save number
4594   1D4F C5                  PUSH    BC
4595   1D50 F5                  PUSH    AF              ; Save count
4596   1D51 E5                  PUSH    HL              ; Save address in table
4597   1D52 CD DE 18            CALL    FPMULT          ; Multiply FPREG by BCDE
4598   1D55 E1                  POP     HL              ; Restore address in table
4599   1D56 CD 38 1A            CALL    LOADFP          ; Number at HL to BCDE
4600   1D59 E5                  PUSH    HL              ; Save address in table
4601   1D5A CD A3 17            CALL    FPADD           ; Add coefficient to FPREG
4602   1D5D E1                  POP     HL              ; Restore address in table
4603   1D5E C3 49 1D            JP      SUMLP           ; More coefficients
4604   1D61             
4605   1D61 CD E9 19    RND:    CALL    TSTSGN          ; Test sign of FPREG
4606   1D64 21 C9 30            LD      HL,SEED+2       ; Random number seed
4607   1D67 FA C2 1D            JP      M,RESEED        ; Negative - Re-seed
4608   1D6A 21 EA 30            LD      HL,LSTRND       ; Last random number
4609   1D6D CD 27 1A            CALL    PHLTFP          ; Move last RND to FPREG
4610   1D70 21 C9 30            LD      HL,SEED+2       ; Random number seed
4611   1D73 C8                  RET     Z               ; Return if RND(0)
4612   1D74 86                  ADD     A,(HL)          ; Add (SEED)+2)
4613   1D75 E6 07               AND     00000111B       ; 0 to 7
4614   1D77 06 00               LD      B,0
4615   1D79 77                  LD      (HL),A          ; Re-save seed
4616   1D7A 23                  INC     HL              ; Move to coefficient table
4617   1D7B 87                  ADD     A,A             ; 4 bytes
4618   1D7C 87                  ADD     A,A             ; per entry
4619   1D7D 4F                  LD      C,A             ; BC = Offset into table
4620   1D7E 09                  ADD     HL,BC           ; Point to coefficient
4621   1D7F CD 38 1A            CALL    LOADFP          ; Coefficient to BCDE
4622   1D82 CD DE 18            CALL    FPMULT  ;       ; Multiply FPREG by coefficient
4623   1D85 3A C8 30            LD      A,(SEED+1)      ; Get (SEED+1)
4624   1D88 3C                  INC     A               ; Add 1
4625   1D89 E6 03               AND     00000011B       ; 0 to 3
4626   1D8B 06 00               LD      B,0
4627   1D8D FE 01               CP      1               ; Is it zero?
4628   1D8F 88                  ADC     A,B             ; Yes - Make it 1
4629   1D90 32 C8 30            LD      (SEED+1),A      ; Re-save seed
4630   1D93 21 C6 1D            LD      HL,RNDTAB-4     ; Addition table
4631   1D96 87                  ADD     A,A             ; 4 bytes
4632   1D97 87                  ADD     A,A             ; per entry
4633   1D98 4F                  LD      C,A             ; BC = Offset into table
4634   1D99 09                  ADD     HL,BC           ; Point to value
4635   1D9A CD 94 17            CALL    ADDPHL          ; Add value to FPREG
4636   1D9D CD 35 1A    RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
4637   1DA0 7B                  LD      A,E             ; Get LSB
4638   1DA1 59                  LD      E,C             ; LSB = MSB
4639   1DA2 EE 4F               XOR     01001111B       ; Fiddle around
4640   1DA4 4F                  LD      C,A             ; New MSB
4641   1DA5 36 80               LD      (HL),80H        ; Set exponent
4642   1DA7 2B                  DEC     HL              ; Point to MSB
4643   1DA8 46                  LD      B,(HL)          ; Get MSB
4644   1DA9 36 80               LD      (HL),80H        ; Make value -0.5
4645   1DAB 21 C7 30            LD      HL,SEED         ; Random number seed
4646   1DAE 34                  INC     (HL)            ; Count seed
4647   1DAF 7E                  LD      A,(HL)          ; Get seed
4648   1DB0 D6 AB               SUB     171             ; Do it modulo 171
4649   1DB2 C2 B9 1D            JP      NZ,RND2         ; Non-zero - Ok
4650   1DB5 77                  LD      (HL),A          ; Zero seed
4651   1DB6 0C                  INC     C               ; Fillde about
4652   1DB7 15                  DEC     D               ; with the
4653   1DB8 1C                  INC     E               ; number
4654   1DB9 CD F4 17    RND2:   CALL    BNORM           ; Normalise number
4655   1DBC 21 EA 30            LD      HL,LSTRND       ; Save random number
4656   1DBF C3 41 1A            JP      FPTHL           ; Move FPREG to last and return
4657   1DC2             
4658   1DC2 77          RESEED: LD      (HL),A          ; Re-seed random numbers
4659   1DC3 2B                  DEC     HL
4660   1DC4 77                  LD      (HL),A
4661   1DC5 2B                  DEC     HL
4662   1DC6 77                  LD      (HL),A
4663   1DC7 C3 9D 1D            JP      RND1            ; Return RND seed
4664   1DCA             
4665   1DCA 68 B1 46 68 RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
4666   1DCE 99 E9 92 69         .BYTE   099H,0E9H,092H,069H
4667   1DD2 10 D1 75 68         .BYTE   010H,0D1H,075H,068H
4668   1DD6             
4669   1DD6 21 20 1E    COS:    LD      HL,HALFPI       ; Point to PI/2
4670   1DD9 CD 94 17            CALL    ADDPHL          ; Add it to PPREG
4671   1DDC CD 1A 1A    SIN:    CALL    STAKFP          ; Put angle on stack
4672   1DDF 01 49 83            LD      BC,8349H        ; BCDE = 2 PI
4673   1DE2 11 DB 0F            LD      DE,0FDBH
4674   1DE5 CD 2A 1A            CALL    FPBCDE          ; Move 2 PI to FPREG
4675   1DE8 C1                  POP     BC              ; Restore angle
4676   1DE9 D1                  POP     DE
4677   1DEA CD 3F 19            CALL    DVBCDE          ; Divide angle by 2 PI
4678   1DED CD 1A 1A            CALL    STAKFP          ; Put it on stack
4679   1DF0 CD BC 1A            CALL    INT             ; Get INT of result
4680   1DF3 C1                  POP     BC              ; Restore number
4681   1DF4 D1                  POP     DE
4682   1DF5 CD A0 17            CALL    SUBCDE          ; Make it 0 <= value < 1
4683   1DF8 21 24 1E            LD      HL,QUARTR       ; Point to 0.25
4684   1DFB CD 9A 17            CALL    SUBPHL          ; Subtract value from 0.25
4685   1DFE CD E9 19            CALL    TSTSGN          ; Test sign of value
4686   1E01 37                  SCF                     ; Flag positive
4687   1E02 F2 0C 1E            JP      P,SIN1          ; Positive - Ok
4688   1E05 CD 91 17            CALL    ROUND           ; Add 0.5 to value
4689   1E08 CD E9 19            CALL    TSTSGN          ; Test sign of value
4690   1E0B B7                  OR      A               ; Flag negative
4691   1E0C F5          SIN1:   PUSH    AF              ; Save sign
4692   1E0D F4 12 1A            CALL    P,INVSGN        ; Negate value if positive
4693   1E10 21 24 1E            LD      HL,QUARTR       ; Point to 0.25
4694   1E13 CD 94 17            CALL    ADDPHL          ; Add 0.25 to value
4695   1E16 F1                  POP     AF              ; Restore sign
4696   1E17 D4 12 1A            CALL    NC,INVSGN       ; Negative - Make positive
4697   1E1A 21 28 1E            LD      HL,SINTAB       ; Coefficient table
4698   1E1D C3 31 1D            JP      SUMSER          ; Evaluate sum of series
4699   1E20             
4700   1E20 DB 0F 49 81 HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
4701   1E24             
4702   1E24 00 00 00 7F QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
4703   1E28             
4704   1E28 05          SINTAB: .BYTE   5                       ; Table used by SIN
4705   1E29 BA D7 1E 86         .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
4706   1E2D 64 26 99 87         .BYTE   064H,026H,099H,087H     ;-76.575
4707   1E31 58 34 23 87         .BYTE   058H,034H,023H,087H     ; 81.602
4708   1E35 E0 5D A5 86         .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
4709   1E39 DA 0F 49 83         .BYTE   0DAH,00FH,049H,083H     ;  6.2832
4710   1E3D             
4711   1E3D CD 1A 1A    TAN:    CALL    STAKFP          ; Put angle on stack
4712   1E40 CD DC 1D            CALL    SIN             ; Get SIN of angle
4713   1E43 C1                  POP     BC              ; Restore angle
4714   1E44 E1                  POP     HL
4715   1E45 CD 1A 1A            CALL    STAKFP          ; Save SIN of angle
4716   1E48 EB                  EX      DE,HL           ; BCDE = Angle
4717   1E49 CD 2A 1A            CALL    FPBCDE          ; Angle to FPREG
4718   1E4C CD D6 1D            CALL    COS             ; Get COS of angle
4719   1E4F C3 3D 19            JP      DIV             ; TAN = SIN / COS
4720   1E52             
4721   1E52 CD E9 19    ATN:    CALL    TSTSGN          ; Test sign of value
4722   1E55 FC 7D 1C            CALL    M,NEGAFT        ; Negate result after if -ve
4723   1E58 FC 12 1A            CALL    M,INVSGN        ; Negate value if -ve
4724   1E5B 3A 97 31            LD      A,(FPEXP)       ; Get exponent
4725   1E5E FE 81               CP      81H             ; Number less than 1?
4726   1E60 DA 6F 1E            JP      C,ATN1          ; Yes - Get arc tangnt
4727   1E63 01 00 81            LD      BC,8100H        ; BCDE = 1
4728   1E66 51                  LD      D,C
4729   1E67 59                  LD      E,C
4730   1E68 CD 3F 19            CALL    DVBCDE          ; Get reciprocal of number
4731   1E6B 21 9A 17            LD      HL,SUBPHL       ; Sub angle from PI/2
4732   1E6E E5                  PUSH    HL              ; Save for angle > 1
4733   1E6F 21 79 1E    ATN1:   LD      HL,ATNTAB       ; Coefficient table
4734   1E72 CD 31 1D            CALL    SUMSER          ; Evaluate sum of series
4735   1E75 21 20 1E            LD      HL,HALFPI       ; PI/2 - angle in case > 1
4736   1E78 C9                  RET                     ; Number > 1 - Sub from PI/2
4737   1E79             
4738   1E79 09          ATNTAB: .BYTE   9                       ; Table used by ATN
4739   1E7A 4A D7 3B 78         .BYTE   04AH,0D7H,03BH,078H     ; 1/17
4740   1E7E 02 6E 84 7B         .BYTE   002H,06EH,084H,07BH     ;-1/15
4741   1E82 FE C1 2F 7C         .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
4742   1E86 74 31 9A 7D         .BYTE   074H,031H,09AH,07DH     ;-1/11
4743   1E8A 84 3D 5A 7D         .BYTE   084H,03DH,05AH,07DH     ; 1/9
4744   1E8E C8 7F 91 7E         .BYTE   0C8H,07FH,091H,07EH     ;-1/7
4745   1E92 E4 BB 4C 7E         .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
4746   1E96 6C AA AA 7F         .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
4747   1E9A 00 00 00 81         .BYTE   000H,000H,000H,081H     ; 1/1
4748   1E9E             
4749   1E9E             
4750   1E9E C9          ARET:   RET                     ; A RETurn instruction
4751   1E9F             
4752   1E9F D7          GETINP: RST	    10H             ;input a character
4753   1EA0 C9                  RET
4754   1EA1             
4755   1EA1             CLS: 
4756   1EA1 3E 0C               LD      A,CS            ; ASCII Clear screen
4757   1EA3 C3 DB 1F            JP      MONOUT          ; Output character
4758   1EA6             
4759   1EA6 CD 68 17    WIDTH:  CALL    GETINT          ; Get integer 0-255
4760   1EA9 7B                  LD      A,E             ; Width to A
4761   1EAA 32 F2 30            LD      (LWIDTH),A      ; Set width
4762   1EAD C9                  RET
4763   1EAE             
4764   1EAE CD 07 10    LINES:  CALL    GETNUM          ; Get a number
4765   1EB1 CD 4C 0C            CALL    DEINT           ; Get integer -32768 to 32767
4766   1EB4 ED 53 F6 30         LD      (LINESC),DE     ; Set lines counter
4767   1EB8 ED 53 F8 30         LD      (LINESN),DE     ; Set lines number
4768   1EBC C9                  RET
4769   1EBD             
4770   1EBD CD 4C 0C    DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
4771   1EC0 D5                  PUSH    DE              ; Save number
4772   1EC1 E1                  POP     HL              ; Number to HL
4773   1EC2 46                  LD      B,(HL)          ; Get LSB of contents
4774   1EC3 23                  INC     HL
4775   1EC4 7E                  LD      A,(HL)          ; Get MSB of contents
4776   1EC5 C3 C2 13            JP      ABPASS          ; Return integer AB
4777   1EC8             
4778   1EC8 CD 07 10    DOKE:   CALL    GETNUM          ; Get a number
4779   1ECB CD 4C 0C            CALL    DEINT           ; Get integer -32768 to 32767
4780   1ECE D5                  PUSH    DE              ; Save address
4781   1ECF CD 10 0A            CALL    CHKSYN          ; Make sure ',' follows
4782   1ED2 2C                  .BYTE      ','
4783   1ED3 CD 07 10            CALL    GETNUM          ; Get a number
4784   1ED6 CD 4C 0C            CALL    DEINT           ; Get integer -32768 to 32767
4785   1ED9 E3                  EX      (SP),HL         ; Save value,get address
4786   1EDA 73                  LD      (HL),E          ; Save LSB of value
4787   1EDB 23                  INC     HL
4788   1EDC 72                  LD      (HL),D          ; Save MSB of value
4789   1EDD E1                  POP     HL              ; Restore code string address
4790   1EDE C9                  RET
4791   1EDF             
4792   1EDF             
4793   1EDF             ; HEX$(nn) Convert 16 bit number to Hexadecimal string
4794   1EDF             
4795   1EDF CD 0A 10    HEX: 	CALL	TSTNUM          ; Verify it's a number
4796   1EE2 CD 4C 0C            CALL	DEINT           ; Get integer -32768 to 32767
4797   1EE5 C5                  PUSH	BC              ; Save contents of BC
4798   1EE6 21 99 31            LD	    HL,PBUFF
4799   1EE9 7A                  LD	    A,D             ; Get high order into A
4800   1EEA FE 00               CP      $0
4801   1EEC 28 0C       		JR      Z,HEX2          ; Skip output if both high digits are zero
4802   1EEE CD 17 1F            CALL    BYT2ASC         ; Convert D to ASCII
4803   1EF1 78          		LD      A,B
4804   1EF2 FE 30       		CP      '0'
4805   1EF4 28 02       		JR      Z,HEX1          ; Don't store high digit if zero
4806   1EF6 70                  LD	    (HL),B          ; Store it to PBUFF
4807   1EF7 23                  INC	    HL              ; Next location
4808   1EF8 71          HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
4809   1EF9 23                  INC     HL              ; Next location
4810   1EFA 7B          HEX2:   LD	    A,E             ; Get lower byte
4811   1EFB CD 17 1F            CALL    BYT2ASC         ; Convert E to ASCII
4812   1EFE 7A          		LD      A,D
4813   1EFF FE 00               CP      $0
4814   1F01 20 05       		JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
4815   1F03 78          		LD      A,B
4816   1F04 FE 30       		CP      '0'             ; If high digit of lower byte is zero then don't print
4817   1F06 28 02       		JR      Z,HEX4
4818   1F08 70          HEX3:   LD      (HL),B          ; to PBUFF+2
4819   1F09 23                  INC     HL              ; Next location
4820   1F0A 71          HEX4:   LD      (HL),C          ; to PBUFF+3
4821   1F0B 23                  INC     HL              ; PBUFF+4 to zero
4822   1F0C AF                  XOR     A               ; Terminating character
4823   1F0D 77                  LD      (HL),A          ; Store zero to terminate
4824   1F0E 23                  INC     HL              ; Make sure PBUFF is terminated
4825   1F0F 77                  LD      (HL),A          ; Store the double zero there
4826   1F10 C1                  POP     BC              ; Get BC back
4827   1F11 21 99 31            LD      HL,PBUFF        ; Reset to start of PBUFF
4828   1F14 C3 70 14            JP      STR1            ; Convert the PBUFF to a string and return it
4829   1F17             
4830   1F17 47          BYT2ASC	LD      B,A             ; Save original value
4831   1F18 E6 0F               AND     $0F             ; Strip off upper nybble
4832   1F1A FE 0A               CP      $0A             ; 0-9?
4833   1F1C 38 02               JR      C,ADD30         ; If A-F, add 7 more
4834   1F1E C6 07               ADD     A,$07           ; Bring value up to ASCII A-F
4835   1F20 C6 30       ADD30	ADD     A,$30           ; And make ASCII
4836   1F22 4F                  LD      C,A             ; Save converted char to C
4837   1F23 78                  LD      A,B             ; Retrieve original value
4838   1F24 0F                  RRCA                    ; and Rotate it right
4839   1F25 0F                  RRCA
4840   1F26 0F                  RRCA
4841   1F27 0F                  RRCA
4842   1F28 E6 0F               AND     $0F             ; Mask off upper nybble
4843   1F2A FE 0A               CP      $0A             ; 0-9? < A hex?
4844   1F2C 38 02               JR      C,ADD301        ; Skip Add 7
4845   1F2E C6 07               ADD     A,$07           ; Bring it up to ASCII A-F
4846   1F30 C6 30       ADD301	ADD     A,$30           ; And make it full ASCII
4847   1F32 47                  LD      B,A             ; Store high order byte
4848   1F33 C9                  RET	
4849   1F34             
4850   1F34             ; Convert "&Hnnnn" to FPREG
4851   1F34             ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
4852   1F34             ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
4853   1F34 EB          HEXTFP  EX      DE,HL           ; Move code string pointer to DE
4854   1F35 21 00 00            LD      HL,$0000        ; Zero out the value
4855   1F38 CD 4D 1F            CALL    GETHEX          ; Check the number for valid hex
4856   1F3B DA 6D 1F            JP      C,HXERR         ; First value wasn't hex, HX error
4857   1F3E 18 05               JR      HEXLP1          ; Convert first character
4858   1F40 CD 4D 1F    HEXLP   CALL    GETHEX          ; Get second and addtional characters
4859   1F43 38 1F               JR      C,HEXIT         ; Exit if not a hex character
4860   1F45 29          HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
4861   1F46 29                  ADD     HL,HL
4862   1F47 29                  ADD     HL,HL
4863   1F48 29                  ADD     HL,HL
4864   1F49 B5                  OR      L               ; Add in D0-D3 into L
4865   1F4A 6F                  LD      L,A             ; Save new value
4866   1F4B 18 F3               JR      HEXLP           ; And continue until all hex characters are in
4867   1F4D             
4868   1F4D 13          GETHEX  INC     DE              ; Next location
4869   1F4E 1A                  LD      A,(DE)          ; Load character at pointer
4870   1F4F FE 20               CP      ' '
4871   1F51 CA 4D 1F            JP      Z,GETHEX        ; Skip spaces
4872   1F54 D6 30               SUB     $30             ; Get absolute value
4873   1F56 D8                  RET     C               ; < "0", error
4874   1F57 FE 0A               CP      $0A
4875   1F59 38 05               JR      C,NOSUB7        ; Is already in the range 0-9
4876   1F5B D6 07               SUB     $07             ; Reduce to A-F
4877   1F5D FE 0A               CP      $0A             ; Value should be $0A-$0F at this point
4878   1F5F D8                  RET     C               ; CY set if was :            ; < = > ? @
4879   1F60 FE 10       NOSUB7  CP      $10             ; > Greater than "F"?
4880   1F62 3F                  CCF
4881   1F63 C9                  RET                     ; CY set if it wasn't valid hex
4882   1F64                 
4883   1F64 EB          HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
4884   1F65 7A                  LD      A,D             ; Load DE into AC
4885   1F66 4B                  LD      C,E             ; For prep to 
4886   1F67 E5                  PUSH    HL
4887   1F68 CD C1 13            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4888   1F6B E1                  POP     HL
4889   1F6C C9                  RET
4890   1F6D             
4891   1F6D 1E 26       HXERR:  LD      E,HX            ; ?HEX Error
4892   1F6F C3 56 07            JP      ERROR
4893   1F72             
4894   1F72             ; BIN$(NN) Convert integer to a 1-16 char binary string
4895   1F72 CD 0A 10    BIN:    CALL    TSTNUM          ; Verify it's a number
4896   1F75 CD 4C 0C            CALL    DEINT           ; Get integer -32768 to 32767
4897   1F78 C5          BIN2:   PUSH    BC              ; Save contents of BC
4898   1F79 21 99 31            LD      HL,PBUFF
4899   1F7C 06 11               LD      B,17            ; One higher than max char count
4900   1F7E             ZEROSUP:                        ; Suppress leading zeros
4901   1F7E 05                  DEC     B               ; Max 16 chars
4902   1F7F 78                  LD      A,B
4903   1F80 FE 01               CP      $01
4904   1F82 28 08               JR      Z,BITOUT        ; Always output at least one character
4905   1F84 CB 13               RL      E
4906   1F86 CB 12               RL      D
4907   1F88 30 F4               JR      NC,ZEROSUP
4908   1F8A 18 04               JR      BITOUT2
4909   1F8C             BITOUT:      
4910   1F8C CB 13               RL      E
4911   1F8E CB 12               RL      D               ; Top bit now in carry
4912   1F90             BITOUT2:
4913   1F90 3E 30               LD      A,'0'           ; Char for '0'
4914   1F92 CE 00               ADC     A,0             ; If carry set then '0' --> '1'
4915   1F94 77                  LD      (HL),A
4916   1F95 23                  INC     HL
4917   1F96 05                  DEC     B
4918   1F97 20 F3               JR      NZ,BITOUT
4919   1F99 AF                  XOR     A               ; Terminating character
4920   1F9A 77                  LD      (HL),A          ; Store zero to terminate
4921   1F9B 23                  INC     HL              ; Make sure PBUFF is terminated
4922   1F9C 77                  LD      (HL),A          ; Store the double zero there
4923   1F9D C1                  POP     BC
4924   1F9E 21 99 31            LD      HL,PBUFF
4925   1FA1 C3 70 14            JP      STR1
4926   1FA4             
4927   1FA4             ; Convert "&Bnnnn" to FPREG
4928   1FA4             ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
4929   1FA4 EB          BINTFP: EX      DE,HL           ; Move code string pointer to DE
4930   1FA5 21 00 00            LD      HL,$0000        ; Zero out the value
4931   1FA8 CD C1 1F            CALL    CHKBIN          ; Check the number for valid bin
4932   1FAB DA CF 1F            JP      C,BINERR        ; First value wasn't bin, HX error
4933   1FAE D6 30       BINIT:  SUB     '0'
4934   1FB0 29                  ADD     HL,HL           ; Rotate HL left
4935   1FB1 B5                  OR      L
4936   1FB2 6F                  LD      L,A
4937   1FB3 CD C1 1F            CALL    CHKBIN          ; Get second and addtional characters
4938   1FB6 30 F6               JR      NC,BINIT        ; Process if a bin character
4939   1FB8 EB                  EX      DE,HL           ; Value into DE, Code string into HL
4940   1FB9 7A                  LD      A,D             ; Load DE into AC
4941   1FBA 4B                  LD      C,E             ; For prep to 
4942   1FBB E5                  PUSH    HL
4943   1FBC CD C1 13            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4944   1FBF E1                  POP     HL
4945   1FC0 C9                  RET
4946   1FC1             
4947   1FC1             ; Char is in A, NC if char is 0 or 1
4948   1FC1 13          CHKBIN: INC     DE
4949   1FC2 1A                  LD      A,(DE)
4950   1FC3 FE 20               CP      ' '
4951   1FC5 CA C1 1F            JP      Z,CHKBIN        ; Skip spaces
4952   1FC8 FE 30               CP      '0'             ; Set C if < '0'
4953   1FCA D8                  RET     C
4954   1FCB FE 32               CP      '2'
4955   1FCD 3F                  CCF                     ; Set C if > '1'
4956   1FCE C9                  RET
4957   1FCF             
4958   1FCF 1E 28       BINERR: LD      E,BN            ; ?BIN Error
4959   1FD1 C3 56 07            JP      ERROR
4960   1FD4             
4961   1FD4             
4962   1FD4             JJUMP1: 
4963   1FD4 DD 21 FF FF         LD      IX,-1           ; Flag cold start
4964   1FD8 C3 A6 03            JP      CSTART          ; Go and initialise
4965   1FDB             
4966   1FDB             MONOUT: 
4967   1FDB C3 08 00            JP      $0008           ; output a char
4968   1FDE             
4969   1FDE             
4970   1FDE             MONITR: 
4971   1FDE C3 00 00            JP      $0000           ; Restart (Normally Monitor Start)
4972   1FE1             
4973   1FE1             
4974   1FE1 3E 00       INITST: LD      A,0             ; Clear break flag
4975   1FE3 32 FD 30            LD      (BRKFLG),A
4976   1FE6 C3 AD 03            JP      INIT
4977   1FE9             
4978   1FE9 ED 45       ARETN:  RETN                    ; Return from NMI
4979   1FEB             
4980   1FEB             
4981   1FEB F5          TSTBIT: PUSH    AF              ; Save bit mask
4982   1FEC A0                  AND     B               ; Get common bits
4983   1FED C1                  POP     BC              ; Restore bit mask
4984   1FEE B8                  CP      B               ; Same bit set?
4985   1FEF 3E 00               LD      A,0             ; Return 0 in A
4986   1FF1 C9                  RET
4987   1FF2             
4988   1FF2 CD 1B 0A    OUTNCR: CALL    OUTC            ; Output character in A
4989   1FF5 C3 42 0E            JP      PRNTCRLF        ; Output CRLF
4990   1FF8             
4991   1FF8             .end
4992   1FF8             
tasm: Number of errors = 0
